// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;
using Pulumi;

namespace Pulumiverse.Scaleway.Kubernetes.Outputs
{

    [OutputType]
    public sealed class ClusterAutoscalerConfig
    {
        /// <summary>
        /// Detect similar node groups and balance the number of nodes between them.
        /// </summary>
        public readonly bool? BalanceSimilarNodeGroups;
        /// <summary>
        /// Disables the scale down feature of the autoscaler.
        /// </summary>
        public readonly bool? DisableScaleDown;
        /// <summary>
        /// Type of resource estimator to be used in scale up.
        /// </summary>
        public readonly string? Estimator;
        /// <summary>
        /// Type of node group expander to be used in scale up.
        /// </summary>
        public readonly string? Expander;
        /// <summary>
        /// Pods with priority below cutoff will be expendable. They can be killed without any consideration during scale down and they don't cause scale up. Pods with null priority (PodPriority disabled) are non expendable.
        /// </summary>
        public readonly int? ExpendablePodsPriorityCutoff;
        /// <summary>
        /// Ignore DaemonSet pods when calculating resource utilization for scaling down.
        /// </summary>
        public readonly bool? IgnoreDaemonsetsUtilization;
        /// <summary>
        /// Maximum number of seconds the cluster autoscaler waits for pod termination when trying to scale down a node
        /// </summary>
        public readonly int? MaxGracefulTerminationSec;
        /// <summary>
        /// How long after scale up that scale down evaluation resumes.
        /// </summary>
        public readonly string? ScaleDownDelayAfterAdd;
        /// <summary>
        /// How long a node should be unneeded before it is eligible for scale down.
        /// </summary>
        public readonly string? ScaleDownUnneededTime;
        /// <summary>
        /// Node utilization level, defined as sum of requested resources divided by capacity, below which a node can be considered for scale down
        /// </summary>
        public readonly double? ScaleDownUtilizationThreshold;

        [OutputConstructor]
        private ClusterAutoscalerConfig(
            bool? balanceSimilarNodeGroups,

            bool? disableScaleDown,

            string? estimator,

            string? expander,

            int? expendablePodsPriorityCutoff,

            bool? ignoreDaemonsetsUtilization,

            int? maxGracefulTerminationSec,

            string? scaleDownDelayAfterAdd,

            string? scaleDownUnneededTime,

            double? scaleDownUtilizationThreshold)
        {
            BalanceSimilarNodeGroups = balanceSimilarNodeGroups;
            DisableScaleDown = disableScaleDown;
            Estimator = estimator;
            Expander = expander;
            ExpendablePodsPriorityCutoff = expendablePodsPriorityCutoff;
            IgnoreDaemonsetsUtilization = ignoreDaemonsetsUtilization;
            MaxGracefulTerminationSec = maxGracefulTerminationSec;
            ScaleDownDelayAfterAdd = scaleDownDelayAfterAdd;
            ScaleDownUnneededTime = scaleDownUnneededTime;
            ScaleDownUtilizationThreshold = scaleDownUtilizationThreshold;
        }
    }
}
