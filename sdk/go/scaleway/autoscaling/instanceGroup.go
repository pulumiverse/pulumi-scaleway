// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package autoscaling

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumiverse/pulumi-scaleway/sdk/go/scaleway/internal"
)

// Books and manages Autoscaling Instance groups.
//
// ## Example Usage
//
// ### Basic
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/pulumiverse/pulumi-scaleway/sdk/go/scaleway/autoscaling"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := autoscaling.NewInstanceGroup(ctx, "main", &autoscaling.InstanceGroupArgs{
//				Name:       pulumi.String("asg-group"),
//				TemplateId: pulumi.Any(mainScalewayAutoscalingInstanceTemplate.Id),
//				Tags: pulumi.StringArray{
//					pulumi.String("terraform-test"),
//					pulumi.String("instance-group"),
//				},
//				Capacities: autoscaling.InstanceGroupCapacityArray{
//					&autoscaling.InstanceGroupCapacityArgs{
//						MaxReplicas:   pulumi.Int(5),
//						MinReplicas:   pulumi.Int(1),
//						CooldownDelay: pulumi.Int(300),
//					},
//				},
//				LoadBalancers: autoscaling.InstanceGroupLoadBalancerArray{
//					&autoscaling.InstanceGroupLoadBalancerArgs{
//						Id: pulumi.Any(mainScalewayLb.Id),
//						BackendIds: pulumi.StringArray{
//							mainScalewayLbBackend.Id,
//						},
//						PrivateNetworkId: pulumi.Any(mainScalewayVpcPrivateNetwork.Id),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ### With template and policies
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/pulumiverse/pulumi-scaleway/sdk/go/scaleway/autoscaling"
//	"github.com/pulumiverse/pulumi-scaleway/sdk/go/scaleway/block"
//	"github.com/pulumiverse/pulumi-scaleway/sdk/go/scaleway/loadbalancers"
//	"github.com/pulumiverse/pulumi-scaleway/sdk/go/scaleway/network"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			main, err := network.NewVpc(ctx, "main", &network.VpcArgs{
//				Name: pulumi.String("TestAccAutoscalingVPC"),
//			})
//			if err != nil {
//				return err
//			}
//			mainPrivateNetwork, err := network.NewPrivateNetwork(ctx, "main", &network.PrivateNetworkArgs{
//				Name:  pulumi.String("TestAccAutoscalingVPC"),
//				VpcId: main.ID(),
//			})
//			if err != nil {
//				return err
//			}
//			mainVolume, err := block.NewVolume(ctx, "main", &block.VolumeArgs{
//				Iops:     pulumi.Int(5000),
//				SizeInGb: pulumi.Int(10),
//			})
//			if err != nil {
//				return err
//			}
//			mainSnapshot, err := block.NewSnapshot(ctx, "main", &block.SnapshotArgs{
//				Name:     pulumi.String("test-ds-block-snapshot-basic"),
//				VolumeId: mainVolume.ID(),
//			})
//			if err != nil {
//				return err
//			}
//			mainIp, err := loadbalancers.NewIp(ctx, "main", nil)
//			if err != nil {
//				return err
//			}
//			mainLoadBalancer, err := loadbalancers.NewLoadBalancer(ctx, "main", &loadbalancers.LoadBalancerArgs{
//				IpId: mainIp.ID(),
//				Name: pulumi.String("test-lb"),
//				Type: pulumi.String("lb-s"),
//				PrivateNetworks: loadbalancers.LoadBalancerPrivateNetworkArray{
//					&loadbalancers.LoadBalancerPrivateNetworkArgs{
//						PrivateNetworkId: mainPrivateNetwork.ID(),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			mainBackend, err := loadbalancers.NewBackend(ctx, "main", &loadbalancers.BackendArgs{
//				LbId:            mainLoadBalancer.ID(),
//				ForwardProtocol: pulumi.String("tcp"),
//				ForwardPort:     pulumi.Int(80),
//				ProxyProtocol:   pulumi.String("none"),
//			})
//			if err != nil {
//				return err
//			}
//			mainInstanceTemplate, err := autoscaling.NewInstanceTemplate(ctx, "main", &autoscaling.InstanceTemplateArgs{
//				Name:           pulumi.String("autoscaling-instance-template-basic"),
//				CommercialType: pulumi.String("PLAY2-MICRO"),
//				Tags: pulumi.StringArray{
//					pulumi.String("terraform-test"),
//					pulumi.String("basic"),
//				},
//				Volumes: autoscaling.InstanceTemplateVolumeArray{
//					&autoscaling.InstanceTemplateVolumeArgs{
//						Name:       pulumi.String("as-volume"),
//						VolumeType: pulumi.String("sbs"),
//						Boot:       pulumi.Bool(true),
//						FromSnapshot: &autoscaling.InstanceTemplateVolumeFromSnapshotArgs{
//							SnapshotId: mainSnapshot.ID(),
//						},
//						PerfIops: pulumi.Int(5000),
//					},
//				},
//				PublicIpsV4Count: pulumi.Int(1),
//				PrivateNetworkIds: pulumi.StringArray{
//					mainPrivateNetwork.ID(),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			mainInstanceGroup, err := autoscaling.NewInstanceGroup(ctx, "main", &autoscaling.InstanceGroupArgs{
//				Name:       pulumi.String("autoscaling-instance-group-basic"),
//				TemplateId: mainInstanceTemplate.ID(),
//				Tags: pulumi.StringArray{
//					pulumi.String("terraform-test"),
//					pulumi.String("instance-group"),
//				},
//				Capacities: autoscaling.InstanceGroupCapacityArray{
//					&autoscaling.InstanceGroupCapacityArgs{
//						MaxReplicas:   pulumi.Int(5),
//						MinReplicas:   pulumi.Int(1),
//						CooldownDelay: pulumi.Int(300),
//					},
//				},
//				LoadBalancers: autoscaling.InstanceGroupLoadBalancerArray{
//					&autoscaling.InstanceGroupLoadBalancerArgs{
//						Id: mainLoadBalancer.ID(),
//						BackendIds: pulumi.StringArray{
//							mainBackend.ID(),
//						},
//						PrivateNetworkId: mainPrivateNetwork.ID(),
//					},
//				},
//				DeleteServersOnDestroy: pulumi.Bool(true),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = autoscaling.NewInstancePolicy(ctx, "up", &autoscaling.InstancePolicyArgs{
//				InstanceGroupId: mainInstanceGroup.ID(),
//				Name:            pulumi.String("scale-up-if-cpu-high"),
//				Action:          pulumi.String("scale_up"),
//				Type:            pulumi.String("flat_count"),
//				Value:           pulumi.Int(1),
//				Priority:        pulumi.Int(1),
//				Metrics: autoscaling.InstancePolicyMetricArray{
//					&autoscaling.InstancePolicyMetricArgs{
//						Name:             pulumi.String("cpu scale up"),
//						ManagedMetric:    pulumi.String("managed_metric_instance_cpu"),
//						Operator:         pulumi.String("operator_greater_than"),
//						Aggregate:        pulumi.String("aggregate_average"),
//						SamplingRangeMin: pulumi.Int(5),
//						Threshold:        pulumi.Int(70),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			_, err = autoscaling.NewInstancePolicy(ctx, "down", &autoscaling.InstancePolicyArgs{
//				InstanceGroupId: mainInstanceGroup.ID(),
//				Name:            pulumi.String("scale-down-if-cpu-low"),
//				Action:          pulumi.String("scale_down"),
//				Type:            pulumi.String("flat_count"),
//				Value:           pulumi.Int(1),
//				Priority:        pulumi.Int(2),
//				Metrics: autoscaling.InstancePolicyMetricArray{
//					&autoscaling.InstancePolicyMetricArgs{
//						Name:             pulumi.String("cpu scale down"),
//						ManagedMetric:    pulumi.String("managed_metric_instance_cpu"),
//						Operator:         pulumi.String("operator_less_than"),
//						Aggregate:        pulumi.String("aggregate_average"),
//						SamplingRangeMin: pulumi.Int(5),
//						Threshold:        pulumi.Int(40),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// Autoscaling Instance groups can be imported using `{zone}/{id}`, e.g.
//
// bash
//
// ```sh
// $ pulumi import scaleway:autoscaling/instanceGroup:InstanceGroup main fr-par-1/11111111-1111-1111-1111-111111111111
// ```
type InstanceGroup struct {
	pulumi.CustomResourceState

	// The specification of the minimum and maximum replicas for the Instance group, and the cooldown interval between two scaling events.
	Capacities InstanceGroupCapacityArrayOutput `pulumi:"capacities"`
	// Date and time of Instance group's creation (RFC 3339 format).
	CreatedAt pulumi.StringOutput `pulumi:"createdAt"`
	// Whether to delete all instances in this group when the group is destroyed. Set to `true` to tear them down, `false` (the default) leaves them running.
	DeleteServersOnDestroy pulumi.BoolPtrOutput `pulumi:"deleteServersOnDestroy"`
	// The specification of the Load Balancer to link to the Instance group.
	LoadBalancers InstanceGroupLoadBalancerArrayOutput `pulumi:"loadBalancers"`
	// The Instance group name.
	Name pulumi.StringOutput `pulumi:"name"`
	// `projectId`) The ID of the Project the Instance group is associated with.
	ProjectId pulumi.StringOutput `pulumi:"projectId"`
	// The tags associated with the Instance group.
	Tags pulumi.StringArrayOutput `pulumi:"tags"`
	// The ID of the Instance template to attach to the Instance group.
	TemplateId pulumi.StringOutput `pulumi:"templateId"`
	// Date and time of Instance group's last update (RFC 3339 format).
	UpdatedAt pulumi.StringOutput `pulumi:"updatedAt"`
	// `zone`) The zone in which the Instance group exists.
	Zone pulumi.StringPtrOutput `pulumi:"zone"`
}

// NewInstanceGroup registers a new resource with the given unique name, arguments, and options.
func NewInstanceGroup(ctx *pulumi.Context,
	name string, args *InstanceGroupArgs, opts ...pulumi.ResourceOption) (*InstanceGroup, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.TemplateId == nil {
		return nil, errors.New("invalid value for required argument 'TemplateId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource InstanceGroup
	err := ctx.RegisterResource("scaleway:autoscaling/instanceGroup:InstanceGroup", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetInstanceGroup gets an existing InstanceGroup resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetInstanceGroup(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *InstanceGroupState, opts ...pulumi.ResourceOption) (*InstanceGroup, error) {
	var resource InstanceGroup
	err := ctx.ReadResource("scaleway:autoscaling/instanceGroup:InstanceGroup", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering InstanceGroup resources.
type instanceGroupState struct {
	// The specification of the minimum and maximum replicas for the Instance group, and the cooldown interval between two scaling events.
	Capacities []InstanceGroupCapacity `pulumi:"capacities"`
	// Date and time of Instance group's creation (RFC 3339 format).
	CreatedAt *string `pulumi:"createdAt"`
	// Whether to delete all instances in this group when the group is destroyed. Set to `true` to tear them down, `false` (the default) leaves them running.
	DeleteServersOnDestroy *bool `pulumi:"deleteServersOnDestroy"`
	// The specification of the Load Balancer to link to the Instance group.
	LoadBalancers []InstanceGroupLoadBalancer `pulumi:"loadBalancers"`
	// The Instance group name.
	Name *string `pulumi:"name"`
	// `projectId`) The ID of the Project the Instance group is associated with.
	ProjectId *string `pulumi:"projectId"`
	// The tags associated with the Instance group.
	Tags []string `pulumi:"tags"`
	// The ID of the Instance template to attach to the Instance group.
	TemplateId *string `pulumi:"templateId"`
	// Date and time of Instance group's last update (RFC 3339 format).
	UpdatedAt *string `pulumi:"updatedAt"`
	// `zone`) The zone in which the Instance group exists.
	Zone *string `pulumi:"zone"`
}

type InstanceGroupState struct {
	// The specification of the minimum and maximum replicas for the Instance group, and the cooldown interval between two scaling events.
	Capacities InstanceGroupCapacityArrayInput
	// Date and time of Instance group's creation (RFC 3339 format).
	CreatedAt pulumi.StringPtrInput
	// Whether to delete all instances in this group when the group is destroyed. Set to `true` to tear them down, `false` (the default) leaves them running.
	DeleteServersOnDestroy pulumi.BoolPtrInput
	// The specification of the Load Balancer to link to the Instance group.
	LoadBalancers InstanceGroupLoadBalancerArrayInput
	// The Instance group name.
	Name pulumi.StringPtrInput
	// `projectId`) The ID of the Project the Instance group is associated with.
	ProjectId pulumi.StringPtrInput
	// The tags associated with the Instance group.
	Tags pulumi.StringArrayInput
	// The ID of the Instance template to attach to the Instance group.
	TemplateId pulumi.StringPtrInput
	// Date and time of Instance group's last update (RFC 3339 format).
	UpdatedAt pulumi.StringPtrInput
	// `zone`) The zone in which the Instance group exists.
	Zone pulumi.StringPtrInput
}

func (InstanceGroupState) ElementType() reflect.Type {
	return reflect.TypeOf((*instanceGroupState)(nil)).Elem()
}

type instanceGroupArgs struct {
	// The specification of the minimum and maximum replicas for the Instance group, and the cooldown interval between two scaling events.
	Capacities []InstanceGroupCapacity `pulumi:"capacities"`
	// Whether to delete all instances in this group when the group is destroyed. Set to `true` to tear them down, `false` (the default) leaves them running.
	DeleteServersOnDestroy *bool `pulumi:"deleteServersOnDestroy"`
	// The specification of the Load Balancer to link to the Instance group.
	LoadBalancers []InstanceGroupLoadBalancer `pulumi:"loadBalancers"`
	// The Instance group name.
	Name *string `pulumi:"name"`
	// `projectId`) The ID of the Project the Instance group is associated with.
	ProjectId *string `pulumi:"projectId"`
	// The tags associated with the Instance group.
	Tags []string `pulumi:"tags"`
	// The ID of the Instance template to attach to the Instance group.
	TemplateId string `pulumi:"templateId"`
	// `zone`) The zone in which the Instance group exists.
	Zone *string `pulumi:"zone"`
}

// The set of arguments for constructing a InstanceGroup resource.
type InstanceGroupArgs struct {
	// The specification of the minimum and maximum replicas for the Instance group, and the cooldown interval between two scaling events.
	Capacities InstanceGroupCapacityArrayInput
	// Whether to delete all instances in this group when the group is destroyed. Set to `true` to tear them down, `false` (the default) leaves them running.
	DeleteServersOnDestroy pulumi.BoolPtrInput
	// The specification of the Load Balancer to link to the Instance group.
	LoadBalancers InstanceGroupLoadBalancerArrayInput
	// The Instance group name.
	Name pulumi.StringPtrInput
	// `projectId`) The ID of the Project the Instance group is associated with.
	ProjectId pulumi.StringPtrInput
	// The tags associated with the Instance group.
	Tags pulumi.StringArrayInput
	// The ID of the Instance template to attach to the Instance group.
	TemplateId pulumi.StringInput
	// `zone`) The zone in which the Instance group exists.
	Zone pulumi.StringPtrInput
}

func (InstanceGroupArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*instanceGroupArgs)(nil)).Elem()
}

type InstanceGroupInput interface {
	pulumi.Input

	ToInstanceGroupOutput() InstanceGroupOutput
	ToInstanceGroupOutputWithContext(ctx context.Context) InstanceGroupOutput
}

func (*InstanceGroup) ElementType() reflect.Type {
	return reflect.TypeOf((**InstanceGroup)(nil)).Elem()
}

func (i *InstanceGroup) ToInstanceGroupOutput() InstanceGroupOutput {
	return i.ToInstanceGroupOutputWithContext(context.Background())
}

func (i *InstanceGroup) ToInstanceGroupOutputWithContext(ctx context.Context) InstanceGroupOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstanceGroupOutput)
}

// InstanceGroupArrayInput is an input type that accepts InstanceGroupArray and InstanceGroupArrayOutput values.
// You can construct a concrete instance of `InstanceGroupArrayInput` via:
//
//	InstanceGroupArray{ InstanceGroupArgs{...} }
type InstanceGroupArrayInput interface {
	pulumi.Input

	ToInstanceGroupArrayOutput() InstanceGroupArrayOutput
	ToInstanceGroupArrayOutputWithContext(context.Context) InstanceGroupArrayOutput
}

type InstanceGroupArray []InstanceGroupInput

func (InstanceGroupArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*InstanceGroup)(nil)).Elem()
}

func (i InstanceGroupArray) ToInstanceGroupArrayOutput() InstanceGroupArrayOutput {
	return i.ToInstanceGroupArrayOutputWithContext(context.Background())
}

func (i InstanceGroupArray) ToInstanceGroupArrayOutputWithContext(ctx context.Context) InstanceGroupArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstanceGroupArrayOutput)
}

// InstanceGroupMapInput is an input type that accepts InstanceGroupMap and InstanceGroupMapOutput values.
// You can construct a concrete instance of `InstanceGroupMapInput` via:
//
//	InstanceGroupMap{ "key": InstanceGroupArgs{...} }
type InstanceGroupMapInput interface {
	pulumi.Input

	ToInstanceGroupMapOutput() InstanceGroupMapOutput
	ToInstanceGroupMapOutputWithContext(context.Context) InstanceGroupMapOutput
}

type InstanceGroupMap map[string]InstanceGroupInput

func (InstanceGroupMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*InstanceGroup)(nil)).Elem()
}

func (i InstanceGroupMap) ToInstanceGroupMapOutput() InstanceGroupMapOutput {
	return i.ToInstanceGroupMapOutputWithContext(context.Background())
}

func (i InstanceGroupMap) ToInstanceGroupMapOutputWithContext(ctx context.Context) InstanceGroupMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstanceGroupMapOutput)
}

type InstanceGroupOutput struct{ *pulumi.OutputState }

func (InstanceGroupOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**InstanceGroup)(nil)).Elem()
}

func (o InstanceGroupOutput) ToInstanceGroupOutput() InstanceGroupOutput {
	return o
}

func (o InstanceGroupOutput) ToInstanceGroupOutputWithContext(ctx context.Context) InstanceGroupOutput {
	return o
}

// The specification of the minimum and maximum replicas for the Instance group, and the cooldown interval between two scaling events.
func (o InstanceGroupOutput) Capacities() InstanceGroupCapacityArrayOutput {
	return o.ApplyT(func(v *InstanceGroup) InstanceGroupCapacityArrayOutput { return v.Capacities }).(InstanceGroupCapacityArrayOutput)
}

// Date and time of Instance group's creation (RFC 3339 format).
func (o InstanceGroupOutput) CreatedAt() pulumi.StringOutput {
	return o.ApplyT(func(v *InstanceGroup) pulumi.StringOutput { return v.CreatedAt }).(pulumi.StringOutput)
}

// Whether to delete all instances in this group when the group is destroyed. Set to `true` to tear them down, `false` (the default) leaves them running.
func (o InstanceGroupOutput) DeleteServersOnDestroy() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *InstanceGroup) pulumi.BoolPtrOutput { return v.DeleteServersOnDestroy }).(pulumi.BoolPtrOutput)
}

// The specification of the Load Balancer to link to the Instance group.
func (o InstanceGroupOutput) LoadBalancers() InstanceGroupLoadBalancerArrayOutput {
	return o.ApplyT(func(v *InstanceGroup) InstanceGroupLoadBalancerArrayOutput { return v.LoadBalancers }).(InstanceGroupLoadBalancerArrayOutput)
}

// The Instance group name.
func (o InstanceGroupOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *InstanceGroup) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// `projectId`) The ID of the Project the Instance group is associated with.
func (o InstanceGroupOutput) ProjectId() pulumi.StringOutput {
	return o.ApplyT(func(v *InstanceGroup) pulumi.StringOutput { return v.ProjectId }).(pulumi.StringOutput)
}

// The tags associated with the Instance group.
func (o InstanceGroupOutput) Tags() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *InstanceGroup) pulumi.StringArrayOutput { return v.Tags }).(pulumi.StringArrayOutput)
}

// The ID of the Instance template to attach to the Instance group.
func (o InstanceGroupOutput) TemplateId() pulumi.StringOutput {
	return o.ApplyT(func(v *InstanceGroup) pulumi.StringOutput { return v.TemplateId }).(pulumi.StringOutput)
}

// Date and time of Instance group's last update (RFC 3339 format).
func (o InstanceGroupOutput) UpdatedAt() pulumi.StringOutput {
	return o.ApplyT(func(v *InstanceGroup) pulumi.StringOutput { return v.UpdatedAt }).(pulumi.StringOutput)
}

// `zone`) The zone in which the Instance group exists.
func (o InstanceGroupOutput) Zone() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *InstanceGroup) pulumi.StringPtrOutput { return v.Zone }).(pulumi.StringPtrOutput)
}

type InstanceGroupArrayOutput struct{ *pulumi.OutputState }

func (InstanceGroupArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*InstanceGroup)(nil)).Elem()
}

func (o InstanceGroupArrayOutput) ToInstanceGroupArrayOutput() InstanceGroupArrayOutput {
	return o
}

func (o InstanceGroupArrayOutput) ToInstanceGroupArrayOutputWithContext(ctx context.Context) InstanceGroupArrayOutput {
	return o
}

func (o InstanceGroupArrayOutput) Index(i pulumi.IntInput) InstanceGroupOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *InstanceGroup {
		return vs[0].([]*InstanceGroup)[vs[1].(int)]
	}).(InstanceGroupOutput)
}

type InstanceGroupMapOutput struct{ *pulumi.OutputState }

func (InstanceGroupMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*InstanceGroup)(nil)).Elem()
}

func (o InstanceGroupMapOutput) ToInstanceGroupMapOutput() InstanceGroupMapOutput {
	return o
}

func (o InstanceGroupMapOutput) ToInstanceGroupMapOutputWithContext(ctx context.Context) InstanceGroupMapOutput {
	return o
}

func (o InstanceGroupMapOutput) MapIndex(k pulumi.StringInput) InstanceGroupOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *InstanceGroup {
		return vs[0].(map[string]*InstanceGroup)[vs[1].(string)]
	}).(InstanceGroupOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*InstanceGroupInput)(nil)).Elem(), &InstanceGroup{})
	pulumi.RegisterInputType(reflect.TypeOf((*InstanceGroupArrayInput)(nil)).Elem(), InstanceGroupArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*InstanceGroupMapInput)(nil)).Elem(), InstanceGroupMap{})
	pulumi.RegisterOutputType(InstanceGroupOutput{})
	pulumi.RegisterOutputType(InstanceGroupArrayOutput{})
	pulumi.RegisterOutputType(InstanceGroupMapOutput{})
}
