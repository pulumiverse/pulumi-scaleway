// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package autoscaling

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumiverse/pulumi-scaleway/sdk/go/scaleway/internal"
)

// Books and manages Autoscaling Instance policies.
//
// ## Example Usage
//
// ### Basic
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/pulumiverse/pulumi-scaleway/sdk/go/scaleway/autoscaling"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := autoscaling.NewInstancePolicy(ctx, "up", &autoscaling.InstancePolicyArgs{
//				InstanceGroupId: pulumi.Any(main.Id),
//				Name:            pulumi.String("scale-up-if-cpu-high"),
//				Action:          pulumi.String("scale_up"),
//				Type:            pulumi.String("flat_count"),
//				Value:           pulumi.Int(1),
//				Priority:        pulumi.Int(1),
//				Metrics: autoscaling.InstancePolicyMetricArray{
//					&autoscaling.InstancePolicyMetricArgs{
//						Name:             pulumi.String("cpu scale up"),
//						ManagedMetric:    pulumi.String("managed_metric_instance_cpu"),
//						Operator:         pulumi.String("operator_greater_than"),
//						Aggregate:        pulumi.String("aggregate_average"),
//						SamplingRangeMin: pulumi.Int(5),
//						Threshold:        pulumi.Int(70),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			_, err = autoscaling.NewInstancePolicy(ctx, "down", &autoscaling.InstancePolicyArgs{
//				InstanceGroupId: pulumi.Any(main.Id),
//				Name:            pulumi.String("scale-down-if-cpu-low"),
//				Action:          pulumi.String("scale_down"),
//				Type:            pulumi.String("flat_count"),
//				Value:           pulumi.Int(1),
//				Priority:        pulumi.Int(2),
//				Metrics: autoscaling.InstancePolicyMetricArray{
//					&autoscaling.InstancePolicyMetricArgs{
//						Name:             pulumi.String("cpu scale down"),
//						ManagedMetric:    pulumi.String("managed_metric_instance_cpu"),
//						Operator:         pulumi.String("operator_less_than"),
//						Aggregate:        pulumi.String("aggregate_average"),
//						SamplingRangeMin: pulumi.Int(5),
//						Threshold:        pulumi.Int(40),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// Autoscaling instance policies can be imported using `{zone}/{id}`, e.g.
//
// bash
//
// ```sh
// $ pulumi import scaleway:autoscaling/instancePolicy:InstancePolicy main fr-par-1/11111111-1111-1111-1111-111111111111
// ```
type InstancePolicy struct {
	pulumi.CustomResourceState

	// The action to execute when the metric-based condition is met.
	Action pulumi.StringOutput `pulumi:"action"`
	// The ID of the Instance group related to this policy.
	InstanceGroupId pulumi.StringOutput `pulumi:"instanceGroupId"`
	// Cockpit metric to use when determining whether to trigger a scale up/down action.
	Metrics InstancePolicyMetricArrayOutput `pulumi:"metrics"`
	// The Instance policy name.
	Name pulumi.StringOutput `pulumi:"name"`
	// The priority of this policy compared to all other scaling policies. This determines the processing order. The lower the number, the higher the priority.
	Priority pulumi.IntOutput `pulumi:"priority"`
	// `projectId`) The ID of the Project the Instance policy is associated with.
	ProjectId pulumi.StringOutput `pulumi:"projectId"`
	// How to use the number defined in `value` when determining by how many Instances to scale up/down.
	Type pulumi.StringOutput `pulumi:"type"`
	// The value representing the magnitude of the scaling action to take for the Instance group. Depending on the `type` parameter, this number could represent a total number of Instances in the group, a number of Instances to add, or a percentage to scale the group by.
	Value pulumi.IntOutput `pulumi:"value"`
	// `zone`) The zone in which the Instance policy exists.
	Zone pulumi.StringOutput `pulumi:"zone"`
}

// NewInstancePolicy registers a new resource with the given unique name, arguments, and options.
func NewInstancePolicy(ctx *pulumi.Context,
	name string, args *InstancePolicyArgs, opts ...pulumi.ResourceOption) (*InstancePolicy, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Action == nil {
		return nil, errors.New("invalid value for required argument 'Action'")
	}
	if args.InstanceGroupId == nil {
		return nil, errors.New("invalid value for required argument 'InstanceGroupId'")
	}
	if args.Priority == nil {
		return nil, errors.New("invalid value for required argument 'Priority'")
	}
	if args.Type == nil {
		return nil, errors.New("invalid value for required argument 'Type'")
	}
	if args.Value == nil {
		return nil, errors.New("invalid value for required argument 'Value'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource InstancePolicy
	err := ctx.RegisterResource("scaleway:autoscaling/instancePolicy:InstancePolicy", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetInstancePolicy gets an existing InstancePolicy resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetInstancePolicy(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *InstancePolicyState, opts ...pulumi.ResourceOption) (*InstancePolicy, error) {
	var resource InstancePolicy
	err := ctx.ReadResource("scaleway:autoscaling/instancePolicy:InstancePolicy", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering InstancePolicy resources.
type instancePolicyState struct {
	// The action to execute when the metric-based condition is met.
	Action *string `pulumi:"action"`
	// The ID of the Instance group related to this policy.
	InstanceGroupId *string `pulumi:"instanceGroupId"`
	// Cockpit metric to use when determining whether to trigger a scale up/down action.
	Metrics []InstancePolicyMetric `pulumi:"metrics"`
	// The Instance policy name.
	Name *string `pulumi:"name"`
	// The priority of this policy compared to all other scaling policies. This determines the processing order. The lower the number, the higher the priority.
	Priority *int `pulumi:"priority"`
	// `projectId`) The ID of the Project the Instance policy is associated with.
	ProjectId *string `pulumi:"projectId"`
	// How to use the number defined in `value` when determining by how many Instances to scale up/down.
	Type *string `pulumi:"type"`
	// The value representing the magnitude of the scaling action to take for the Instance group. Depending on the `type` parameter, this number could represent a total number of Instances in the group, a number of Instances to add, or a percentage to scale the group by.
	Value *int `pulumi:"value"`
	// `zone`) The zone in which the Instance policy exists.
	Zone *string `pulumi:"zone"`
}

type InstancePolicyState struct {
	// The action to execute when the metric-based condition is met.
	Action pulumi.StringPtrInput
	// The ID of the Instance group related to this policy.
	InstanceGroupId pulumi.StringPtrInput
	// Cockpit metric to use when determining whether to trigger a scale up/down action.
	Metrics InstancePolicyMetricArrayInput
	// The Instance policy name.
	Name pulumi.StringPtrInput
	// The priority of this policy compared to all other scaling policies. This determines the processing order. The lower the number, the higher the priority.
	Priority pulumi.IntPtrInput
	// `projectId`) The ID of the Project the Instance policy is associated with.
	ProjectId pulumi.StringPtrInput
	// How to use the number defined in `value` when determining by how many Instances to scale up/down.
	Type pulumi.StringPtrInput
	// The value representing the magnitude of the scaling action to take for the Instance group. Depending on the `type` parameter, this number could represent a total number of Instances in the group, a number of Instances to add, or a percentage to scale the group by.
	Value pulumi.IntPtrInput
	// `zone`) The zone in which the Instance policy exists.
	Zone pulumi.StringPtrInput
}

func (InstancePolicyState) ElementType() reflect.Type {
	return reflect.TypeOf((*instancePolicyState)(nil)).Elem()
}

type instancePolicyArgs struct {
	// The action to execute when the metric-based condition is met.
	Action string `pulumi:"action"`
	// The ID of the Instance group related to this policy.
	InstanceGroupId string `pulumi:"instanceGroupId"`
	// Cockpit metric to use when determining whether to trigger a scale up/down action.
	Metrics []InstancePolicyMetric `pulumi:"metrics"`
	// The Instance policy name.
	Name *string `pulumi:"name"`
	// The priority of this policy compared to all other scaling policies. This determines the processing order. The lower the number, the higher the priority.
	Priority int `pulumi:"priority"`
	// `projectId`) The ID of the Project the Instance policy is associated with.
	ProjectId *string `pulumi:"projectId"`
	// How to use the number defined in `value` when determining by how many Instances to scale up/down.
	Type string `pulumi:"type"`
	// The value representing the magnitude of the scaling action to take for the Instance group. Depending on the `type` parameter, this number could represent a total number of Instances in the group, a number of Instances to add, or a percentage to scale the group by.
	Value int `pulumi:"value"`
	// `zone`) The zone in which the Instance policy exists.
	Zone *string `pulumi:"zone"`
}

// The set of arguments for constructing a InstancePolicy resource.
type InstancePolicyArgs struct {
	// The action to execute when the metric-based condition is met.
	Action pulumi.StringInput
	// The ID of the Instance group related to this policy.
	InstanceGroupId pulumi.StringInput
	// Cockpit metric to use when determining whether to trigger a scale up/down action.
	Metrics InstancePolicyMetricArrayInput
	// The Instance policy name.
	Name pulumi.StringPtrInput
	// The priority of this policy compared to all other scaling policies. This determines the processing order. The lower the number, the higher the priority.
	Priority pulumi.IntInput
	// `projectId`) The ID of the Project the Instance policy is associated with.
	ProjectId pulumi.StringPtrInput
	// How to use the number defined in `value` when determining by how many Instances to scale up/down.
	Type pulumi.StringInput
	// The value representing the magnitude of the scaling action to take for the Instance group. Depending on the `type` parameter, this number could represent a total number of Instances in the group, a number of Instances to add, or a percentage to scale the group by.
	Value pulumi.IntInput
	// `zone`) The zone in which the Instance policy exists.
	Zone pulumi.StringPtrInput
}

func (InstancePolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*instancePolicyArgs)(nil)).Elem()
}

type InstancePolicyInput interface {
	pulumi.Input

	ToInstancePolicyOutput() InstancePolicyOutput
	ToInstancePolicyOutputWithContext(ctx context.Context) InstancePolicyOutput
}

func (*InstancePolicy) ElementType() reflect.Type {
	return reflect.TypeOf((**InstancePolicy)(nil)).Elem()
}

func (i *InstancePolicy) ToInstancePolicyOutput() InstancePolicyOutput {
	return i.ToInstancePolicyOutputWithContext(context.Background())
}

func (i *InstancePolicy) ToInstancePolicyOutputWithContext(ctx context.Context) InstancePolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstancePolicyOutput)
}

// InstancePolicyArrayInput is an input type that accepts InstancePolicyArray and InstancePolicyArrayOutput values.
// You can construct a concrete instance of `InstancePolicyArrayInput` via:
//
//	InstancePolicyArray{ InstancePolicyArgs{...} }
type InstancePolicyArrayInput interface {
	pulumi.Input

	ToInstancePolicyArrayOutput() InstancePolicyArrayOutput
	ToInstancePolicyArrayOutputWithContext(context.Context) InstancePolicyArrayOutput
}

type InstancePolicyArray []InstancePolicyInput

func (InstancePolicyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*InstancePolicy)(nil)).Elem()
}

func (i InstancePolicyArray) ToInstancePolicyArrayOutput() InstancePolicyArrayOutput {
	return i.ToInstancePolicyArrayOutputWithContext(context.Background())
}

func (i InstancePolicyArray) ToInstancePolicyArrayOutputWithContext(ctx context.Context) InstancePolicyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstancePolicyArrayOutput)
}

// InstancePolicyMapInput is an input type that accepts InstancePolicyMap and InstancePolicyMapOutput values.
// You can construct a concrete instance of `InstancePolicyMapInput` via:
//
//	InstancePolicyMap{ "key": InstancePolicyArgs{...} }
type InstancePolicyMapInput interface {
	pulumi.Input

	ToInstancePolicyMapOutput() InstancePolicyMapOutput
	ToInstancePolicyMapOutputWithContext(context.Context) InstancePolicyMapOutput
}

type InstancePolicyMap map[string]InstancePolicyInput

func (InstancePolicyMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*InstancePolicy)(nil)).Elem()
}

func (i InstancePolicyMap) ToInstancePolicyMapOutput() InstancePolicyMapOutput {
	return i.ToInstancePolicyMapOutputWithContext(context.Background())
}

func (i InstancePolicyMap) ToInstancePolicyMapOutputWithContext(ctx context.Context) InstancePolicyMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstancePolicyMapOutput)
}

type InstancePolicyOutput struct{ *pulumi.OutputState }

func (InstancePolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**InstancePolicy)(nil)).Elem()
}

func (o InstancePolicyOutput) ToInstancePolicyOutput() InstancePolicyOutput {
	return o
}

func (o InstancePolicyOutput) ToInstancePolicyOutputWithContext(ctx context.Context) InstancePolicyOutput {
	return o
}

// The action to execute when the metric-based condition is met.
func (o InstancePolicyOutput) Action() pulumi.StringOutput {
	return o.ApplyT(func(v *InstancePolicy) pulumi.StringOutput { return v.Action }).(pulumi.StringOutput)
}

// The ID of the Instance group related to this policy.
func (o InstancePolicyOutput) InstanceGroupId() pulumi.StringOutput {
	return o.ApplyT(func(v *InstancePolicy) pulumi.StringOutput { return v.InstanceGroupId }).(pulumi.StringOutput)
}

// Cockpit metric to use when determining whether to trigger a scale up/down action.
func (o InstancePolicyOutput) Metrics() InstancePolicyMetricArrayOutput {
	return o.ApplyT(func(v *InstancePolicy) InstancePolicyMetricArrayOutput { return v.Metrics }).(InstancePolicyMetricArrayOutput)
}

// The Instance policy name.
func (o InstancePolicyOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *InstancePolicy) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// The priority of this policy compared to all other scaling policies. This determines the processing order. The lower the number, the higher the priority.
func (o InstancePolicyOutput) Priority() pulumi.IntOutput {
	return o.ApplyT(func(v *InstancePolicy) pulumi.IntOutput { return v.Priority }).(pulumi.IntOutput)
}

// `projectId`) The ID of the Project the Instance policy is associated with.
func (o InstancePolicyOutput) ProjectId() pulumi.StringOutput {
	return o.ApplyT(func(v *InstancePolicy) pulumi.StringOutput { return v.ProjectId }).(pulumi.StringOutput)
}

// How to use the number defined in `value` when determining by how many Instances to scale up/down.
func (o InstancePolicyOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v *InstancePolicy) pulumi.StringOutput { return v.Type }).(pulumi.StringOutput)
}

// The value representing the magnitude of the scaling action to take for the Instance group. Depending on the `type` parameter, this number could represent a total number of Instances in the group, a number of Instances to add, or a percentage to scale the group by.
func (o InstancePolicyOutput) Value() pulumi.IntOutput {
	return o.ApplyT(func(v *InstancePolicy) pulumi.IntOutput { return v.Value }).(pulumi.IntOutput)
}

// `zone`) The zone in which the Instance policy exists.
func (o InstancePolicyOutput) Zone() pulumi.StringOutput {
	return o.ApplyT(func(v *InstancePolicy) pulumi.StringOutput { return v.Zone }).(pulumi.StringOutput)
}

type InstancePolicyArrayOutput struct{ *pulumi.OutputState }

func (InstancePolicyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*InstancePolicy)(nil)).Elem()
}

func (o InstancePolicyArrayOutput) ToInstancePolicyArrayOutput() InstancePolicyArrayOutput {
	return o
}

func (o InstancePolicyArrayOutput) ToInstancePolicyArrayOutputWithContext(ctx context.Context) InstancePolicyArrayOutput {
	return o
}

func (o InstancePolicyArrayOutput) Index(i pulumi.IntInput) InstancePolicyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *InstancePolicy {
		return vs[0].([]*InstancePolicy)[vs[1].(int)]
	}).(InstancePolicyOutput)
}

type InstancePolicyMapOutput struct{ *pulumi.OutputState }

func (InstancePolicyMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*InstancePolicy)(nil)).Elem()
}

func (o InstancePolicyMapOutput) ToInstancePolicyMapOutput() InstancePolicyMapOutput {
	return o
}

func (o InstancePolicyMapOutput) ToInstancePolicyMapOutputWithContext(ctx context.Context) InstancePolicyMapOutput {
	return o
}

func (o InstancePolicyMapOutput) MapIndex(k pulumi.StringInput) InstancePolicyOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *InstancePolicy {
		return vs[0].(map[string]*InstancePolicy)[vs[1].(string)]
	}).(InstancePolicyOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*InstancePolicyInput)(nil)).Elem(), &InstancePolicy{})
	pulumi.RegisterInputType(reflect.TypeOf((*InstancePolicyArrayInput)(nil)).Elem(), InstancePolicyArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*InstancePolicyMapInput)(nil)).Elem(), InstancePolicyMap{})
	pulumi.RegisterOutputType(InstancePolicyOutput{})
	pulumi.RegisterOutputType(InstancePolicyArrayOutput{})
	pulumi.RegisterOutputType(InstancePolicyMapOutput{})
}
