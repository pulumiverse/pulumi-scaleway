// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package scaleway

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumiverse/pulumi-scaleway/sdk/go/scaleway/internal"
)

// Books and manages Autoscaling Instance groups.
//
// ## Example Usage
//
// ### Basic
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/pulumiverse/pulumi-scaleway/sdk/go/scaleway"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := scaleway.NewAutoscalingInstanceGroup(ctx, "main", &scaleway.AutoscalingInstanceGroupArgs{
//				Name:       pulumi.String("asg-group"),
//				TemplateId: pulumi.Any(mainScalewayAutoscalingInstanceTemplate.Id),
//				Tags: pulumi.StringArray{
//					pulumi.String("terraform-test"),
//					pulumi.String("instance-group"),
//				},
//				Capacities: scaleway.AutoscalingInstanceGroupCapacityArray{
//					&scaleway.AutoscalingInstanceGroupCapacityArgs{
//						MaxReplicas:   pulumi.Int(5),
//						MinReplicas:   pulumi.Int(1),
//						CooldownDelay: pulumi.Int(300),
//					},
//				},
//				LoadBalancers: scaleway.AutoscalingInstanceGroupLoadBalancerArray{
//					&scaleway.AutoscalingInstanceGroupLoadBalancerArgs{
//						Id: pulumi.Any(mainScalewayLb.Id),
//						BackendIds: pulumi.StringArray{
//							mainScalewayLbBackend.Id,
//						},
//						PrivateNetworkId: pulumi.Any(mainScalewayVpcPrivateNetwork.Id),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ### With template and policies
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/pulumiverse/pulumi-scaleway/sdk/go/scaleway"
//	"github.com/pulumiverse/pulumi-scaleway/sdk/go/scaleway/block"
//	"github.com/pulumiverse/pulumi-scaleway/sdk/go/scaleway/loadbalancers"
//	"github.com/pulumiverse/pulumi-scaleway/sdk/go/scaleway/network"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			main, err := network.NewVpc(ctx, "main", &network.VpcArgs{
//				Name: pulumi.String("TestAccAutoscalingVPC"),
//			})
//			if err != nil {
//				return err
//			}
//			mainPrivateNetwork, err := network.NewPrivateNetwork(ctx, "main", &network.PrivateNetworkArgs{
//				Name:  pulumi.String("TestAccAutoscalingVPC"),
//				VpcId: main.ID(),
//			})
//			if err != nil {
//				return err
//			}
//			mainVolume, err := block.NewVolume(ctx, "main", &block.VolumeArgs{
//				Iops:     pulumi.Int(5000),
//				SizeInGb: pulumi.Int(10),
//			})
//			if err != nil {
//				return err
//			}
//			mainSnapshot, err := block.NewSnapshot(ctx, "main", &block.SnapshotArgs{
//				Name:     pulumi.String("test-ds-block-snapshot-basic"),
//				VolumeId: mainVolume.ID(),
//			})
//			if err != nil {
//				return err
//			}
//			mainIp, err := loadbalancers.NewIp(ctx, "main", nil)
//			if err != nil {
//				return err
//			}
//			mainLoadBalancer, err := loadbalancers.NewLoadBalancer(ctx, "main", &loadbalancers.LoadBalancerArgs{
//				IpId: mainIp.ID(),
//				Name: pulumi.String("test-lb"),
//				Type: pulumi.String("lb-s"),
//				PrivateNetworks: loadbalancers.LoadBalancerPrivateNetworkArray{
//					&loadbalancers.LoadBalancerPrivateNetworkArgs{
//						PrivateNetworkId: mainPrivateNetwork.ID(),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			mainBackend, err := loadbalancers.NewBackend(ctx, "main", &loadbalancers.BackendArgs{
//				LbId:            mainLoadBalancer.ID(),
//				ForwardProtocol: pulumi.String("tcp"),
//				ForwardPort:     pulumi.Int(80),
//				ProxyProtocol:   pulumi.String("none"),
//			})
//			if err != nil {
//				return err
//			}
//			mainAutoscalingInstanceTemplate, err := scaleway.NewAutoscalingInstanceTemplate(ctx, "main", &scaleway.AutoscalingInstanceTemplateArgs{
//				Name:           pulumi.String("autoscaling-instance-template-basic"),
//				CommercialType: pulumi.String("PLAY2-MICRO"),
//				Tags: pulumi.StringArray{
//					pulumi.String("terraform-test"),
//					pulumi.String("basic"),
//				},
//				Volumes: scaleway.AutoscalingInstanceTemplateVolumeArray{
//					&scaleway.AutoscalingInstanceTemplateVolumeArgs{
//						Name:       pulumi.String("as-volume"),
//						VolumeType: pulumi.String("sbs"),
//						Boot:       pulumi.Bool(true),
//						FromSnapshot: &scaleway.AutoscalingInstanceTemplateVolumeFromSnapshotArgs{
//							SnapshotId: mainSnapshot.ID(),
//						},
//						PerfIops: pulumi.Int(5000),
//					},
//				},
//				PublicIpsV4Count: pulumi.Int(1),
//				PrivateNetworkIds: pulumi.StringArray{
//					mainPrivateNetwork.ID(),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			mainAutoscalingInstanceGroup, err := scaleway.NewAutoscalingInstanceGroup(ctx, "main", &scaleway.AutoscalingInstanceGroupArgs{
//				Name:       pulumi.String("autoscaling-instance-group-basic"),
//				TemplateId: mainAutoscalingInstanceTemplate.ID(),
//				Tags: pulumi.StringArray{
//					pulumi.String("terraform-test"),
//					pulumi.String("instance-group"),
//				},
//				Capacities: scaleway.AutoscalingInstanceGroupCapacityArray{
//					&scaleway.AutoscalingInstanceGroupCapacityArgs{
//						MaxReplicas:   pulumi.Int(5),
//						MinReplicas:   pulumi.Int(1),
//						CooldownDelay: pulumi.Int(300),
//					},
//				},
//				LoadBalancers: scaleway.AutoscalingInstanceGroupLoadBalancerArray{
//					&scaleway.AutoscalingInstanceGroupLoadBalancerArgs{
//						Id: mainLoadBalancer.ID(),
//						BackendIds: pulumi.StringArray{
//							mainBackend.ID(),
//						},
//						PrivateNetworkId: mainPrivateNetwork.ID(),
//					},
//				},
//				DeleteServersOnDestroy: pulumi.Bool(true),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = scaleway.NewAutoscalingInstancePolicy(ctx, "up", &scaleway.AutoscalingInstancePolicyArgs{
//				InstanceGroupId: mainAutoscalingInstanceGroup.ID(),
//				Name:            pulumi.String("scale-up-if-cpu-high"),
//				Action:          pulumi.String("scale_up"),
//				Type:            pulumi.String("flat_count"),
//				Value:           pulumi.Int(1),
//				Priority:        pulumi.Int(1),
//				Metrics: scaleway.AutoscalingInstancePolicyMetricArray{
//					&scaleway.AutoscalingInstancePolicyMetricArgs{
//						Name:             pulumi.String("cpu scale up"),
//						ManagedMetric:    pulumi.String("managed_metric_instance_cpu"),
//						Operator:         pulumi.String("operator_greater_than"),
//						Aggregate:        pulumi.String("aggregate_average"),
//						SamplingRangeMin: pulumi.Int(5),
//						Threshold:        pulumi.Int(70),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			_, err = scaleway.NewAutoscalingInstancePolicy(ctx, "down", &scaleway.AutoscalingInstancePolicyArgs{
//				InstanceGroupId: mainAutoscalingInstanceGroup.ID(),
//				Name:            pulumi.String("scale-down-if-cpu-low"),
//				Action:          pulumi.String("scale_down"),
//				Type:            pulumi.String("flat_count"),
//				Value:           pulumi.Int(1),
//				Priority:        pulumi.Int(2),
//				Metrics: scaleway.AutoscalingInstancePolicyMetricArray{
//					&scaleway.AutoscalingInstancePolicyMetricArgs{
//						Name:             pulumi.String("cpu scale down"),
//						ManagedMetric:    pulumi.String("managed_metric_instance_cpu"),
//						Operator:         pulumi.String("operator_less_than"),
//						Aggregate:        pulumi.String("aggregate_average"),
//						SamplingRangeMin: pulumi.Int(5),
//						Threshold:        pulumi.Int(40),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// Autoscaling Instance groups can be imported using `{zone}/{id}`, e.g.
//
// bash
//
// ```sh
// $ pulumi import scaleway:index/autoscalingInstanceGroup:AutoscalingInstanceGroup main fr-par-1/11111111-1111-1111-1111-111111111111
// ```
type AutoscalingInstanceGroup struct {
	pulumi.CustomResourceState

	// The specification of the minimum and maximum replicas for the Instance group, and the cooldown interval between two scaling events.
	Capacities AutoscalingInstanceGroupCapacityArrayOutput `pulumi:"capacities"`
	// Date and time of Instance group's creation (RFC 3339 format).
	CreatedAt pulumi.StringOutput `pulumi:"createdAt"`
	// Whether to delete all instances in this group when the group is destroyed. Set to `true` to tear them down, `false` (the default) leaves them running.
	DeleteServersOnDestroy pulumi.BoolPtrOutput `pulumi:"deleteServersOnDestroy"`
	// The specification of the Load Balancer to link to the Instance group.
	LoadBalancers AutoscalingInstanceGroupLoadBalancerArrayOutput `pulumi:"loadBalancers"`
	// The Instance group name.
	Name pulumi.StringOutput `pulumi:"name"`
	// `projectId`) The ID of the Project the Instance group is associated with.
	ProjectId pulumi.StringOutput `pulumi:"projectId"`
	// The tags associated with the Instance group.
	Tags pulumi.StringArrayOutput `pulumi:"tags"`
	// The ID of the Instance template to attach to the Instance group.
	TemplateId pulumi.StringOutput `pulumi:"templateId"`
	// Date and time of Instance group's last update (RFC 3339 format).
	UpdatedAt pulumi.StringOutput `pulumi:"updatedAt"`
	// `zone`) The zone in which the Instance group exists.
	Zone pulumi.StringOutput `pulumi:"zone"`
}

// NewAutoscalingInstanceGroup registers a new resource with the given unique name, arguments, and options.
func NewAutoscalingInstanceGroup(ctx *pulumi.Context,
	name string, args *AutoscalingInstanceGroupArgs, opts ...pulumi.ResourceOption) (*AutoscalingInstanceGroup, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.TemplateId == nil {
		return nil, errors.New("invalid value for required argument 'TemplateId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource AutoscalingInstanceGroup
	err := ctx.RegisterResource("scaleway:index/autoscalingInstanceGroup:AutoscalingInstanceGroup", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetAutoscalingInstanceGroup gets an existing AutoscalingInstanceGroup resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetAutoscalingInstanceGroup(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *AutoscalingInstanceGroupState, opts ...pulumi.ResourceOption) (*AutoscalingInstanceGroup, error) {
	var resource AutoscalingInstanceGroup
	err := ctx.ReadResource("scaleway:index/autoscalingInstanceGroup:AutoscalingInstanceGroup", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering AutoscalingInstanceGroup resources.
type autoscalingInstanceGroupState struct {
	// The specification of the minimum and maximum replicas for the Instance group, and the cooldown interval between two scaling events.
	Capacities []AutoscalingInstanceGroupCapacity `pulumi:"capacities"`
	// Date and time of Instance group's creation (RFC 3339 format).
	CreatedAt *string `pulumi:"createdAt"`
	// Whether to delete all instances in this group when the group is destroyed. Set to `true` to tear them down, `false` (the default) leaves them running.
	DeleteServersOnDestroy *bool `pulumi:"deleteServersOnDestroy"`
	// The specification of the Load Balancer to link to the Instance group.
	LoadBalancers []AutoscalingInstanceGroupLoadBalancer `pulumi:"loadBalancers"`
	// The Instance group name.
	Name *string `pulumi:"name"`
	// `projectId`) The ID of the Project the Instance group is associated with.
	ProjectId *string `pulumi:"projectId"`
	// The tags associated with the Instance group.
	Tags []string `pulumi:"tags"`
	// The ID of the Instance template to attach to the Instance group.
	TemplateId *string `pulumi:"templateId"`
	// Date and time of Instance group's last update (RFC 3339 format).
	UpdatedAt *string `pulumi:"updatedAt"`
	// `zone`) The zone in which the Instance group exists.
	Zone *string `pulumi:"zone"`
}

type AutoscalingInstanceGroupState struct {
	// The specification of the minimum and maximum replicas for the Instance group, and the cooldown interval between two scaling events.
	Capacities AutoscalingInstanceGroupCapacityArrayInput
	// Date and time of Instance group's creation (RFC 3339 format).
	CreatedAt pulumi.StringPtrInput
	// Whether to delete all instances in this group when the group is destroyed. Set to `true` to tear them down, `false` (the default) leaves them running.
	DeleteServersOnDestroy pulumi.BoolPtrInput
	// The specification of the Load Balancer to link to the Instance group.
	LoadBalancers AutoscalingInstanceGroupLoadBalancerArrayInput
	// The Instance group name.
	Name pulumi.StringPtrInput
	// `projectId`) The ID of the Project the Instance group is associated with.
	ProjectId pulumi.StringPtrInput
	// The tags associated with the Instance group.
	Tags pulumi.StringArrayInput
	// The ID of the Instance template to attach to the Instance group.
	TemplateId pulumi.StringPtrInput
	// Date and time of Instance group's last update (RFC 3339 format).
	UpdatedAt pulumi.StringPtrInput
	// `zone`) The zone in which the Instance group exists.
	Zone pulumi.StringPtrInput
}

func (AutoscalingInstanceGroupState) ElementType() reflect.Type {
	return reflect.TypeOf((*autoscalingInstanceGroupState)(nil)).Elem()
}

type autoscalingInstanceGroupArgs struct {
	// The specification of the minimum and maximum replicas for the Instance group, and the cooldown interval between two scaling events.
	Capacities []AutoscalingInstanceGroupCapacity `pulumi:"capacities"`
	// Whether to delete all instances in this group when the group is destroyed. Set to `true` to tear them down, `false` (the default) leaves them running.
	DeleteServersOnDestroy *bool `pulumi:"deleteServersOnDestroy"`
	// The specification of the Load Balancer to link to the Instance group.
	LoadBalancers []AutoscalingInstanceGroupLoadBalancer `pulumi:"loadBalancers"`
	// The Instance group name.
	Name *string `pulumi:"name"`
	// `projectId`) The ID of the Project the Instance group is associated with.
	ProjectId *string `pulumi:"projectId"`
	// The tags associated with the Instance group.
	Tags []string `pulumi:"tags"`
	// The ID of the Instance template to attach to the Instance group.
	TemplateId string `pulumi:"templateId"`
	// `zone`) The zone in which the Instance group exists.
	Zone *string `pulumi:"zone"`
}

// The set of arguments for constructing a AutoscalingInstanceGroup resource.
type AutoscalingInstanceGroupArgs struct {
	// The specification of the minimum and maximum replicas for the Instance group, and the cooldown interval between two scaling events.
	Capacities AutoscalingInstanceGroupCapacityArrayInput
	// Whether to delete all instances in this group when the group is destroyed. Set to `true` to tear them down, `false` (the default) leaves them running.
	DeleteServersOnDestroy pulumi.BoolPtrInput
	// The specification of the Load Balancer to link to the Instance group.
	LoadBalancers AutoscalingInstanceGroupLoadBalancerArrayInput
	// The Instance group name.
	Name pulumi.StringPtrInput
	// `projectId`) The ID of the Project the Instance group is associated with.
	ProjectId pulumi.StringPtrInput
	// The tags associated with the Instance group.
	Tags pulumi.StringArrayInput
	// The ID of the Instance template to attach to the Instance group.
	TemplateId pulumi.StringInput
	// `zone`) The zone in which the Instance group exists.
	Zone pulumi.StringPtrInput
}

func (AutoscalingInstanceGroupArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*autoscalingInstanceGroupArgs)(nil)).Elem()
}

type AutoscalingInstanceGroupInput interface {
	pulumi.Input

	ToAutoscalingInstanceGroupOutput() AutoscalingInstanceGroupOutput
	ToAutoscalingInstanceGroupOutputWithContext(ctx context.Context) AutoscalingInstanceGroupOutput
}

func (*AutoscalingInstanceGroup) ElementType() reflect.Type {
	return reflect.TypeOf((**AutoscalingInstanceGroup)(nil)).Elem()
}

func (i *AutoscalingInstanceGroup) ToAutoscalingInstanceGroupOutput() AutoscalingInstanceGroupOutput {
	return i.ToAutoscalingInstanceGroupOutputWithContext(context.Background())
}

func (i *AutoscalingInstanceGroup) ToAutoscalingInstanceGroupOutputWithContext(ctx context.Context) AutoscalingInstanceGroupOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AutoscalingInstanceGroupOutput)
}

// AutoscalingInstanceGroupArrayInput is an input type that accepts AutoscalingInstanceGroupArray and AutoscalingInstanceGroupArrayOutput values.
// You can construct a concrete instance of `AutoscalingInstanceGroupArrayInput` via:
//
//	AutoscalingInstanceGroupArray{ AutoscalingInstanceGroupArgs{...} }
type AutoscalingInstanceGroupArrayInput interface {
	pulumi.Input

	ToAutoscalingInstanceGroupArrayOutput() AutoscalingInstanceGroupArrayOutput
	ToAutoscalingInstanceGroupArrayOutputWithContext(context.Context) AutoscalingInstanceGroupArrayOutput
}

type AutoscalingInstanceGroupArray []AutoscalingInstanceGroupInput

func (AutoscalingInstanceGroupArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*AutoscalingInstanceGroup)(nil)).Elem()
}

func (i AutoscalingInstanceGroupArray) ToAutoscalingInstanceGroupArrayOutput() AutoscalingInstanceGroupArrayOutput {
	return i.ToAutoscalingInstanceGroupArrayOutputWithContext(context.Background())
}

func (i AutoscalingInstanceGroupArray) ToAutoscalingInstanceGroupArrayOutputWithContext(ctx context.Context) AutoscalingInstanceGroupArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AutoscalingInstanceGroupArrayOutput)
}

// AutoscalingInstanceGroupMapInput is an input type that accepts AutoscalingInstanceGroupMap and AutoscalingInstanceGroupMapOutput values.
// You can construct a concrete instance of `AutoscalingInstanceGroupMapInput` via:
//
//	AutoscalingInstanceGroupMap{ "key": AutoscalingInstanceGroupArgs{...} }
type AutoscalingInstanceGroupMapInput interface {
	pulumi.Input

	ToAutoscalingInstanceGroupMapOutput() AutoscalingInstanceGroupMapOutput
	ToAutoscalingInstanceGroupMapOutputWithContext(context.Context) AutoscalingInstanceGroupMapOutput
}

type AutoscalingInstanceGroupMap map[string]AutoscalingInstanceGroupInput

func (AutoscalingInstanceGroupMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*AutoscalingInstanceGroup)(nil)).Elem()
}

func (i AutoscalingInstanceGroupMap) ToAutoscalingInstanceGroupMapOutput() AutoscalingInstanceGroupMapOutput {
	return i.ToAutoscalingInstanceGroupMapOutputWithContext(context.Background())
}

func (i AutoscalingInstanceGroupMap) ToAutoscalingInstanceGroupMapOutputWithContext(ctx context.Context) AutoscalingInstanceGroupMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AutoscalingInstanceGroupMapOutput)
}

type AutoscalingInstanceGroupOutput struct{ *pulumi.OutputState }

func (AutoscalingInstanceGroupOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AutoscalingInstanceGroup)(nil)).Elem()
}

func (o AutoscalingInstanceGroupOutput) ToAutoscalingInstanceGroupOutput() AutoscalingInstanceGroupOutput {
	return o
}

func (o AutoscalingInstanceGroupOutput) ToAutoscalingInstanceGroupOutputWithContext(ctx context.Context) AutoscalingInstanceGroupOutput {
	return o
}

// The specification of the minimum and maximum replicas for the Instance group, and the cooldown interval between two scaling events.
func (o AutoscalingInstanceGroupOutput) Capacities() AutoscalingInstanceGroupCapacityArrayOutput {
	return o.ApplyT(func(v *AutoscalingInstanceGroup) AutoscalingInstanceGroupCapacityArrayOutput { return v.Capacities }).(AutoscalingInstanceGroupCapacityArrayOutput)
}

// Date and time of Instance group's creation (RFC 3339 format).
func (o AutoscalingInstanceGroupOutput) CreatedAt() pulumi.StringOutput {
	return o.ApplyT(func(v *AutoscalingInstanceGroup) pulumi.StringOutput { return v.CreatedAt }).(pulumi.StringOutput)
}

// Whether to delete all instances in this group when the group is destroyed. Set to `true` to tear them down, `false` (the default) leaves them running.
func (o AutoscalingInstanceGroupOutput) DeleteServersOnDestroy() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *AutoscalingInstanceGroup) pulumi.BoolPtrOutput { return v.DeleteServersOnDestroy }).(pulumi.BoolPtrOutput)
}

// The specification of the Load Balancer to link to the Instance group.
func (o AutoscalingInstanceGroupOutput) LoadBalancers() AutoscalingInstanceGroupLoadBalancerArrayOutput {
	return o.ApplyT(func(v *AutoscalingInstanceGroup) AutoscalingInstanceGroupLoadBalancerArrayOutput {
		return v.LoadBalancers
	}).(AutoscalingInstanceGroupLoadBalancerArrayOutput)
}

// The Instance group name.
func (o AutoscalingInstanceGroupOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *AutoscalingInstanceGroup) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// `projectId`) The ID of the Project the Instance group is associated with.
func (o AutoscalingInstanceGroupOutput) ProjectId() pulumi.StringOutput {
	return o.ApplyT(func(v *AutoscalingInstanceGroup) pulumi.StringOutput { return v.ProjectId }).(pulumi.StringOutput)
}

// The tags associated with the Instance group.
func (o AutoscalingInstanceGroupOutput) Tags() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *AutoscalingInstanceGroup) pulumi.StringArrayOutput { return v.Tags }).(pulumi.StringArrayOutput)
}

// The ID of the Instance template to attach to the Instance group.
func (o AutoscalingInstanceGroupOutput) TemplateId() pulumi.StringOutput {
	return o.ApplyT(func(v *AutoscalingInstanceGroup) pulumi.StringOutput { return v.TemplateId }).(pulumi.StringOutput)
}

// Date and time of Instance group's last update (RFC 3339 format).
func (o AutoscalingInstanceGroupOutput) UpdatedAt() pulumi.StringOutput {
	return o.ApplyT(func(v *AutoscalingInstanceGroup) pulumi.StringOutput { return v.UpdatedAt }).(pulumi.StringOutput)
}

// `zone`) The zone in which the Instance group exists.
func (o AutoscalingInstanceGroupOutput) Zone() pulumi.StringOutput {
	return o.ApplyT(func(v *AutoscalingInstanceGroup) pulumi.StringOutput { return v.Zone }).(pulumi.StringOutput)
}

type AutoscalingInstanceGroupArrayOutput struct{ *pulumi.OutputState }

func (AutoscalingInstanceGroupArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*AutoscalingInstanceGroup)(nil)).Elem()
}

func (o AutoscalingInstanceGroupArrayOutput) ToAutoscalingInstanceGroupArrayOutput() AutoscalingInstanceGroupArrayOutput {
	return o
}

func (o AutoscalingInstanceGroupArrayOutput) ToAutoscalingInstanceGroupArrayOutputWithContext(ctx context.Context) AutoscalingInstanceGroupArrayOutput {
	return o
}

func (o AutoscalingInstanceGroupArrayOutput) Index(i pulumi.IntInput) AutoscalingInstanceGroupOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *AutoscalingInstanceGroup {
		return vs[0].([]*AutoscalingInstanceGroup)[vs[1].(int)]
	}).(AutoscalingInstanceGroupOutput)
}

type AutoscalingInstanceGroupMapOutput struct{ *pulumi.OutputState }

func (AutoscalingInstanceGroupMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*AutoscalingInstanceGroup)(nil)).Elem()
}

func (o AutoscalingInstanceGroupMapOutput) ToAutoscalingInstanceGroupMapOutput() AutoscalingInstanceGroupMapOutput {
	return o
}

func (o AutoscalingInstanceGroupMapOutput) ToAutoscalingInstanceGroupMapOutputWithContext(ctx context.Context) AutoscalingInstanceGroupMapOutput {
	return o
}

func (o AutoscalingInstanceGroupMapOutput) MapIndex(k pulumi.StringInput) AutoscalingInstanceGroupOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *AutoscalingInstanceGroup {
		return vs[0].(map[string]*AutoscalingInstanceGroup)[vs[1].(string)]
	}).(AutoscalingInstanceGroupOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*AutoscalingInstanceGroupInput)(nil)).Elem(), &AutoscalingInstanceGroup{})
	pulumi.RegisterInputType(reflect.TypeOf((*AutoscalingInstanceGroupArrayInput)(nil)).Elem(), AutoscalingInstanceGroupArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*AutoscalingInstanceGroupMapInput)(nil)).Elem(), AutoscalingInstanceGroupMap{})
	pulumi.RegisterOutputType(AutoscalingInstanceGroupOutput{})
	pulumi.RegisterOutputType(AutoscalingInstanceGroupArrayOutput{})
	pulumi.RegisterOutputType(AutoscalingInstanceGroupMapOutput{})
}
