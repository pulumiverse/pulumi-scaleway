// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package keymanager

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumiverse/pulumi-scaleway/sdk/go/scaleway/internal"
)

// Provides a Scaleway Key Manager Key resource.\
// This resource allows you to create and manage cryptographic keys in Scaleway Key Manager (KMS).
//
// ## Example Usage
//
// ### Symmetric Encryption Key
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/pulumiverse/pulumi-scaleway/sdk/go/scaleway/keymanager"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := keymanager.NewKey(ctx, "symmetric", &keymanager.KeyArgs{
//				Name:        pulumi.String("my-kms-key"),
//				Region:      pulumi.String("fr-par"),
//				ProjectId:   pulumi.String("your-project-id"),
//				Usage:       pulumi.String("symmetric_encryption"),
//				Algorithm:   pulumi.String("aes_256_gcm"),
//				Description: pulumi.String("Key for encrypting secrets"),
//				Tags: pulumi.StringArray{
//					pulumi.String("env:prod"),
//					pulumi.String("kms"),
//				},
//				Unprotected: pulumi.Bool(true),
//				RotationPolicy: &keymanager.KeyRotationPolicyArgs{
//					RotationPeriod: pulumi.String("720h"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ### Asymmetric Encryption Key with RSA-4096
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/pulumiverse/pulumi-scaleway/sdk/go/scaleway/keymanager"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := keymanager.NewKey(ctx, "rsa_4096", &keymanager.KeyArgs{
//				Name:        pulumi.String("rsa-4096-key"),
//				Region:      pulumi.String("fr-par"),
//				Usage:       pulumi.String("asymmetric_encryption"),
//				Algorithm:   pulumi.String("rsa_oaep_4096_sha256"),
//				Description: pulumi.String("Key for encrypting large files with RSA-4096"),
//				Unprotected: pulumi.Bool(true),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ### Asymmetric Signing Key
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/pulumiverse/pulumi-scaleway/sdk/go/scaleway/keymanager"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := keymanager.NewKey(ctx, "signing", &keymanager.KeyArgs{
//				Name:        pulumi.String("signing-key"),
//				Region:      pulumi.String("fr-par"),
//				Usage:       pulumi.String("asymmetric_signing"),
//				Algorithm:   pulumi.String("rsa_pss_2048_sha256"),
//				Description: pulumi.String("Key for signing documents"),
//				Unprotected: pulumi.Bool(true),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Notes
//
// - **Protection**: By default, keys are protected and cannot be deleted. To allow deletion, set `unprotected = true` when creating the key.
// - **Rotation Policy**: The `rotationPolicy` block allows you to set automatic rotation for your key.
// - **Origin**: The `origin` argument is optional and defaults to `scalewayKms`. Use `external` if you want to import an external key (see Scaleway documentation for details).
// - **Project and Region**: If not specified, `projectId` and `region` will default to the provider configuration.
// - **Algorithm Validation**: The provider validates that the specified `algorithm` is compatible with the `usage` type at plan time, providing early feedback on configuration errors.
//
// ## Import
//
// You can import a key using its ID and region:
//
// ```sh
// $ pulumi import scaleway:keymanager/key:Key main fr-par/11111111-2222-3333-4444-555555555555
// ```
type Key struct {
	pulumi.CustomResourceState

	// – The cryptographic algorithm to use. Valid values depend on the `usage`:
	// - For `symmetricEncryption`:
	Algorithm pulumi.StringOutput `pulumi:"algorithm"`
	// The date and time when the key was created.
	CreatedAt pulumi.StringOutput `pulumi:"createdAt"`
	// – A description for the key.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// Whether the key is locked.
	Locked pulumi.BoolOutput `pulumi:"locked"`
	// The name of the key.
	Name pulumi.StringOutput `pulumi:"name"`
	// – The origin of the key. Valid values are:
	Origin pulumi.StringPtrOutput `pulumi:"origin"`
	// – The ID of the project the key belongs to.
	//
	// **Key Usage and Algorithm (both required):**
	ProjectId pulumi.StringOutput `pulumi:"projectId"`
	// Whether the key is protected from deletion.
	Protected pulumi.BoolOutput `pulumi:"protected"`
	// The region in which to create the key (e.g., `fr-par`).
	Region pulumi.StringPtrOutput `pulumi:"region"`
	// The date and time when the key was last rotated.
	RotatedAt pulumi.StringOutput `pulumi:"rotatedAt"`
	// The number of times the key has been rotated.
	RotationCount pulumi.IntOutput `pulumi:"rotationCount"`
	// – Rotation policy for the key:
	RotationPolicy KeyRotationPolicyPtrOutput `pulumi:"rotationPolicy"`
	// The state of the key (e.g., `enabled`).
	State pulumi.StringOutput `pulumi:"state"`
	// – A list of tags to assign to the key.
	Tags pulumi.StringArrayOutput `pulumi:"tags"`
	// – If `true`, the key can be deleted. Defaults to `false` (protected).
	Unprotected pulumi.BoolPtrOutput `pulumi:"unprotected"`
	// The date and time when the key was last updated.
	UpdatedAt pulumi.StringOutput `pulumi:"updatedAt"`
	// – The usage type of the key. Valid values:
	Usage pulumi.StringOutput `pulumi:"usage"`
}

// NewKey registers a new resource with the given unique name, arguments, and options.
func NewKey(ctx *pulumi.Context,
	name string, args *KeyArgs, opts ...pulumi.ResourceOption) (*Key, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Algorithm == nil {
		return nil, errors.New("invalid value for required argument 'Algorithm'")
	}
	if args.Usage == nil {
		return nil, errors.New("invalid value for required argument 'Usage'")
	}
	aliases := pulumi.Aliases([]pulumi.Alias{
		{
			Type: pulumi.String("scaleway:index/keyManagerKey:KeyManagerKey"),
		},
	})
	opts = append(opts, aliases)
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Key
	err := ctx.RegisterResource("scaleway:keymanager/key:Key", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetKey gets an existing Key resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetKey(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *KeyState, opts ...pulumi.ResourceOption) (*Key, error) {
	var resource Key
	err := ctx.ReadResource("scaleway:keymanager/key:Key", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Key resources.
type keyState struct {
	// – The cryptographic algorithm to use. Valid values depend on the `usage`:
	// - For `symmetricEncryption`:
	Algorithm *string `pulumi:"algorithm"`
	// The date and time when the key was created.
	CreatedAt *string `pulumi:"createdAt"`
	// – A description for the key.
	Description *string `pulumi:"description"`
	// Whether the key is locked.
	Locked *bool `pulumi:"locked"`
	// The name of the key.
	Name *string `pulumi:"name"`
	// – The origin of the key. Valid values are:
	Origin *string `pulumi:"origin"`
	// – The ID of the project the key belongs to.
	//
	// **Key Usage and Algorithm (both required):**
	ProjectId *string `pulumi:"projectId"`
	// Whether the key is protected from deletion.
	Protected *bool `pulumi:"protected"`
	// The region in which to create the key (e.g., `fr-par`).
	Region *string `pulumi:"region"`
	// The date and time when the key was last rotated.
	RotatedAt *string `pulumi:"rotatedAt"`
	// The number of times the key has been rotated.
	RotationCount *int `pulumi:"rotationCount"`
	// – Rotation policy for the key:
	RotationPolicy *KeyRotationPolicy `pulumi:"rotationPolicy"`
	// The state of the key (e.g., `enabled`).
	State *string `pulumi:"state"`
	// – A list of tags to assign to the key.
	Tags []string `pulumi:"tags"`
	// – If `true`, the key can be deleted. Defaults to `false` (protected).
	Unprotected *bool `pulumi:"unprotected"`
	// The date and time when the key was last updated.
	UpdatedAt *string `pulumi:"updatedAt"`
	// – The usage type of the key. Valid values:
	Usage *string `pulumi:"usage"`
}

type KeyState struct {
	// – The cryptographic algorithm to use. Valid values depend on the `usage`:
	// - For `symmetricEncryption`:
	Algorithm pulumi.StringPtrInput
	// The date and time when the key was created.
	CreatedAt pulumi.StringPtrInput
	// – A description for the key.
	Description pulumi.StringPtrInput
	// Whether the key is locked.
	Locked pulumi.BoolPtrInput
	// The name of the key.
	Name pulumi.StringPtrInput
	// – The origin of the key. Valid values are:
	Origin pulumi.StringPtrInput
	// – The ID of the project the key belongs to.
	//
	// **Key Usage and Algorithm (both required):**
	ProjectId pulumi.StringPtrInput
	// Whether the key is protected from deletion.
	Protected pulumi.BoolPtrInput
	// The region in which to create the key (e.g., `fr-par`).
	Region pulumi.StringPtrInput
	// The date and time when the key was last rotated.
	RotatedAt pulumi.StringPtrInput
	// The number of times the key has been rotated.
	RotationCount pulumi.IntPtrInput
	// – Rotation policy for the key:
	RotationPolicy KeyRotationPolicyPtrInput
	// The state of the key (e.g., `enabled`).
	State pulumi.StringPtrInput
	// – A list of tags to assign to the key.
	Tags pulumi.StringArrayInput
	// – If `true`, the key can be deleted. Defaults to `false` (protected).
	Unprotected pulumi.BoolPtrInput
	// The date and time when the key was last updated.
	UpdatedAt pulumi.StringPtrInput
	// – The usage type of the key. Valid values:
	Usage pulumi.StringPtrInput
}

func (KeyState) ElementType() reflect.Type {
	return reflect.TypeOf((*keyState)(nil)).Elem()
}

type keyArgs struct {
	// – The cryptographic algorithm to use. Valid values depend on the `usage`:
	// - For `symmetricEncryption`:
	Algorithm string `pulumi:"algorithm"`
	// – A description for the key.
	Description *string `pulumi:"description"`
	// The name of the key.
	Name *string `pulumi:"name"`
	// – The origin of the key. Valid values are:
	Origin *string `pulumi:"origin"`
	// – The ID of the project the key belongs to.
	//
	// **Key Usage and Algorithm (both required):**
	ProjectId *string `pulumi:"projectId"`
	// The region in which to create the key (e.g., `fr-par`).
	Region *string `pulumi:"region"`
	// – Rotation policy for the key:
	RotationPolicy *KeyRotationPolicy `pulumi:"rotationPolicy"`
	// – A list of tags to assign to the key.
	Tags []string `pulumi:"tags"`
	// – If `true`, the key can be deleted. Defaults to `false` (protected).
	Unprotected *bool `pulumi:"unprotected"`
	// – The usage type of the key. Valid values:
	Usage string `pulumi:"usage"`
}

// The set of arguments for constructing a Key resource.
type KeyArgs struct {
	// – The cryptographic algorithm to use. Valid values depend on the `usage`:
	// - For `symmetricEncryption`:
	Algorithm pulumi.StringInput
	// – A description for the key.
	Description pulumi.StringPtrInput
	// The name of the key.
	Name pulumi.StringPtrInput
	// – The origin of the key. Valid values are:
	Origin pulumi.StringPtrInput
	// – The ID of the project the key belongs to.
	//
	// **Key Usage and Algorithm (both required):**
	ProjectId pulumi.StringPtrInput
	// The region in which to create the key (e.g., `fr-par`).
	Region pulumi.StringPtrInput
	// – Rotation policy for the key:
	RotationPolicy KeyRotationPolicyPtrInput
	// – A list of tags to assign to the key.
	Tags pulumi.StringArrayInput
	// – If `true`, the key can be deleted. Defaults to `false` (protected).
	Unprotected pulumi.BoolPtrInput
	// – The usage type of the key. Valid values:
	Usage pulumi.StringInput
}

func (KeyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*keyArgs)(nil)).Elem()
}

type KeyInput interface {
	pulumi.Input

	ToKeyOutput() KeyOutput
	ToKeyOutputWithContext(ctx context.Context) KeyOutput
}

func (*Key) ElementType() reflect.Type {
	return reflect.TypeOf((**Key)(nil)).Elem()
}

func (i *Key) ToKeyOutput() KeyOutput {
	return i.ToKeyOutputWithContext(context.Background())
}

func (i *Key) ToKeyOutputWithContext(ctx context.Context) KeyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KeyOutput)
}

// KeyArrayInput is an input type that accepts KeyArray and KeyArrayOutput values.
// You can construct a concrete instance of `KeyArrayInput` via:
//
//	KeyArray{ KeyArgs{...} }
type KeyArrayInput interface {
	pulumi.Input

	ToKeyArrayOutput() KeyArrayOutput
	ToKeyArrayOutputWithContext(context.Context) KeyArrayOutput
}

type KeyArray []KeyInput

func (KeyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Key)(nil)).Elem()
}

func (i KeyArray) ToKeyArrayOutput() KeyArrayOutput {
	return i.ToKeyArrayOutputWithContext(context.Background())
}

func (i KeyArray) ToKeyArrayOutputWithContext(ctx context.Context) KeyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KeyArrayOutput)
}

// KeyMapInput is an input type that accepts KeyMap and KeyMapOutput values.
// You can construct a concrete instance of `KeyMapInput` via:
//
//	KeyMap{ "key": KeyArgs{...} }
type KeyMapInput interface {
	pulumi.Input

	ToKeyMapOutput() KeyMapOutput
	ToKeyMapOutputWithContext(context.Context) KeyMapOutput
}

type KeyMap map[string]KeyInput

func (KeyMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Key)(nil)).Elem()
}

func (i KeyMap) ToKeyMapOutput() KeyMapOutput {
	return i.ToKeyMapOutputWithContext(context.Background())
}

func (i KeyMap) ToKeyMapOutputWithContext(ctx context.Context) KeyMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KeyMapOutput)
}

type KeyOutput struct{ *pulumi.OutputState }

func (KeyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Key)(nil)).Elem()
}

func (o KeyOutput) ToKeyOutput() KeyOutput {
	return o
}

func (o KeyOutput) ToKeyOutputWithContext(ctx context.Context) KeyOutput {
	return o
}

// – The cryptographic algorithm to use. Valid values depend on the `usage`:
// - For `symmetricEncryption`:
func (o KeyOutput) Algorithm() pulumi.StringOutput {
	return o.ApplyT(func(v *Key) pulumi.StringOutput { return v.Algorithm }).(pulumi.StringOutput)
}

// The date and time when the key was created.
func (o KeyOutput) CreatedAt() pulumi.StringOutput {
	return o.ApplyT(func(v *Key) pulumi.StringOutput { return v.CreatedAt }).(pulumi.StringOutput)
}

// – A description for the key.
func (o KeyOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Key) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// Whether the key is locked.
func (o KeyOutput) Locked() pulumi.BoolOutput {
	return o.ApplyT(func(v *Key) pulumi.BoolOutput { return v.Locked }).(pulumi.BoolOutput)
}

// The name of the key.
func (o KeyOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Key) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// – The origin of the key. Valid values are:
func (o KeyOutput) Origin() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Key) pulumi.StringPtrOutput { return v.Origin }).(pulumi.StringPtrOutput)
}

// – The ID of the project the key belongs to.
//
// **Key Usage and Algorithm (both required):**
func (o KeyOutput) ProjectId() pulumi.StringOutput {
	return o.ApplyT(func(v *Key) pulumi.StringOutput { return v.ProjectId }).(pulumi.StringOutput)
}

// Whether the key is protected from deletion.
func (o KeyOutput) Protected() pulumi.BoolOutput {
	return o.ApplyT(func(v *Key) pulumi.BoolOutput { return v.Protected }).(pulumi.BoolOutput)
}

// The region in which to create the key (e.g., `fr-par`).
func (o KeyOutput) Region() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Key) pulumi.StringPtrOutput { return v.Region }).(pulumi.StringPtrOutput)
}

// The date and time when the key was last rotated.
func (o KeyOutput) RotatedAt() pulumi.StringOutput {
	return o.ApplyT(func(v *Key) pulumi.StringOutput { return v.RotatedAt }).(pulumi.StringOutput)
}

// The number of times the key has been rotated.
func (o KeyOutput) RotationCount() pulumi.IntOutput {
	return o.ApplyT(func(v *Key) pulumi.IntOutput { return v.RotationCount }).(pulumi.IntOutput)
}

// – Rotation policy for the key:
func (o KeyOutput) RotationPolicy() KeyRotationPolicyPtrOutput {
	return o.ApplyT(func(v *Key) KeyRotationPolicyPtrOutput { return v.RotationPolicy }).(KeyRotationPolicyPtrOutput)
}

// The state of the key (e.g., `enabled`).
func (o KeyOutput) State() pulumi.StringOutput {
	return o.ApplyT(func(v *Key) pulumi.StringOutput { return v.State }).(pulumi.StringOutput)
}

// – A list of tags to assign to the key.
func (o KeyOutput) Tags() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Key) pulumi.StringArrayOutput { return v.Tags }).(pulumi.StringArrayOutput)
}

// – If `true`, the key can be deleted. Defaults to `false` (protected).
func (o KeyOutput) Unprotected() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Key) pulumi.BoolPtrOutput { return v.Unprotected }).(pulumi.BoolPtrOutput)
}

// The date and time when the key was last updated.
func (o KeyOutput) UpdatedAt() pulumi.StringOutput {
	return o.ApplyT(func(v *Key) pulumi.StringOutput { return v.UpdatedAt }).(pulumi.StringOutput)
}

// – The usage type of the key. Valid values:
func (o KeyOutput) Usage() pulumi.StringOutput {
	return o.ApplyT(func(v *Key) pulumi.StringOutput { return v.Usage }).(pulumi.StringOutput)
}

type KeyArrayOutput struct{ *pulumi.OutputState }

func (KeyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Key)(nil)).Elem()
}

func (o KeyArrayOutput) ToKeyArrayOutput() KeyArrayOutput {
	return o
}

func (o KeyArrayOutput) ToKeyArrayOutputWithContext(ctx context.Context) KeyArrayOutput {
	return o
}

func (o KeyArrayOutput) Index(i pulumi.IntInput) KeyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Key {
		return vs[0].([]*Key)[vs[1].(int)]
	}).(KeyOutput)
}

type KeyMapOutput struct{ *pulumi.OutputState }

func (KeyMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Key)(nil)).Elem()
}

func (o KeyMapOutput) ToKeyMapOutput() KeyMapOutput {
	return o
}

func (o KeyMapOutput) ToKeyMapOutputWithContext(ctx context.Context) KeyMapOutput {
	return o
}

func (o KeyMapOutput) MapIndex(k pulumi.StringInput) KeyOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Key {
		return vs[0].(map[string]*Key)[vs[1].(string)]
	}).(KeyOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*KeyInput)(nil)).Elem(), &Key{})
	pulumi.RegisterInputType(reflect.TypeOf((*KeyArrayInput)(nil)).Elem(), KeyArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*KeyMapInput)(nil)).Elem(), KeyMap{})
	pulumi.RegisterOutputType(KeyOutput{})
	pulumi.RegisterOutputType(KeyArrayOutput{})
	pulumi.RegisterOutputType(KeyMapOutput{})
}
