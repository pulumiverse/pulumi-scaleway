// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package kubernetes

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumiverse/pulumi-scaleway/sdk/go/scaleway/internal"
)

// Creates and manages Scaleway Kubernetes clusters. For more information, see the [API documentation](https://www.scaleway.com/en/developers/api/kubernetes/).
//
// ## Example Usage
//
// ### Basic
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/pulumiverse/pulumi-scaleway/sdk/go/scaleway/kubernetes"
//	"github.com/pulumiverse/pulumi-scaleway/sdk/go/scaleway/network"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			pn, err := network.NewPrivateNetwork(ctx, "pn", nil)
//			if err != nil {
//				return err
//			}
//			cluster, err := kubernetes.NewCluster(ctx, "cluster", &kubernetes.ClusterArgs{
//				Name:                      pulumi.String("tf-cluster"),
//				Version:                   pulumi.String("1.29.1"),
//				Cni:                       pulumi.String("cilium"),
//				PrivateNetworkId:          pn.ID(),
//				DeleteAdditionalResources: pulumi.Bool(false),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = kubernetes.NewPool(ctx, "pool", &kubernetes.PoolArgs{
//				ClusterId: cluster.ID(),
//				Name:      pulumi.String("tf-pool"),
//				NodeType:  pulumi.String("DEV1-M"),
//				Size:      pulumi.Int(1),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ### Multicloud
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/pulumiverse/pulumi-scaleway/sdk/go/scaleway/kubernetes"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			cluster, err := kubernetes.NewCluster(ctx, "cluster", &kubernetes.ClusterArgs{
//				Name:                      pulumi.String("tf-cluster"),
//				Type:                      pulumi.String("multicloud"),
//				Version:                   pulumi.String("1.29.1"),
//				Cni:                       pulumi.String("kilo"),
//				DeleteAdditionalResources: pulumi.Bool(false),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = kubernetes.NewPool(ctx, "pool", &kubernetes.PoolArgs{
//				ClusterId: cluster.ID(),
//				Name:      pulumi.String("tf-pool"),
//				NodeType:  pulumi.String("external"),
//				Size:      pulumi.Int(0),
//				MinSize:   pulumi.Int(0),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// For a detailed example of how to add or run Elastic Metal servers instead of Instances on your cluster, please refer to this guide.
//
// ### With additional configuration
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/pulumiverse/pulumi-scaleway/sdk/go/scaleway/kubernetes"
//	"github.com/pulumiverse/pulumi-scaleway/sdk/go/scaleway/network"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			pn, err := network.NewPrivateNetwork(ctx, "pn", nil)
//			if err != nil {
//				return err
//			}
//			cluster, err := kubernetes.NewCluster(ctx, "cluster", &kubernetes.ClusterArgs{
//				Name:        pulumi.String("tf-cluster"),
//				Description: pulumi.String("cluster made in terraform"),
//				Version:     pulumi.String("1.29.1"),
//				Cni:         pulumi.String("calico"),
//				Tags: pulumi.StringArray{
//					pulumi.String("terraform"),
//				},
//				PrivateNetworkId:          pn.ID(),
//				DeleteAdditionalResources: pulumi.Bool(false),
//				AutoscalerConfig: &kubernetes.ClusterAutoscalerConfigArgs{
//					DisableScaleDown:             pulumi.Bool(false),
//					ScaleDownDelayAfterAdd:       pulumi.String("5m"),
//					Estimator:                    pulumi.String("binpacking"),
//					Expander:                     pulumi.String("random"),
//					IgnoreDaemonsetsUtilization:  pulumi.Bool(true),
//					BalanceSimilarNodeGroups:     pulumi.Bool(true),
//					ExpendablePodsPriorityCutoff: pulumi.Int(-5),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			_, err = kubernetes.NewPool(ctx, "pool", &kubernetes.PoolArgs{
//				ClusterId:   cluster.ID(),
//				Name:        pulumi.String("tf-pool"),
//				NodeType:    pulumi.String("DEV1-M"),
//				Size:        pulumi.Int(3),
//				Autoscaling: pulumi.Bool(true),
//				Autohealing: pulumi.Bool(true),
//				MinSize:     pulumi.Int(1),
//				MaxSize:     pulumi.Int(5),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ### With the kubernetes provider
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-null/sdk/go/null"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/pulumiverse/pulumi-scaleway/sdk/go/scaleway/kubernetes"
//	"github.com/pulumiverse/pulumi-scaleway/sdk/go/scaleway/network"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			pn, err := network.NewPrivateNetwork(ctx, "pn", nil)
//			if err != nil {
//				return err
//			}
//			cluster, err := kubernetes.NewCluster(ctx, "cluster", &kubernetes.ClusterArgs{
//				Name:                      pulumi.String("tf-cluster"),
//				Version:                   pulumi.String("1.29.1"),
//				Cni:                       pulumi.String("cilium"),
//				PrivateNetworkId:          pn.ID(),
//				DeleteAdditionalResources: pulumi.Bool(false),
//			})
//			if err != nil {
//				return err
//			}
//			pool, err := kubernetes.NewPool(ctx, "pool", &kubernetes.PoolArgs{
//				ClusterId: cluster.ID(),
//				Name:      pulumi.String("tf-pool"),
//				NodeType:  pulumi.String("DEV1-M"),
//				Size:      pulumi.Int(1),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = null.NewResource(ctx, "kubeconfig", &null.ResourceArgs{
//				Triggers: pulumi.StringMap{
//					"host": pulumi.String(cluster.Kubeconfigs.ApplyT(func(kubeconfigs []kubernetes.ClusterKubeconfig) (*string, error) {
//						return &kubeconfigs[0].Host, nil
//					}).(pulumi.StringPtrOutput)),
//					"token": pulumi.String(cluster.Kubeconfigs.ApplyT(func(kubeconfigs []kubernetes.ClusterKubeconfig) (*string, error) {
//						return &kubeconfigs[0].Token, nil
//					}).(pulumi.StringPtrOutput)),
//					"cluster_ca_certificate": pulumi.String(cluster.Kubeconfigs.ApplyT(func(kubeconfigs []kubernetes.ClusterKubeconfig) (*string, error) {
//						return &kubeconfigs[0].ClusterCaCertificate, nil
//					}).(pulumi.StringPtrOutput)),
//				},
//			}, pulumi.DependsOn([]pulumi.Resource{
//				pool,
//			}))
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// The `nullResource` is needed because when the cluster is created, its status is `poolRequired`, but the kubeconfig can already be downloaded.
// It leads the `kubernetes` provider to start creating its objects, but the DNS entry for the Kubernetes master is not yet ready, that's why it's needed to wait for at least a pool.
//
// ### With the Helm provider
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-helm/sdk/go/helm"
//	"github.com/pulumi/pulumi-null/sdk/go/null"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/pulumiverse/pulumi-scaleway/sdk/go/scaleway/kubernetes"
//	"github.com/pulumiverse/pulumi-scaleway/sdk/go/scaleway/loadbalancers"
//	"github.com/pulumiverse/pulumi-scaleway/sdk/go/scaleway/network"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			pn, err := network.NewPrivateNetwork(ctx, "pn", nil)
//			if err != nil {
//				return err
//			}
//			cluster, err := kubernetes.NewCluster(ctx, "cluster", &kubernetes.ClusterArgs{
//				Name:                      pulumi.String("tf-cluster"),
//				Version:                   pulumi.String("1.29.1"),
//				Cni:                       pulumi.String("cilium"),
//				DeleteAdditionalResources: pulumi.Bool(false),
//				PrivateNetworkId:          pn.ID(),
//			})
//			if err != nil {
//				return err
//			}
//			pool, err := kubernetes.NewPool(ctx, "pool", &kubernetes.PoolArgs{
//				ClusterId: cluster.ID(),
//				Name:      pulumi.String("tf-pool"),
//				NodeType:  pulumi.String("DEV1-M"),
//				Size:      pulumi.Int(1),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = null.NewResource(ctx, "kubeconfig", &null.ResourceArgs{
//				Triggers: pulumi.StringMap{
//					"host": pulumi.String(cluster.Kubeconfigs.ApplyT(func(kubeconfigs []kubernetes.ClusterKubeconfig) (*string, error) {
//						return &kubeconfigs[0].Host, nil
//					}).(pulumi.StringPtrOutput)),
//					"token": pulumi.String(cluster.Kubeconfigs.ApplyT(func(kubeconfigs []kubernetes.ClusterKubeconfig) (*string, error) {
//						return &kubeconfigs[0].Token, nil
//					}).(pulumi.StringPtrOutput)),
//					"cluster_ca_certificate": pulumi.String(cluster.Kubeconfigs.ApplyT(func(kubeconfigs []kubernetes.ClusterKubeconfig) (*string, error) {
//						return &kubeconfigs[0].ClusterCaCertificate, nil
//					}).(pulumi.StringPtrOutput)),
//				},
//			}, pulumi.DependsOn([]pulumi.Resource{
//				pool,
//			}))
//			if err != nil {
//				return err
//			}
//			nginxIp, err := loadbalancers.NewIp(ctx, "nginx_ip", &loadbalancers.IpArgs{
//				Zone:      pulumi.String("fr-par-1"),
//				ProjectId: cluster.ProjectId,
//			})
//			if err != nil {
//				return err
//			}
//			_, err = helm.NewRelease(ctx, "nginx_ingress", &helm.ReleaseArgs{
//				Name:       "nginx-ingress",
//				Namespace:  "kube-system",
//				Repository: "https://kubernetes.github.io/ingress-nginx",
//				Chart:      "ingress-nginx",
//				Set: []map[string]interface{}{
//					map[string]interface{}{
//						"name":  "controller.service.loadBalancerIP",
//						"value": nginxIp.IpAddress,
//					},
//					map[string]interface{}{
//						"name":  "controller.config.use-proxy-protocol",
//						"value": "true",
//					},
//					map[string]interface{}{
//						"name":  "controller.service.annotations.service\\.beta\\.kubernetes\\.io/scw-loadbalancer-proxy-protocol-v2",
//						"value": "true",
//					},
//					map[string]interface{}{
//						"name":  "controller.service.annotations.service\\.beta\\.kubernetes\\.io/scw-loadbalancer-zone",
//						"value": nginxIp.Zone,
//					},
//					map[string]interface{}{
//						"name":  "controller.service.externalTrafficPolicy",
//						"value": "Local",
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// Kubernetes clusters can be imported using the `{region}/{id}`, e.g.
//
// bash
//
// ```sh
// $ pulumi import scaleway:kubernetes/cluster:Cluster mycluster fr-par/11111111-1111-1111-1111-111111111111
// ```
type Cluster struct {
	pulumi.CustomResourceState

	// The list of [admission plugins](https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/) to enable on the cluster.
	AdmissionPlugins pulumi.StringArrayOutput `pulumi:"admissionPlugins"`
	// Additional Subject Alternative Names for the Kubernetes API server certificate
	ApiserverCertSans pulumi.StringArrayOutput `pulumi:"apiserverCertSans"`
	// The URL of the Kubernetes API server.
	ApiserverUrl pulumi.StringOutput `pulumi:"apiserverUrl"`
	// The auto upgrade configuration.
	AutoUpgrade ClusterAutoUpgradeOutput `pulumi:"autoUpgrade"`
	// The configuration options for the [Kubernetes cluster autoscaler](https://github.com/kubernetes/autoscaler/tree/master/cluster-autoscaler).
	AutoscalerConfig ClusterAutoscalerConfigOutput `pulumi:"autoscalerConfig"`
	// The Container Network Interface (CNI) for the Kubernetes cluster.
	// > **Important:** Updates to this field will recreate a new resource.
	Cni pulumi.StringOutput `pulumi:"cni"`
	// The creation date of the cluster.
	CreatedAt pulumi.StringOutput `pulumi:"createdAt"`
	// Delete additional resources like block volumes, load-balancers and the cluster's private network (if empty) that were created in Kubernetes on cluster deletion.
	// > **Important:** Setting this field to `true` means that you will lose all your cluster data and network configuration when you delete your cluster.
	// If you prefer keeping it, you should instead set it as `false`.
	DeleteAdditionalResources pulumi.BoolOutput `pulumi:"deleteAdditionalResources"`
	// A description for the Kubernetes cluster.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// The list of [feature gates](https://kubernetes.io/docs/reference/command-line-tools-reference/feature-gates/) to enable on the cluster.
	FeatureGates pulumi.StringArrayOutput `pulumi:"featureGates"`
	// The kubeconfig configuration file of the Kubernetes cluster
	Kubeconfigs ClusterKubeconfigArrayOutput `pulumi:"kubeconfigs"`
	// The name for the Kubernetes cluster.
	Name pulumi.StringOutput `pulumi:"name"`
	// The OpenID Connect configuration of the cluster
	OpenIdConnectConfig ClusterOpenIdConnectConfigOutput `pulumi:"openIdConnectConfig"`
	// The organization ID the cluster is associated with.
	OrganizationId pulumi.StringOutput `pulumi:"organizationId"`
	// The ID of the private network of the cluster.
	//
	// > **Important:** Changes to this field will recreate a new resource.
	//
	// > **Important:** Private Networks are now mandatory with Kapsule Clusters. If you have a legacy cluster (no `privateNetworkId` set),
	// you can still set it now. In this case it will not destroy and recreate your cluster but migrate it to the Private Network.
	PrivateNetworkId pulumi.StringPtrOutput `pulumi:"privateNetworkId"`
	// `projectId`) The ID of the project the cluster is associated with.
	ProjectId pulumi.StringOutput `pulumi:"projectId"`
	// `region`) The region in which the cluster should be created.
	Region pulumi.StringOutput `pulumi:"region"`
	// The status of the Kubernetes cluster.
	Status pulumi.StringOutput `pulumi:"status"`
	// The tags associated with the Kubernetes cluster.
	Tags pulumi.StringArrayOutput `pulumi:"tags"`
	// The type of Kubernetes cluster. Possible values are:
	//
	// - for mutualized clusters: `kapsule` or `multicloud`
	//
	// - for dedicated Kapsule clusters: `kapsule-dedicated-4`, `kapsule-dedicated-8` or `kapsule-dedicated-16`.
	//
	// - for dedicated Kosmos clusters: `multicloud-dedicated-4`, `multicloud-dedicated-8` or `multicloud-dedicated-16`.
	Type pulumi.StringOutput `pulumi:"type"`
	// The last update date of the cluster.
	UpdatedAt pulumi.StringOutput `pulumi:"updatedAt"`
	// Set to `true` if a newer Kubernetes version is available.
	UpgradeAvailable pulumi.BoolOutput `pulumi:"upgradeAvailable"`
	// The version of the Kubernetes cluster.
	Version pulumi.StringOutput `pulumi:"version"`
	// The DNS wildcard that points to all ready nodes.
	WildcardDns pulumi.StringOutput `pulumi:"wildcardDns"`
}

// NewCluster registers a new resource with the given unique name, arguments, and options.
func NewCluster(ctx *pulumi.Context,
	name string, args *ClusterArgs, opts ...pulumi.ResourceOption) (*Cluster, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Cni == nil {
		return nil, errors.New("invalid value for required argument 'Cni'")
	}
	if args.DeleteAdditionalResources == nil {
		return nil, errors.New("invalid value for required argument 'DeleteAdditionalResources'")
	}
	if args.Version == nil {
		return nil, errors.New("invalid value for required argument 'Version'")
	}
	aliases := pulumi.Aliases([]pulumi.Alias{
		{
			Type: pulumi.String("scaleway:index/kubernetesCluster:KubernetesCluster"),
		},
	})
	opts = append(opts, aliases)
	secrets := pulumi.AdditionalSecretOutputs([]string{
		"kubeconfigs",
	})
	opts = append(opts, secrets)
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Cluster
	err := ctx.RegisterResource("scaleway:kubernetes/cluster:Cluster", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetCluster gets an existing Cluster resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetCluster(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ClusterState, opts ...pulumi.ResourceOption) (*Cluster, error) {
	var resource Cluster
	err := ctx.ReadResource("scaleway:kubernetes/cluster:Cluster", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Cluster resources.
type clusterState struct {
	// The list of [admission plugins](https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/) to enable on the cluster.
	AdmissionPlugins []string `pulumi:"admissionPlugins"`
	// Additional Subject Alternative Names for the Kubernetes API server certificate
	ApiserverCertSans []string `pulumi:"apiserverCertSans"`
	// The URL of the Kubernetes API server.
	ApiserverUrl *string `pulumi:"apiserverUrl"`
	// The auto upgrade configuration.
	AutoUpgrade *ClusterAutoUpgrade `pulumi:"autoUpgrade"`
	// The configuration options for the [Kubernetes cluster autoscaler](https://github.com/kubernetes/autoscaler/tree/master/cluster-autoscaler).
	AutoscalerConfig *ClusterAutoscalerConfig `pulumi:"autoscalerConfig"`
	// The Container Network Interface (CNI) for the Kubernetes cluster.
	// > **Important:** Updates to this field will recreate a new resource.
	Cni *string `pulumi:"cni"`
	// The creation date of the cluster.
	CreatedAt *string `pulumi:"createdAt"`
	// Delete additional resources like block volumes, load-balancers and the cluster's private network (if empty) that were created in Kubernetes on cluster deletion.
	// > **Important:** Setting this field to `true` means that you will lose all your cluster data and network configuration when you delete your cluster.
	// If you prefer keeping it, you should instead set it as `false`.
	DeleteAdditionalResources *bool `pulumi:"deleteAdditionalResources"`
	// A description for the Kubernetes cluster.
	Description *string `pulumi:"description"`
	// The list of [feature gates](https://kubernetes.io/docs/reference/command-line-tools-reference/feature-gates/) to enable on the cluster.
	FeatureGates []string `pulumi:"featureGates"`
	// The kubeconfig configuration file of the Kubernetes cluster
	Kubeconfigs []ClusterKubeconfig `pulumi:"kubeconfigs"`
	// The name for the Kubernetes cluster.
	Name *string `pulumi:"name"`
	// The OpenID Connect configuration of the cluster
	OpenIdConnectConfig *ClusterOpenIdConnectConfig `pulumi:"openIdConnectConfig"`
	// The organization ID the cluster is associated with.
	OrganizationId *string `pulumi:"organizationId"`
	// The ID of the private network of the cluster.
	//
	// > **Important:** Changes to this field will recreate a new resource.
	//
	// > **Important:** Private Networks are now mandatory with Kapsule Clusters. If you have a legacy cluster (no `privateNetworkId` set),
	// you can still set it now. In this case it will not destroy and recreate your cluster but migrate it to the Private Network.
	PrivateNetworkId *string `pulumi:"privateNetworkId"`
	// `projectId`) The ID of the project the cluster is associated with.
	ProjectId *string `pulumi:"projectId"`
	// `region`) The region in which the cluster should be created.
	Region *string `pulumi:"region"`
	// The status of the Kubernetes cluster.
	Status *string `pulumi:"status"`
	// The tags associated with the Kubernetes cluster.
	Tags []string `pulumi:"tags"`
	// The type of Kubernetes cluster. Possible values are:
	//
	// - for mutualized clusters: `kapsule` or `multicloud`
	//
	// - for dedicated Kapsule clusters: `kapsule-dedicated-4`, `kapsule-dedicated-8` or `kapsule-dedicated-16`.
	//
	// - for dedicated Kosmos clusters: `multicloud-dedicated-4`, `multicloud-dedicated-8` or `multicloud-dedicated-16`.
	Type *string `pulumi:"type"`
	// The last update date of the cluster.
	UpdatedAt *string `pulumi:"updatedAt"`
	// Set to `true` if a newer Kubernetes version is available.
	UpgradeAvailable *bool `pulumi:"upgradeAvailable"`
	// The version of the Kubernetes cluster.
	Version *string `pulumi:"version"`
	// The DNS wildcard that points to all ready nodes.
	WildcardDns *string `pulumi:"wildcardDns"`
}

type ClusterState struct {
	// The list of [admission plugins](https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/) to enable on the cluster.
	AdmissionPlugins pulumi.StringArrayInput
	// Additional Subject Alternative Names for the Kubernetes API server certificate
	ApiserverCertSans pulumi.StringArrayInput
	// The URL of the Kubernetes API server.
	ApiserverUrl pulumi.StringPtrInput
	// The auto upgrade configuration.
	AutoUpgrade ClusterAutoUpgradePtrInput
	// The configuration options for the [Kubernetes cluster autoscaler](https://github.com/kubernetes/autoscaler/tree/master/cluster-autoscaler).
	AutoscalerConfig ClusterAutoscalerConfigPtrInput
	// The Container Network Interface (CNI) for the Kubernetes cluster.
	// > **Important:** Updates to this field will recreate a new resource.
	Cni pulumi.StringPtrInput
	// The creation date of the cluster.
	CreatedAt pulumi.StringPtrInput
	// Delete additional resources like block volumes, load-balancers and the cluster's private network (if empty) that were created in Kubernetes on cluster deletion.
	// > **Important:** Setting this field to `true` means that you will lose all your cluster data and network configuration when you delete your cluster.
	// If you prefer keeping it, you should instead set it as `false`.
	DeleteAdditionalResources pulumi.BoolPtrInput
	// A description for the Kubernetes cluster.
	Description pulumi.StringPtrInput
	// The list of [feature gates](https://kubernetes.io/docs/reference/command-line-tools-reference/feature-gates/) to enable on the cluster.
	FeatureGates pulumi.StringArrayInput
	// The kubeconfig configuration file of the Kubernetes cluster
	Kubeconfigs ClusterKubeconfigArrayInput
	// The name for the Kubernetes cluster.
	Name pulumi.StringPtrInput
	// The OpenID Connect configuration of the cluster
	OpenIdConnectConfig ClusterOpenIdConnectConfigPtrInput
	// The organization ID the cluster is associated with.
	OrganizationId pulumi.StringPtrInput
	// The ID of the private network of the cluster.
	//
	// > **Important:** Changes to this field will recreate a new resource.
	//
	// > **Important:** Private Networks are now mandatory with Kapsule Clusters. If you have a legacy cluster (no `privateNetworkId` set),
	// you can still set it now. In this case it will not destroy and recreate your cluster but migrate it to the Private Network.
	PrivateNetworkId pulumi.StringPtrInput
	// `projectId`) The ID of the project the cluster is associated with.
	ProjectId pulumi.StringPtrInput
	// `region`) The region in which the cluster should be created.
	Region pulumi.StringPtrInput
	// The status of the Kubernetes cluster.
	Status pulumi.StringPtrInput
	// The tags associated with the Kubernetes cluster.
	Tags pulumi.StringArrayInput
	// The type of Kubernetes cluster. Possible values are:
	//
	// - for mutualized clusters: `kapsule` or `multicloud`
	//
	// - for dedicated Kapsule clusters: `kapsule-dedicated-4`, `kapsule-dedicated-8` or `kapsule-dedicated-16`.
	//
	// - for dedicated Kosmos clusters: `multicloud-dedicated-4`, `multicloud-dedicated-8` or `multicloud-dedicated-16`.
	Type pulumi.StringPtrInput
	// The last update date of the cluster.
	UpdatedAt pulumi.StringPtrInput
	// Set to `true` if a newer Kubernetes version is available.
	UpgradeAvailable pulumi.BoolPtrInput
	// The version of the Kubernetes cluster.
	Version pulumi.StringPtrInput
	// The DNS wildcard that points to all ready nodes.
	WildcardDns pulumi.StringPtrInput
}

func (ClusterState) ElementType() reflect.Type {
	return reflect.TypeOf((*clusterState)(nil)).Elem()
}

type clusterArgs struct {
	// The list of [admission plugins](https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/) to enable on the cluster.
	AdmissionPlugins []string `pulumi:"admissionPlugins"`
	// Additional Subject Alternative Names for the Kubernetes API server certificate
	ApiserverCertSans []string `pulumi:"apiserverCertSans"`
	// The auto upgrade configuration.
	AutoUpgrade *ClusterAutoUpgrade `pulumi:"autoUpgrade"`
	// The configuration options for the [Kubernetes cluster autoscaler](https://github.com/kubernetes/autoscaler/tree/master/cluster-autoscaler).
	AutoscalerConfig *ClusterAutoscalerConfig `pulumi:"autoscalerConfig"`
	// The Container Network Interface (CNI) for the Kubernetes cluster.
	// > **Important:** Updates to this field will recreate a new resource.
	Cni string `pulumi:"cni"`
	// Delete additional resources like block volumes, load-balancers and the cluster's private network (if empty) that were created in Kubernetes on cluster deletion.
	// > **Important:** Setting this field to `true` means that you will lose all your cluster data and network configuration when you delete your cluster.
	// If you prefer keeping it, you should instead set it as `false`.
	DeleteAdditionalResources bool `pulumi:"deleteAdditionalResources"`
	// A description for the Kubernetes cluster.
	Description *string `pulumi:"description"`
	// The list of [feature gates](https://kubernetes.io/docs/reference/command-line-tools-reference/feature-gates/) to enable on the cluster.
	FeatureGates []string `pulumi:"featureGates"`
	// The name for the Kubernetes cluster.
	Name *string `pulumi:"name"`
	// The OpenID Connect configuration of the cluster
	OpenIdConnectConfig *ClusterOpenIdConnectConfig `pulumi:"openIdConnectConfig"`
	// The ID of the private network of the cluster.
	//
	// > **Important:** Changes to this field will recreate a new resource.
	//
	// > **Important:** Private Networks are now mandatory with Kapsule Clusters. If you have a legacy cluster (no `privateNetworkId` set),
	// you can still set it now. In this case it will not destroy and recreate your cluster but migrate it to the Private Network.
	PrivateNetworkId *string `pulumi:"privateNetworkId"`
	// `projectId`) The ID of the project the cluster is associated with.
	ProjectId *string `pulumi:"projectId"`
	// `region`) The region in which the cluster should be created.
	Region *string `pulumi:"region"`
	// The tags associated with the Kubernetes cluster.
	Tags []string `pulumi:"tags"`
	// The type of Kubernetes cluster. Possible values are:
	//
	// - for mutualized clusters: `kapsule` or `multicloud`
	//
	// - for dedicated Kapsule clusters: `kapsule-dedicated-4`, `kapsule-dedicated-8` or `kapsule-dedicated-16`.
	//
	// - for dedicated Kosmos clusters: `multicloud-dedicated-4`, `multicloud-dedicated-8` or `multicloud-dedicated-16`.
	Type *string `pulumi:"type"`
	// The version of the Kubernetes cluster.
	Version string `pulumi:"version"`
}

// The set of arguments for constructing a Cluster resource.
type ClusterArgs struct {
	// The list of [admission plugins](https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/) to enable on the cluster.
	AdmissionPlugins pulumi.StringArrayInput
	// Additional Subject Alternative Names for the Kubernetes API server certificate
	ApiserverCertSans pulumi.StringArrayInput
	// The auto upgrade configuration.
	AutoUpgrade ClusterAutoUpgradePtrInput
	// The configuration options for the [Kubernetes cluster autoscaler](https://github.com/kubernetes/autoscaler/tree/master/cluster-autoscaler).
	AutoscalerConfig ClusterAutoscalerConfigPtrInput
	// The Container Network Interface (CNI) for the Kubernetes cluster.
	// > **Important:** Updates to this field will recreate a new resource.
	Cni pulumi.StringInput
	// Delete additional resources like block volumes, load-balancers and the cluster's private network (if empty) that were created in Kubernetes on cluster deletion.
	// > **Important:** Setting this field to `true` means that you will lose all your cluster data and network configuration when you delete your cluster.
	// If you prefer keeping it, you should instead set it as `false`.
	DeleteAdditionalResources pulumi.BoolInput
	// A description for the Kubernetes cluster.
	Description pulumi.StringPtrInput
	// The list of [feature gates](https://kubernetes.io/docs/reference/command-line-tools-reference/feature-gates/) to enable on the cluster.
	FeatureGates pulumi.StringArrayInput
	// The name for the Kubernetes cluster.
	Name pulumi.StringPtrInput
	// The OpenID Connect configuration of the cluster
	OpenIdConnectConfig ClusterOpenIdConnectConfigPtrInput
	// The ID of the private network of the cluster.
	//
	// > **Important:** Changes to this field will recreate a new resource.
	//
	// > **Important:** Private Networks are now mandatory with Kapsule Clusters. If you have a legacy cluster (no `privateNetworkId` set),
	// you can still set it now. In this case it will not destroy and recreate your cluster but migrate it to the Private Network.
	PrivateNetworkId pulumi.StringPtrInput
	// `projectId`) The ID of the project the cluster is associated with.
	ProjectId pulumi.StringPtrInput
	// `region`) The region in which the cluster should be created.
	Region pulumi.StringPtrInput
	// The tags associated with the Kubernetes cluster.
	Tags pulumi.StringArrayInput
	// The type of Kubernetes cluster. Possible values are:
	//
	// - for mutualized clusters: `kapsule` or `multicloud`
	//
	// - for dedicated Kapsule clusters: `kapsule-dedicated-4`, `kapsule-dedicated-8` or `kapsule-dedicated-16`.
	//
	// - for dedicated Kosmos clusters: `multicloud-dedicated-4`, `multicloud-dedicated-8` or `multicloud-dedicated-16`.
	Type pulumi.StringPtrInput
	// The version of the Kubernetes cluster.
	Version pulumi.StringInput
}

func (ClusterArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*clusterArgs)(nil)).Elem()
}

type ClusterInput interface {
	pulumi.Input

	ToClusterOutput() ClusterOutput
	ToClusterOutputWithContext(ctx context.Context) ClusterOutput
}

func (*Cluster) ElementType() reflect.Type {
	return reflect.TypeOf((**Cluster)(nil)).Elem()
}

func (i *Cluster) ToClusterOutput() ClusterOutput {
	return i.ToClusterOutputWithContext(context.Background())
}

func (i *Cluster) ToClusterOutputWithContext(ctx context.Context) ClusterOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterOutput)
}

// ClusterArrayInput is an input type that accepts ClusterArray and ClusterArrayOutput values.
// You can construct a concrete instance of `ClusterArrayInput` via:
//
//	ClusterArray{ ClusterArgs{...} }
type ClusterArrayInput interface {
	pulumi.Input

	ToClusterArrayOutput() ClusterArrayOutput
	ToClusterArrayOutputWithContext(context.Context) ClusterArrayOutput
}

type ClusterArray []ClusterInput

func (ClusterArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Cluster)(nil)).Elem()
}

func (i ClusterArray) ToClusterArrayOutput() ClusterArrayOutput {
	return i.ToClusterArrayOutputWithContext(context.Background())
}

func (i ClusterArray) ToClusterArrayOutputWithContext(ctx context.Context) ClusterArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterArrayOutput)
}

// ClusterMapInput is an input type that accepts ClusterMap and ClusterMapOutput values.
// You can construct a concrete instance of `ClusterMapInput` via:
//
//	ClusterMap{ "key": ClusterArgs{...} }
type ClusterMapInput interface {
	pulumi.Input

	ToClusterMapOutput() ClusterMapOutput
	ToClusterMapOutputWithContext(context.Context) ClusterMapOutput
}

type ClusterMap map[string]ClusterInput

func (ClusterMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Cluster)(nil)).Elem()
}

func (i ClusterMap) ToClusterMapOutput() ClusterMapOutput {
	return i.ToClusterMapOutputWithContext(context.Background())
}

func (i ClusterMap) ToClusterMapOutputWithContext(ctx context.Context) ClusterMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterMapOutput)
}

type ClusterOutput struct{ *pulumi.OutputState }

func (ClusterOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Cluster)(nil)).Elem()
}

func (o ClusterOutput) ToClusterOutput() ClusterOutput {
	return o
}

func (o ClusterOutput) ToClusterOutputWithContext(ctx context.Context) ClusterOutput {
	return o
}

// The list of [admission plugins](https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/) to enable on the cluster.
func (o ClusterOutput) AdmissionPlugins() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Cluster) pulumi.StringArrayOutput { return v.AdmissionPlugins }).(pulumi.StringArrayOutput)
}

// Additional Subject Alternative Names for the Kubernetes API server certificate
func (o ClusterOutput) ApiserverCertSans() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Cluster) pulumi.StringArrayOutput { return v.ApiserverCertSans }).(pulumi.StringArrayOutput)
}

// The URL of the Kubernetes API server.
func (o ClusterOutput) ApiserverUrl() pulumi.StringOutput {
	return o.ApplyT(func(v *Cluster) pulumi.StringOutput { return v.ApiserverUrl }).(pulumi.StringOutput)
}

// The auto upgrade configuration.
func (o ClusterOutput) AutoUpgrade() ClusterAutoUpgradeOutput {
	return o.ApplyT(func(v *Cluster) ClusterAutoUpgradeOutput { return v.AutoUpgrade }).(ClusterAutoUpgradeOutput)
}

// The configuration options for the [Kubernetes cluster autoscaler](https://github.com/kubernetes/autoscaler/tree/master/cluster-autoscaler).
func (o ClusterOutput) AutoscalerConfig() ClusterAutoscalerConfigOutput {
	return o.ApplyT(func(v *Cluster) ClusterAutoscalerConfigOutput { return v.AutoscalerConfig }).(ClusterAutoscalerConfigOutput)
}

// The Container Network Interface (CNI) for the Kubernetes cluster.
// > **Important:** Updates to this field will recreate a new resource.
func (o ClusterOutput) Cni() pulumi.StringOutput {
	return o.ApplyT(func(v *Cluster) pulumi.StringOutput { return v.Cni }).(pulumi.StringOutput)
}

// The creation date of the cluster.
func (o ClusterOutput) CreatedAt() pulumi.StringOutput {
	return o.ApplyT(func(v *Cluster) pulumi.StringOutput { return v.CreatedAt }).(pulumi.StringOutput)
}

// Delete additional resources like block volumes, load-balancers and the cluster's private network (if empty) that were created in Kubernetes on cluster deletion.
// > **Important:** Setting this field to `true` means that you will lose all your cluster data and network configuration when you delete your cluster.
// If you prefer keeping it, you should instead set it as `false`.
func (o ClusterOutput) DeleteAdditionalResources() pulumi.BoolOutput {
	return o.ApplyT(func(v *Cluster) pulumi.BoolOutput { return v.DeleteAdditionalResources }).(pulumi.BoolOutput)
}

// A description for the Kubernetes cluster.
func (o ClusterOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Cluster) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// The list of [feature gates](https://kubernetes.io/docs/reference/command-line-tools-reference/feature-gates/) to enable on the cluster.
func (o ClusterOutput) FeatureGates() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Cluster) pulumi.StringArrayOutput { return v.FeatureGates }).(pulumi.StringArrayOutput)
}

// The kubeconfig configuration file of the Kubernetes cluster
func (o ClusterOutput) Kubeconfigs() ClusterKubeconfigArrayOutput {
	return o.ApplyT(func(v *Cluster) ClusterKubeconfigArrayOutput { return v.Kubeconfigs }).(ClusterKubeconfigArrayOutput)
}

// The name for the Kubernetes cluster.
func (o ClusterOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Cluster) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// The OpenID Connect configuration of the cluster
func (o ClusterOutput) OpenIdConnectConfig() ClusterOpenIdConnectConfigOutput {
	return o.ApplyT(func(v *Cluster) ClusterOpenIdConnectConfigOutput { return v.OpenIdConnectConfig }).(ClusterOpenIdConnectConfigOutput)
}

// The organization ID the cluster is associated with.
func (o ClusterOutput) OrganizationId() pulumi.StringOutput {
	return o.ApplyT(func(v *Cluster) pulumi.StringOutput { return v.OrganizationId }).(pulumi.StringOutput)
}

// The ID of the private network of the cluster.
//
// > **Important:** Changes to this field will recreate a new resource.
//
// > **Important:** Private Networks are now mandatory with Kapsule Clusters. If you have a legacy cluster (no `privateNetworkId` set),
// you can still set it now. In this case it will not destroy and recreate your cluster but migrate it to the Private Network.
func (o ClusterOutput) PrivateNetworkId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Cluster) pulumi.StringPtrOutput { return v.PrivateNetworkId }).(pulumi.StringPtrOutput)
}

// `projectId`) The ID of the project the cluster is associated with.
func (o ClusterOutput) ProjectId() pulumi.StringOutput {
	return o.ApplyT(func(v *Cluster) pulumi.StringOutput { return v.ProjectId }).(pulumi.StringOutput)
}

// `region`) The region in which the cluster should be created.
func (o ClusterOutput) Region() pulumi.StringOutput {
	return o.ApplyT(func(v *Cluster) pulumi.StringOutput { return v.Region }).(pulumi.StringOutput)
}

// The status of the Kubernetes cluster.
func (o ClusterOutput) Status() pulumi.StringOutput {
	return o.ApplyT(func(v *Cluster) pulumi.StringOutput { return v.Status }).(pulumi.StringOutput)
}

// The tags associated with the Kubernetes cluster.
func (o ClusterOutput) Tags() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Cluster) pulumi.StringArrayOutput { return v.Tags }).(pulumi.StringArrayOutput)
}

// The type of Kubernetes cluster. Possible values are:
//
// - for mutualized clusters: `kapsule` or `multicloud`
//
// - for dedicated Kapsule clusters: `kapsule-dedicated-4`, `kapsule-dedicated-8` or `kapsule-dedicated-16`.
//
// - for dedicated Kosmos clusters: `multicloud-dedicated-4`, `multicloud-dedicated-8` or `multicloud-dedicated-16`.
func (o ClusterOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v *Cluster) pulumi.StringOutput { return v.Type }).(pulumi.StringOutput)
}

// The last update date of the cluster.
func (o ClusterOutput) UpdatedAt() pulumi.StringOutput {
	return o.ApplyT(func(v *Cluster) pulumi.StringOutput { return v.UpdatedAt }).(pulumi.StringOutput)
}

// Set to `true` if a newer Kubernetes version is available.
func (o ClusterOutput) UpgradeAvailable() pulumi.BoolOutput {
	return o.ApplyT(func(v *Cluster) pulumi.BoolOutput { return v.UpgradeAvailable }).(pulumi.BoolOutput)
}

// The version of the Kubernetes cluster.
func (o ClusterOutput) Version() pulumi.StringOutput {
	return o.ApplyT(func(v *Cluster) pulumi.StringOutput { return v.Version }).(pulumi.StringOutput)
}

// The DNS wildcard that points to all ready nodes.
func (o ClusterOutput) WildcardDns() pulumi.StringOutput {
	return o.ApplyT(func(v *Cluster) pulumi.StringOutput { return v.WildcardDns }).(pulumi.StringOutput)
}

type ClusterArrayOutput struct{ *pulumi.OutputState }

func (ClusterArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Cluster)(nil)).Elem()
}

func (o ClusterArrayOutput) ToClusterArrayOutput() ClusterArrayOutput {
	return o
}

func (o ClusterArrayOutput) ToClusterArrayOutputWithContext(ctx context.Context) ClusterArrayOutput {
	return o
}

func (o ClusterArrayOutput) Index(i pulumi.IntInput) ClusterOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Cluster {
		return vs[0].([]*Cluster)[vs[1].(int)]
	}).(ClusterOutput)
}

type ClusterMapOutput struct{ *pulumi.OutputState }

func (ClusterMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Cluster)(nil)).Elem()
}

func (o ClusterMapOutput) ToClusterMapOutput() ClusterMapOutput {
	return o
}

func (o ClusterMapOutput) ToClusterMapOutputWithContext(ctx context.Context) ClusterMapOutput {
	return o
}

func (o ClusterMapOutput) MapIndex(k pulumi.StringInput) ClusterOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Cluster {
		return vs[0].(map[string]*Cluster)[vs[1].(string)]
	}).(ClusterOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterInput)(nil)).Elem(), &Cluster{})
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterArrayInput)(nil)).Elem(), ClusterArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterMapInput)(nil)).Elem(), ClusterMap{})
	pulumi.RegisterOutputType(ClusterOutput{})
	pulumi.RegisterOutputType(ClusterArrayOutput{})
	pulumi.RegisterOutputType(ClusterMapOutput{})
}
