// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package object

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumiverse/pulumi-scaleway/sdk/go/scaleway/internal"
)

// The `object.Item` resource allows you to create and manage objects for [Scaleway Object storage](https://www.scaleway.com/en/docs/object-storage/).
//
// Refer to the [dedicated documentation](https://www.scaleway.com/en/docs/object-storage/how-to/upload-files-into-a-bucket/) for more information on Object Storage objects.
//
// ## Import
//
// Objects can be imported using the `{region}/{bucketName}/{objectKey}` identifier, as shown below:
//
// bash
//
// ```sh
// $ pulumi import scaleway:object/item:Item some_object fr-par/some-bucket/some-file
// ```
//
// ~> **Important:** The `project_id` attribute has a particular behavior with s3 products because the s3 API is scoped by project.
//
// If you are using a project different from the default one, you have to specify the project ID at the end of the import command.
//
// bash
//
// ```sh
// $ pulumi import scaleway:object/item:Item some_object fr-par/some-bucket/some-file@xxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxx
// ```
type Item struct {
	pulumi.CustomResourceState

	// The bucket's name or regional ID.
	Bucket pulumi.StringOutput `pulumi:"bucket"`
	// The content of the file to upload. Only one of `file`, `content` or `contentBase64` can be defined.
	Content pulumi.StringPtrOutput `pulumi:"content"`
	// The base64-encoded content of the file to upload. Only one of `file`, `content` or `contentBase64` can be defined.
	//
	// > **Note:** Only one of `file`, `content` or `contentBase64` can be defined.
	ContentBase64 pulumi.StringPtrOutput `pulumi:"contentBase64"`
	// The standard MIME type of the object's content (e.g., 'application/json', 'text/plain'). This specifies how the object should be interpreted by clients. See RFC 9110: https://www.rfc-editor.org/rfc/rfc9110.html#name-content-type
	ContentType pulumi.StringOutput `pulumi:"contentType"`
	// The name of the file to upload, defaults to an empty file.
	File pulumi.StringPtrOutput `pulumi:"file"`
	// Hash of the file, used to trigger the upload on file change.
	Hash pulumi.StringPtrOutput `pulumi:"hash"`
	// The path to the object.
	Key pulumi.StringOutput `pulumi:"key"`
	// Map of metadata used for the object (keys must be lowercase).
	Metadata pulumi.StringMapOutput `pulumi:"metadata"`
	// The projectId you want to attach the resource to
	ProjectId pulumi.StringOutput `pulumi:"projectId"`
	// The Scaleway region the bucket resides in.
	Region pulumi.StringPtrOutput `pulumi:"region"`
	// Customer's encryption keys to encrypt data (SSE-C)
	SseCustomerKey pulumi.StringPtrOutput `pulumi:"sseCustomerKey"`
	// Specifies the Scaleway [storage class](https://www.scaleway.com/en/docs/object-storage/concepts/#storage-class) (`STANDARD`, `GLACIER`, or `ONEZONE_IA`) used to store the object.
	StorageClass pulumi.StringPtrOutput `pulumi:"storageClass"`
	// Map of tags.
	Tags pulumi.StringMapOutput `pulumi:"tags"`
	// Visibility of the object, `public-read` or `private`.
	Visibility pulumi.StringOutput `pulumi:"visibility"`
}

// NewItem registers a new resource with the given unique name, arguments, and options.
func NewItem(ctx *pulumi.Context,
	name string, args *ItemArgs, opts ...pulumi.ResourceOption) (*Item, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Bucket == nil {
		return nil, errors.New("invalid value for required argument 'Bucket'")
	}
	if args.Key == nil {
		return nil, errors.New("invalid value for required argument 'Key'")
	}
	aliases := pulumi.Aliases([]pulumi.Alias{
		{
			Type: pulumi.String("scaleway:index/objectItem:ObjectItem"),
		},
	})
	opts = append(opts, aliases)
	if args.SseCustomerKey != nil {
		args.SseCustomerKey = pulumi.ToSecret(args.SseCustomerKey).(pulumi.StringPtrInput)
	}
	secrets := pulumi.AdditionalSecretOutputs([]string{
		"sseCustomerKey",
	})
	opts = append(opts, secrets)
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Item
	err := ctx.RegisterResource("scaleway:object/item:Item", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetItem gets an existing Item resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetItem(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ItemState, opts ...pulumi.ResourceOption) (*Item, error) {
	var resource Item
	err := ctx.ReadResource("scaleway:object/item:Item", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Item resources.
type itemState struct {
	// The bucket's name or regional ID.
	Bucket *string `pulumi:"bucket"`
	// The content of the file to upload. Only one of `file`, `content` or `contentBase64` can be defined.
	Content *string `pulumi:"content"`
	// The base64-encoded content of the file to upload. Only one of `file`, `content` or `contentBase64` can be defined.
	//
	// > **Note:** Only one of `file`, `content` or `contentBase64` can be defined.
	ContentBase64 *string `pulumi:"contentBase64"`
	// The standard MIME type of the object's content (e.g., 'application/json', 'text/plain'). This specifies how the object should be interpreted by clients. See RFC 9110: https://www.rfc-editor.org/rfc/rfc9110.html#name-content-type
	ContentType *string `pulumi:"contentType"`
	// The name of the file to upload, defaults to an empty file.
	File *string `pulumi:"file"`
	// Hash of the file, used to trigger the upload on file change.
	Hash *string `pulumi:"hash"`
	// The path to the object.
	Key *string `pulumi:"key"`
	// Map of metadata used for the object (keys must be lowercase).
	Metadata map[string]string `pulumi:"metadata"`
	// The projectId you want to attach the resource to
	ProjectId *string `pulumi:"projectId"`
	// The Scaleway region the bucket resides in.
	Region *string `pulumi:"region"`
	// Customer's encryption keys to encrypt data (SSE-C)
	SseCustomerKey *string `pulumi:"sseCustomerKey"`
	// Specifies the Scaleway [storage class](https://www.scaleway.com/en/docs/object-storage/concepts/#storage-class) (`STANDARD`, `GLACIER`, or `ONEZONE_IA`) used to store the object.
	StorageClass *string `pulumi:"storageClass"`
	// Map of tags.
	Tags map[string]string `pulumi:"tags"`
	// Visibility of the object, `public-read` or `private`.
	Visibility *string `pulumi:"visibility"`
}

type ItemState struct {
	// The bucket's name or regional ID.
	Bucket pulumi.StringPtrInput
	// The content of the file to upload. Only one of `file`, `content` or `contentBase64` can be defined.
	Content pulumi.StringPtrInput
	// The base64-encoded content of the file to upload. Only one of `file`, `content` or `contentBase64` can be defined.
	//
	// > **Note:** Only one of `file`, `content` or `contentBase64` can be defined.
	ContentBase64 pulumi.StringPtrInput
	// The standard MIME type of the object's content (e.g., 'application/json', 'text/plain'). This specifies how the object should be interpreted by clients. See RFC 9110: https://www.rfc-editor.org/rfc/rfc9110.html#name-content-type
	ContentType pulumi.StringPtrInput
	// The name of the file to upload, defaults to an empty file.
	File pulumi.StringPtrInput
	// Hash of the file, used to trigger the upload on file change.
	Hash pulumi.StringPtrInput
	// The path to the object.
	Key pulumi.StringPtrInput
	// Map of metadata used for the object (keys must be lowercase).
	Metadata pulumi.StringMapInput
	// The projectId you want to attach the resource to
	ProjectId pulumi.StringPtrInput
	// The Scaleway region the bucket resides in.
	Region pulumi.StringPtrInput
	// Customer's encryption keys to encrypt data (SSE-C)
	SseCustomerKey pulumi.StringPtrInput
	// Specifies the Scaleway [storage class](https://www.scaleway.com/en/docs/object-storage/concepts/#storage-class) (`STANDARD`, `GLACIER`, or `ONEZONE_IA`) used to store the object.
	StorageClass pulumi.StringPtrInput
	// Map of tags.
	Tags pulumi.StringMapInput
	// Visibility of the object, `public-read` or `private`.
	Visibility pulumi.StringPtrInput
}

func (ItemState) ElementType() reflect.Type {
	return reflect.TypeOf((*itemState)(nil)).Elem()
}

type itemArgs struct {
	// The bucket's name or regional ID.
	Bucket string `pulumi:"bucket"`
	// The content of the file to upload. Only one of `file`, `content` or `contentBase64` can be defined.
	Content *string `pulumi:"content"`
	// The base64-encoded content of the file to upload. Only one of `file`, `content` or `contentBase64` can be defined.
	//
	// > **Note:** Only one of `file`, `content` or `contentBase64` can be defined.
	ContentBase64 *string `pulumi:"contentBase64"`
	// The standard MIME type of the object's content (e.g., 'application/json', 'text/plain'). This specifies how the object should be interpreted by clients. See RFC 9110: https://www.rfc-editor.org/rfc/rfc9110.html#name-content-type
	ContentType *string `pulumi:"contentType"`
	// The name of the file to upload, defaults to an empty file.
	File *string `pulumi:"file"`
	// Hash of the file, used to trigger the upload on file change.
	Hash *string `pulumi:"hash"`
	// The path to the object.
	Key string `pulumi:"key"`
	// Map of metadata used for the object (keys must be lowercase).
	Metadata map[string]string `pulumi:"metadata"`
	// The projectId you want to attach the resource to
	ProjectId *string `pulumi:"projectId"`
	// The Scaleway region the bucket resides in.
	Region *string `pulumi:"region"`
	// Customer's encryption keys to encrypt data (SSE-C)
	SseCustomerKey *string `pulumi:"sseCustomerKey"`
	// Specifies the Scaleway [storage class](https://www.scaleway.com/en/docs/object-storage/concepts/#storage-class) (`STANDARD`, `GLACIER`, or `ONEZONE_IA`) used to store the object.
	StorageClass *string `pulumi:"storageClass"`
	// Map of tags.
	Tags map[string]string `pulumi:"tags"`
	// Visibility of the object, `public-read` or `private`.
	Visibility *string `pulumi:"visibility"`
}

// The set of arguments for constructing a Item resource.
type ItemArgs struct {
	// The bucket's name or regional ID.
	Bucket pulumi.StringInput
	// The content of the file to upload. Only one of `file`, `content` or `contentBase64` can be defined.
	Content pulumi.StringPtrInput
	// The base64-encoded content of the file to upload. Only one of `file`, `content` or `contentBase64` can be defined.
	//
	// > **Note:** Only one of `file`, `content` or `contentBase64` can be defined.
	ContentBase64 pulumi.StringPtrInput
	// The standard MIME type of the object's content (e.g., 'application/json', 'text/plain'). This specifies how the object should be interpreted by clients. See RFC 9110: https://www.rfc-editor.org/rfc/rfc9110.html#name-content-type
	ContentType pulumi.StringPtrInput
	// The name of the file to upload, defaults to an empty file.
	File pulumi.StringPtrInput
	// Hash of the file, used to trigger the upload on file change.
	Hash pulumi.StringPtrInput
	// The path to the object.
	Key pulumi.StringInput
	// Map of metadata used for the object (keys must be lowercase).
	Metadata pulumi.StringMapInput
	// The projectId you want to attach the resource to
	ProjectId pulumi.StringPtrInput
	// The Scaleway region the bucket resides in.
	Region pulumi.StringPtrInput
	// Customer's encryption keys to encrypt data (SSE-C)
	SseCustomerKey pulumi.StringPtrInput
	// Specifies the Scaleway [storage class](https://www.scaleway.com/en/docs/object-storage/concepts/#storage-class) (`STANDARD`, `GLACIER`, or `ONEZONE_IA`) used to store the object.
	StorageClass pulumi.StringPtrInput
	// Map of tags.
	Tags pulumi.StringMapInput
	// Visibility of the object, `public-read` or `private`.
	Visibility pulumi.StringPtrInput
}

func (ItemArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*itemArgs)(nil)).Elem()
}

type ItemInput interface {
	pulumi.Input

	ToItemOutput() ItemOutput
	ToItemOutputWithContext(ctx context.Context) ItemOutput
}

func (*Item) ElementType() reflect.Type {
	return reflect.TypeOf((**Item)(nil)).Elem()
}

func (i *Item) ToItemOutput() ItemOutput {
	return i.ToItemOutputWithContext(context.Background())
}

func (i *Item) ToItemOutputWithContext(ctx context.Context) ItemOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ItemOutput)
}

// ItemArrayInput is an input type that accepts ItemArray and ItemArrayOutput values.
// You can construct a concrete instance of `ItemArrayInput` via:
//
//	ItemArray{ ItemArgs{...} }
type ItemArrayInput interface {
	pulumi.Input

	ToItemArrayOutput() ItemArrayOutput
	ToItemArrayOutputWithContext(context.Context) ItemArrayOutput
}

type ItemArray []ItemInput

func (ItemArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Item)(nil)).Elem()
}

func (i ItemArray) ToItemArrayOutput() ItemArrayOutput {
	return i.ToItemArrayOutputWithContext(context.Background())
}

func (i ItemArray) ToItemArrayOutputWithContext(ctx context.Context) ItemArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ItemArrayOutput)
}

// ItemMapInput is an input type that accepts ItemMap and ItemMapOutput values.
// You can construct a concrete instance of `ItemMapInput` via:
//
//	ItemMap{ "key": ItemArgs{...} }
type ItemMapInput interface {
	pulumi.Input

	ToItemMapOutput() ItemMapOutput
	ToItemMapOutputWithContext(context.Context) ItemMapOutput
}

type ItemMap map[string]ItemInput

func (ItemMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Item)(nil)).Elem()
}

func (i ItemMap) ToItemMapOutput() ItemMapOutput {
	return i.ToItemMapOutputWithContext(context.Background())
}

func (i ItemMap) ToItemMapOutputWithContext(ctx context.Context) ItemMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ItemMapOutput)
}

type ItemOutput struct{ *pulumi.OutputState }

func (ItemOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Item)(nil)).Elem()
}

func (o ItemOutput) ToItemOutput() ItemOutput {
	return o
}

func (o ItemOutput) ToItemOutputWithContext(ctx context.Context) ItemOutput {
	return o
}

// The bucket's name or regional ID.
func (o ItemOutput) Bucket() pulumi.StringOutput {
	return o.ApplyT(func(v *Item) pulumi.StringOutput { return v.Bucket }).(pulumi.StringOutput)
}

// The content of the file to upload. Only one of `file`, `content` or `contentBase64` can be defined.
func (o ItemOutput) Content() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Item) pulumi.StringPtrOutput { return v.Content }).(pulumi.StringPtrOutput)
}

// The base64-encoded content of the file to upload. Only one of `file`, `content` or `contentBase64` can be defined.
//
// > **Note:** Only one of `file`, `content` or `contentBase64` can be defined.
func (o ItemOutput) ContentBase64() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Item) pulumi.StringPtrOutput { return v.ContentBase64 }).(pulumi.StringPtrOutput)
}

// The standard MIME type of the object's content (e.g., 'application/json', 'text/plain'). This specifies how the object should be interpreted by clients. See RFC 9110: https://www.rfc-editor.org/rfc/rfc9110.html#name-content-type
func (o ItemOutput) ContentType() pulumi.StringOutput {
	return o.ApplyT(func(v *Item) pulumi.StringOutput { return v.ContentType }).(pulumi.StringOutput)
}

// The name of the file to upload, defaults to an empty file.
func (o ItemOutput) File() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Item) pulumi.StringPtrOutput { return v.File }).(pulumi.StringPtrOutput)
}

// Hash of the file, used to trigger the upload on file change.
func (o ItemOutput) Hash() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Item) pulumi.StringPtrOutput { return v.Hash }).(pulumi.StringPtrOutput)
}

// The path to the object.
func (o ItemOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v *Item) pulumi.StringOutput { return v.Key }).(pulumi.StringOutput)
}

// Map of metadata used for the object (keys must be lowercase).
func (o ItemOutput) Metadata() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Item) pulumi.StringMapOutput { return v.Metadata }).(pulumi.StringMapOutput)
}

// The projectId you want to attach the resource to
func (o ItemOutput) ProjectId() pulumi.StringOutput {
	return o.ApplyT(func(v *Item) pulumi.StringOutput { return v.ProjectId }).(pulumi.StringOutput)
}

// The Scaleway region the bucket resides in.
func (o ItemOutput) Region() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Item) pulumi.StringPtrOutput { return v.Region }).(pulumi.StringPtrOutput)
}

// Customer's encryption keys to encrypt data (SSE-C)
func (o ItemOutput) SseCustomerKey() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Item) pulumi.StringPtrOutput { return v.SseCustomerKey }).(pulumi.StringPtrOutput)
}

// Specifies the Scaleway [storage class](https://www.scaleway.com/en/docs/object-storage/concepts/#storage-class) (`STANDARD`, `GLACIER`, or `ONEZONE_IA`) used to store the object.
func (o ItemOutput) StorageClass() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Item) pulumi.StringPtrOutput { return v.StorageClass }).(pulumi.StringPtrOutput)
}

// Map of tags.
func (o ItemOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Item) pulumi.StringMapOutput { return v.Tags }).(pulumi.StringMapOutput)
}

// Visibility of the object, `public-read` or `private`.
func (o ItemOutput) Visibility() pulumi.StringOutput {
	return o.ApplyT(func(v *Item) pulumi.StringOutput { return v.Visibility }).(pulumi.StringOutput)
}

type ItemArrayOutput struct{ *pulumi.OutputState }

func (ItemArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Item)(nil)).Elem()
}

func (o ItemArrayOutput) ToItemArrayOutput() ItemArrayOutput {
	return o
}

func (o ItemArrayOutput) ToItemArrayOutputWithContext(ctx context.Context) ItemArrayOutput {
	return o
}

func (o ItemArrayOutput) Index(i pulumi.IntInput) ItemOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Item {
		return vs[0].([]*Item)[vs[1].(int)]
	}).(ItemOutput)
}

type ItemMapOutput struct{ *pulumi.OutputState }

func (ItemMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Item)(nil)).Elem()
}

func (o ItemMapOutput) ToItemMapOutput() ItemMapOutput {
	return o
}

func (o ItemMapOutput) ToItemMapOutputWithContext(ctx context.Context) ItemMapOutput {
	return o
}

func (o ItemMapOutput) MapIndex(k pulumi.StringInput) ItemOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Item {
		return vs[0].(map[string]*Item)[vs[1].(string)]
	}).(ItemOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ItemInput)(nil)).Elem(), &Item{})
	pulumi.RegisterInputType(reflect.TypeOf((*ItemArrayInput)(nil)).Elem(), ItemArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ItemMapInput)(nil)).Elem(), ItemMap{})
	pulumi.RegisterOutputType(ItemOutput{})
	pulumi.RegisterOutputType(ItemArrayOutput{})
	pulumi.RegisterOutputType(ItemMapOutput{})
}
