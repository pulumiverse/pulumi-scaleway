// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.scaleway.outputs;

import com.pulumi.core.annotations.CustomType;
import java.lang.Boolean;
import java.lang.Double;
import java.lang.Integer;
import java.lang.String;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;

@CustomType
public final class KubernetesClusterAutoscalerConfig {
    /**
     * @return Detect similar node groups and balance the number of nodes between them.
     * 
     */
    private @Nullable Boolean balanceSimilarNodeGroups;
    /**
     * @return Disables the scale down feature of the autoscaler.
     * 
     */
    private @Nullable Boolean disableScaleDown;
    /**
     * @return Type of resource estimator to be used in scale up.
     * 
     */
    private @Nullable String estimator;
    /**
     * @return Type of node group expander to be used in scale up.
     * 
     */
    private @Nullable String expander;
    /**
     * @return Pods with priority below cutoff will be expendable. They can be killed without any consideration during scale down and they don&#39;t cause scale up. Pods with null priority (PodPriority disabled) are non expendable.
     * 
     */
    private @Nullable Integer expendablePodsPriorityCutoff;
    /**
     * @return Ignore DaemonSet pods when calculating resource utilization for scaling down.
     * 
     */
    private @Nullable Boolean ignoreDaemonsetsUtilization;
    /**
     * @return Maximum number of seconds the cluster autoscaler waits for pod termination when trying to scale down a node
     * 
     */
    private @Nullable Integer maxGracefulTerminationSec;
    /**
     * @return How long after scale up that scale down evaluation resumes.
     * 
     */
    private @Nullable String scaleDownDelayAfterAdd;
    /**
     * @return How long a node should be unneeded before it is eligible for scale down.
     * 
     */
    private @Nullable String scaleDownUnneededTime;
    /**
     * @return Node utilization level, defined as sum of requested resources divided by capacity, below which a node can be considered for scale down
     * 
     */
    private @Nullable Double scaleDownUtilizationThreshold;

    private KubernetesClusterAutoscalerConfig() {}
    /**
     * @return Detect similar node groups and balance the number of nodes between them.
     * 
     */
    public Optional<Boolean> balanceSimilarNodeGroups() {
        return Optional.ofNullable(this.balanceSimilarNodeGroups);
    }
    /**
     * @return Disables the scale down feature of the autoscaler.
     * 
     */
    public Optional<Boolean> disableScaleDown() {
        return Optional.ofNullable(this.disableScaleDown);
    }
    /**
     * @return Type of resource estimator to be used in scale up.
     * 
     */
    public Optional<String> estimator() {
        return Optional.ofNullable(this.estimator);
    }
    /**
     * @return Type of node group expander to be used in scale up.
     * 
     */
    public Optional<String> expander() {
        return Optional.ofNullable(this.expander);
    }
    /**
     * @return Pods with priority below cutoff will be expendable. They can be killed without any consideration during scale down and they don&#39;t cause scale up. Pods with null priority (PodPriority disabled) are non expendable.
     * 
     */
    public Optional<Integer> expendablePodsPriorityCutoff() {
        return Optional.ofNullable(this.expendablePodsPriorityCutoff);
    }
    /**
     * @return Ignore DaemonSet pods when calculating resource utilization for scaling down.
     * 
     */
    public Optional<Boolean> ignoreDaemonsetsUtilization() {
        return Optional.ofNullable(this.ignoreDaemonsetsUtilization);
    }
    /**
     * @return Maximum number of seconds the cluster autoscaler waits for pod termination when trying to scale down a node
     * 
     */
    public Optional<Integer> maxGracefulTerminationSec() {
        return Optional.ofNullable(this.maxGracefulTerminationSec);
    }
    /**
     * @return How long after scale up that scale down evaluation resumes.
     * 
     */
    public Optional<String> scaleDownDelayAfterAdd() {
        return Optional.ofNullable(this.scaleDownDelayAfterAdd);
    }
    /**
     * @return How long a node should be unneeded before it is eligible for scale down.
     * 
     */
    public Optional<String> scaleDownUnneededTime() {
        return Optional.ofNullable(this.scaleDownUnneededTime);
    }
    /**
     * @return Node utilization level, defined as sum of requested resources divided by capacity, below which a node can be considered for scale down
     * 
     */
    public Optional<Double> scaleDownUtilizationThreshold() {
        return Optional.ofNullable(this.scaleDownUtilizationThreshold);
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(KubernetesClusterAutoscalerConfig defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private @Nullable Boolean balanceSimilarNodeGroups;
        private @Nullable Boolean disableScaleDown;
        private @Nullable String estimator;
        private @Nullable String expander;
        private @Nullable Integer expendablePodsPriorityCutoff;
        private @Nullable Boolean ignoreDaemonsetsUtilization;
        private @Nullable Integer maxGracefulTerminationSec;
        private @Nullable String scaleDownDelayAfterAdd;
        private @Nullable String scaleDownUnneededTime;
        private @Nullable Double scaleDownUtilizationThreshold;
        public Builder() {}
        public Builder(KubernetesClusterAutoscalerConfig defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.balanceSimilarNodeGroups = defaults.balanceSimilarNodeGroups;
    	      this.disableScaleDown = defaults.disableScaleDown;
    	      this.estimator = defaults.estimator;
    	      this.expander = defaults.expander;
    	      this.expendablePodsPriorityCutoff = defaults.expendablePodsPriorityCutoff;
    	      this.ignoreDaemonsetsUtilization = defaults.ignoreDaemonsetsUtilization;
    	      this.maxGracefulTerminationSec = defaults.maxGracefulTerminationSec;
    	      this.scaleDownDelayAfterAdd = defaults.scaleDownDelayAfterAdd;
    	      this.scaleDownUnneededTime = defaults.scaleDownUnneededTime;
    	      this.scaleDownUtilizationThreshold = defaults.scaleDownUtilizationThreshold;
        }

        @CustomType.Setter
        public Builder balanceSimilarNodeGroups(@Nullable Boolean balanceSimilarNodeGroups) {
            this.balanceSimilarNodeGroups = balanceSimilarNodeGroups;
            return this;
        }
        @CustomType.Setter
        public Builder disableScaleDown(@Nullable Boolean disableScaleDown) {
            this.disableScaleDown = disableScaleDown;
            return this;
        }
        @CustomType.Setter
        public Builder estimator(@Nullable String estimator) {
            this.estimator = estimator;
            return this;
        }
        @CustomType.Setter
        public Builder expander(@Nullable String expander) {
            this.expander = expander;
            return this;
        }
        @CustomType.Setter
        public Builder expendablePodsPriorityCutoff(@Nullable Integer expendablePodsPriorityCutoff) {
            this.expendablePodsPriorityCutoff = expendablePodsPriorityCutoff;
            return this;
        }
        @CustomType.Setter
        public Builder ignoreDaemonsetsUtilization(@Nullable Boolean ignoreDaemonsetsUtilization) {
            this.ignoreDaemonsetsUtilization = ignoreDaemonsetsUtilization;
            return this;
        }
        @CustomType.Setter
        public Builder maxGracefulTerminationSec(@Nullable Integer maxGracefulTerminationSec) {
            this.maxGracefulTerminationSec = maxGracefulTerminationSec;
            return this;
        }
        @CustomType.Setter
        public Builder scaleDownDelayAfterAdd(@Nullable String scaleDownDelayAfterAdd) {
            this.scaleDownDelayAfterAdd = scaleDownDelayAfterAdd;
            return this;
        }
        @CustomType.Setter
        public Builder scaleDownUnneededTime(@Nullable String scaleDownUnneededTime) {
            this.scaleDownUnneededTime = scaleDownUnneededTime;
            return this;
        }
        @CustomType.Setter
        public Builder scaleDownUtilizationThreshold(@Nullable Double scaleDownUtilizationThreshold) {
            this.scaleDownUtilizationThreshold = scaleDownUtilizationThreshold;
            return this;
        }
        public KubernetesClusterAutoscalerConfig build() {
            final var o = new KubernetesClusterAutoscalerConfig();
            o.balanceSimilarNodeGroups = balanceSimilarNodeGroups;
            o.disableScaleDown = disableScaleDown;
            o.estimator = estimator;
            o.expander = expander;
            o.expendablePodsPriorityCutoff = expendablePodsPriorityCutoff;
            o.ignoreDaemonsetsUtilization = ignoreDaemonsetsUtilization;
            o.maxGracefulTerminationSec = maxGracefulTerminationSec;
            o.scaleDownDelayAfterAdd = scaleDownDelayAfterAdd;
            o.scaleDownUnneededTime = scaleDownUnneededTime;
            o.scaleDownUtilizationThreshold = scaleDownUtilizationThreshold;
            return o;
        }
    }
}
