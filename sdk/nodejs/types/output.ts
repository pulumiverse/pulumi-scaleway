// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface BaremetalServerIp {
    /**
     * The address of the IPv6.
     */
    address: string;
    /**
     * The ID of the IPv6.
     */
    id: string;
    /**
     * The reverse of the IPv6.
     */
    reverse: string;
    /**
     * The type of the IPv6.
     */
    version: string;
}

export interface BaremetalServerIpv4 {
    /**
     * The address of the IPv6.
     */
    address: string;
    /**
     * The ID of the IPv6.
     */
    id: string;
    /**
     * The reverse of the IPv6.
     */
    reverse: string;
    /**
     * The type of the IPv6.
     */
    version: string;
}

export interface BaremetalServerIpv6 {
    /**
     * The address of the IPv6.
     */
    address: string;
    /**
     * The ID of the IPv6.
     */
    id: string;
    /**
     * The reverse of the IPv6.
     */
    reverse: string;
    /**
     * The type of the IPv6.
     */
    version: string;
}

export interface BaremetalServerOption {
    /**
     * The auto expiration date for compatible options
     */
    expiresAt: string;
    /**
     * The id of the option to enable. Use [this endpoint](https://developers.scaleway.com/en/products/baremetal/api/#get-012dcc) to find the available options IDs.
     */
    id: string;
    /**
     * The name of the server.
     */
    name: string;
}

export interface BaremetalServerPrivateNetwork {
    /**
     * The date and time of the creation of the private network.
     */
    createdAt: string;
    /**
     * The id of the private network to attach.
     */
    id: string;
    /**
     * The private network status.
     */
    status: string;
    /**
     * The date and time of the last update of the private network.
     */
    updatedAt: string;
    /**
     * The VLAN ID associated to the private network.
     */
    vlan: number;
}

export interface CockpitEndpoint {
    /**
     * The alertmanager URL.
     */
    alertmanagerUrl: string;
    /**
     * The grafana URL.
     */
    grafanaUrl: string;
    /**
     * The logs URL.
     */
    logsUrl: string;
    /**
     * The metrics URL.
     */
    metricsUrl: string;
    /**
     * The traces URL.
     */
    tracesUrl: string;
}

export interface CockpitPushUrl {
    /**
     * Push URL for logs (Grafana Loki)
     */
    pushLogsUrl: string;
    /**
     * Push URL for metrics (Grafana Mimir)
     */
    pushMetricsUrl: string;
}

export interface CockpitTokenScopes {
    /**
     * Query logs.
     */
    queryLogs?: boolean;
    /**
     * Query metrics.
     */
    queryMetrics?: boolean;
    /**
     * Query traces.
     */
    queryTraces?: boolean;
    /**
     * Setup alerts.
     */
    setupAlerts?: boolean;
    /**
     * Setup logs rules.
     */
    setupLogsRules?: boolean;
    /**
     * Setup metrics rules.
     */
    setupMetricsRules?: boolean;
    /**
     * Write logs.
     */
    writeLogs?: boolean;
    /**
     * Write metrics.
     */
    writeMetrics?: boolean;
    /**
     * Write traces.
     */
    writeTraces?: boolean;
}

export interface ContainerTriggerNats {
    /**
     * ID of the mnq nats account.
     */
    accountId?: string;
    /**
     * ID of the project that contain the mnq nats account, defaults to provider's project
     */
    projectId: string;
    /**
     * Region where the mnq nats account is, defaults to provider's region
     */
    region: string;
    /**
     * The subject to listen to
     */
    subject: string;
}

export interface ContainerTriggerSqs {
    /**
     * ID of the mnq namespace. Deprecated.
     */
    namespaceId?: string;
    /**
     * ID of the project where sqs is enabled, defaults to provider's project
     */
    projectId: string;
    /**
     * Name of the queue
     */
    queue: string;
    /**
     * Region where sqs is enabled, defaults to provider's region
     */
    region: string;
}

export interface DatabaseAclAclRule {
    /**
     * A text describing this rule. Default description: `IP allowed`
     */
    description: string;
    /**
     * The ip range to whitelist in [CIDR notation](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#CIDR_notation)
     */
    ip: string;
}

export interface DatabaseInstanceLoadBalancer {
    /**
     * The ID of the endpoint.
     */
    endpointId: string;
    /**
     * Hostname of the endpoint.
     */
    hostname: string;
    /**
     * IPv4 address on the network.
     */
    ip: string;
    /**
     * The name of the Database Instance.
     */
    name: string;
    /**
     * Port in the Private Network.
     */
    port: number;
}

export interface DatabaseInstancePrivateNetwork {
    /**
     * Whether or not the private network endpoint should be configured with IPAM
     */
    enableIpam: boolean;
    /**
     * The ID of the endpoint.
     */
    endpointId: string;
    /**
     * Hostname of the endpoint.
     */
    hostname: string;
    /**
     * IPv4 address on the network.
     */
    ip: string;
    /**
     * The IP with the given mask within the private subnet
     */
    ipNet: string;
    /**
     * The name of the Database Instance.
     */
    name: string;
    /**
     * The private network ID
     */
    pnId: string;
    /**
     * Port in the Private Network.
     */
    port: number;
    /**
     * The zone you want to attach the resource to
     */
    zone: string;
}

export interface DatabaseInstanceReadReplica {
    /**
     * IPv4 address on the network.
     */
    ip: string;
    /**
     * The name of the Database Instance.
     */
    name: string;
    /**
     * Port in the Private Network.
     */
    port: number;
}

export interface DatabaseReadReplicaDirectAccess {
    /**
     * The ID of the endpoint of the read replica.
     */
    endpointId: string;
    /**
     * Hostname of the endpoint. Only one of ip and hostname may be set.
     */
    hostname: string;
    /**
     * IPv4 address of the endpoint (IP address). Only one of ip and hostname may be set.
     */
    ip: string;
    /**
     * Name of the endpoint.
     */
    name: string;
    /**
     * TCP port of the endpoint.
     */
    port: number;
}

export interface DatabaseReadReplicaPrivateNetwork {
    /**
     * If true, the IP network address within the private subnet is determined by the IP Address Management (IPAM) service.
     */
    enableIpam: boolean;
    /**
     * The ID of the endpoint of the read replica.
     */
    endpointId: string;
    /**
     * Hostname of the endpoint. Only one of ip and hostname may be set.
     */
    hostname: string;
    /**
     * IPv4 address of the endpoint (IP address). Only one of ip and hostname may be set.
     */
    ip: string;
    /**
     * Name of the endpoint.
     */
    name: string;
    /**
     * TCP port of the endpoint.
     */
    port: number;
    /**
     * UUID of the private network to be connected to the read replica.
     */
    privateNetworkId: string;
    /**
     * The IP network address within the private subnet. This must be an IPv4 address with a CIDR notation. If not set, The IP network address within the private subnet is determined by the IP Address Management (IPAM) service.
     */
    serviceIp: string;
    /**
     * Private network zone
     */
    zone: string;
}

export interface DocumentdbReadReplicaDirectAccess {
    /**
     * The ID of the endpoint of the read replica.
     */
    endpointId: string;
    /**
     * Hostname of the endpoint. Only one of ip and hostname may be set.
     */
    hostname: string;
    /**
     * IPv4 address of the endpoint (IP address). Only one of ip and hostname may be set.
     */
    ip: string;
    /**
     * Name of the endpoint.
     */
    name: string;
    /**
     * TCP port of the endpoint.
     */
    port: number;
}

export interface DocumentdbReadReplicaPrivateNetwork {
    /**
     * The ID of the endpoint of the read replica.
     */
    endpointId: string;
    /**
     * Hostname of the endpoint. Only one of ip and hostname may be set.
     */
    hostname: string;
    /**
     * IPv4 address of the endpoint (IP address). Only one of ip and hostname may be set.
     */
    ip: string;
    /**
     * Name of the endpoint.
     */
    name: string;
    /**
     * TCP port of the endpoint.
     */
    port: number;
    /**
     * UUID of the private network to be connected to the read replica.
     */
    privateNetworkId: string;
    /**
     * The IP network address within the private subnet. This must be an IPv4 address with a
     * CIDR notation. The IP network address within the private subnet is determined by the IP Address Management (IPAM)
     * service if not set.
     */
    serviceIp: string;
    /**
     * Private network zone
     */
    zone: string;
}

export interface DomainRecordGeoIp {
    /**
     * The list of matches
     */
    matches: outputs.DomainRecordGeoIpMatch[];
}

export interface DomainRecordGeoIpMatch {
    /**
     * List of continents (eg: EU for Europe, NA for North America, AS for Asia...). List of all continents code: https://api.scaleway.com/domain-private/v2beta1/continents
     */
    continents?: string[];
    /**
     * List of countries (eg: FR for France, US for the United States, GB for Great Britain...). List of all countries code: https://api.scaleway.com/domain-private/v2beta1/countries
     */
    countries?: string[];
    /**
     * The content of the record (an IPv4 for an `A`, a string for a `TXT`...).
     */
    data: string;
}

export interface DomainRecordHttpService {
    /**
     * IPs to check
     */
    ips: string[];
    /**
     * Text to search
     */
    mustContain: string;
    /**
     * Strategy to return an IP from the IPs list
     */
    strategy: string;
    /**
     * URL to match the mustContain text to validate an IP
     */
    url: string;
    /**
     * User-agent used when checking the URL
     */
    userAgent?: string;
}

export interface DomainRecordView {
    /**
     * The content of the record (an IPv4 for an `A`, a string for a `TXT`...).
     */
    data: string;
    /**
     * The subnet of the view
     */
    subnet: string;
}

export interface DomainRecordWeighted {
    /**
     * The weighted IP
     */
    ip: string;
    /**
     * The weight of the IP
     */
    weight: number;
}

export interface FunctionTriggerNats {
    /**
     * ID of the mnq nats account.
     */
    accountId?: string;
    /**
     * ID of the project that contain the mnq nats account, defaults to provider's project
     */
    projectId: string;
    /**
     * Region where the mnq nats account is, defaults to provider's region
     */
    region: string;
    /**
     * The subject to listen to
     */
    subject: string;
}

export interface FunctionTriggerSqs {
    /**
     * ID of the mnq namespace. Deprecated.
     */
    namespaceId?: string;
    /**
     * ID of the project that contain the mnq namespace, defaults to provider's project
     */
    projectId: string;
    /**
     * Name of the queue
     */
    queue: string;
    /**
     * Region where the mnq namespace is, defaults to provider's region
     */
    region: string;
}

export interface GetBaremetalOfferCpu {
    /**
     * Number of core on this CPU.
     */
    coreCount: number;
    /**
     * Frequency of the memory in MHz.
     */
    frequency: number;
    /**
     * The offer name. Only one of `name` and `offerId` should be specified.
     */
    name: string;
    /**
     * Number of thread on this CPU.
     */
    threadCount: number;
}

export interface GetBaremetalOfferDisk {
    /**
     * Capacity of the memory in GB.
     */
    capacity: number;
    /**
     * Type of memory.
     */
    type: string;
}

export interface GetBaremetalOfferMemory {
    /**
     * Capacity of the memory in GB.
     */
    capacity: number;
    /**
     * Frequency of the memory in MHz.
     */
    frequency: number;
    /**
     * True if error-correcting code is available on this memory.
     */
    isEcc: boolean;
    /**
     * Type of memory.
     */
    type: string;
}

export interface GetBaremetalServerIp {
    /**
     * The IPv6 address
     */
    address: string;
    /**
     * The ID of the server.
     */
    id: string;
    /**
     * The Reverse of the IPv6
     */
    reverse: string;
    /**
     * The version of the IPv6
     */
    version: string;
}

export interface GetBaremetalServerIpv4 {
    /**
     * The IPv6 address
     */
    address: string;
    /**
     * The ID of the server.
     */
    id: string;
    /**
     * The Reverse of the IPv6
     */
    reverse: string;
    /**
     * The version of the IPv6
     */
    version: string;
}

export interface GetBaremetalServerIpv6 {
    /**
     * The IPv6 address
     */
    address: string;
    /**
     * The ID of the server.
     */
    id: string;
    /**
     * The Reverse of the IPv6
     */
    reverse: string;
    /**
     * The version of the IPv6
     */
    version: string;
}

export interface GetBaremetalServerOption {
    /**
     * Auto expire the option after this date
     */
    expiresAt: string;
    /**
     * The ID of the server.
     */
    id: string;
    /**
     * The server name. Only one of `name` and `serverId` should be specified.
     */
    name: string;
}

export interface GetBaremetalServerPrivateNetwork {
    /**
     * The date and time of the creation of the private network
     */
    createdAt: string;
    /**
     * The ID of the server.
     */
    id: string;
    /**
     * The private network status
     */
    status: string;
    /**
     * The date and time of the last update of the private network
     */
    updatedAt: string;
    /**
     * The VLAN ID associated to the private network
     */
    vlan: number;
}

export interface GetBillingConsumptionsConsumption {
    /**
     * Consumed quantity
     */
    billedQuantity: string;
    /**
     * Name of consumption category
     */
    categoryName: string;
    /**
     * The product name
     */
    productName: string;
    /**
     * Project ID of the consumption
     */
    projectId: string;
    /**
     * Unique identifier of the product
     */
    sku: string;
    /**
     * Unit of consumed quantity
     */
    unit: string;
    /**
     * Monetary value of the consumption
     */
    value: string;
}

export interface GetBillingInvoicesInvoice {
    /**
     * The billing period of the invoice in the YYYY-MM format.
     */
    billingPeriod: string;
    /**
     * The payment time limit, set according to the Organization's payment conditions (RFC 3339 format).
     */
    dueDate: string;
    /**
     * The associated invoice ID.
     */
    id: string;
    /**
     * Invoices with the given type are listed. Valid values are `periodic` and `purchase`.
     */
    invoiceType: string;
    /**
     * The date when the invoice was sent to the customer (RFC 3339 format).
     */
    issuedDate: string;
    /**
     * The invoice number.
     */
    number: number;
    /**
     * The organization name.
     */
    organizationName: string;
    /**
     * The name of the seller (Scaleway).
     */
    sellerName: string;
    /**
     * The start date of the billing period (RFC 3339 format).
     */
    startDate: string;
    /**
     * The state of the invoice.
     */
    state: string;
    /**
     * The end date of the billing period (RFC 3339 format).
     */
    stopDate: string;
    /**
     * The total discount amount of the invoice.
     */
    totalDiscount: string;
    /**
     * The total tax amount of the invoice.
     */
    totalTax: string;
    /**
     * The total amount, taxed.
     */
    totalTaxed: string;
    /**
     * The total amount of the invoice before applying the discount.
     */
    totalUndiscount: string;
    /**
     * The total amount, untaxed.
     */
    totalUntaxed: string;
}

export interface GetCockpitEndpoint {
    /**
     * The alertmanager URL
     */
    alertmanagerUrl: string;
    /**
     * The grafana URL
     */
    grafanaUrl: string;
    /**
     * The logs URL
     */
    logsUrl: string;
    /**
     * The metrics URL
     */
    metricsUrl: string;
    /**
     * The traces URL
     */
    tracesUrl: string;
}

export interface GetCockpitPushUrl {
    /**
     * Push URL for logs (Grafana Loki)
     */
    pushLogsUrl: string;
    /**
     * Push URL for metrics (Grafana Mimir)
     */
    pushMetricsUrl: string;
}

export interface GetDatabaseAclAclRule {
    /**
     * A simple text describing this rule
     */
    description: string;
    /**
     * The ip range to whitelist in [CIDR notation](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#CIDR_notation)
     */
    ip: string;
}

export interface GetDatabaseInstanceLoadBalancer {
    /**
     * The endpoint ID
     */
    endpointId: string;
    /**
     * The hostname of your endpoint
     */
    hostname: string;
    /**
     * The IP of your load balancer service
     */
    ip: string;
    /**
     * The name of the RDB instance.
     * Only one of `name` and `instanceId` should be specified.
     */
    name: string;
    /**
     * The port of your load balancer service
     */
    port: number;
}

export interface GetDatabaseInstancePrivateNetwork {
    /**
     * Whether or not the private network endpoint should be configured with IPAM
     */
    enableIpam: boolean;
    /**
     * The endpoint ID
     */
    endpointId: string;
    /**
     * The hostname of your endpoint
     */
    hostname: string;
    /**
     * The IP of your Instance within the private service
     */
    ip: string;
    /**
     * The IP with the given mask within the private subnet
     */
    ipNet: string;
    /**
     * The name of the RDB instance.
     * Only one of `name` and `instanceId` should be specified.
     */
    name: string;
    /**
     * The private network ID
     */
    pnId: string;
    /**
     * The port of your private service
     */
    port: number;
    /**
     * The zone you want to attach the resource to
     */
    zone: string;
}

export interface GetDatabaseInstanceReadReplica {
    /**
     * IP of the replica
     */
    ip: string;
    /**
     * The name of the RDB instance.
     * Only one of `name` and `instanceId` should be specified.
     */
    name: string;
    /**
     * Port of the replica
     */
    port: number;
}

export interface GetDomainRecordGeoIp {
    /**
     * The list of matches
     */
    matches: outputs.GetDomainRecordGeoIpMatch[];
}

export interface GetDomainRecordGeoIpMatch {
    /**
     * List of continents (eg: EU for Europe, NA for North America, AS for Asia...). List of all continents code: https://api.scaleway.com/domain-private/v2beta1/continents
     */
    continents: string[];
    /**
     * List of countries (eg: FR for France, US for the United States, GB for Great Britain...). List of all countries code: https://api.scaleway.com/domain-private/v2beta1/countries
     */
    countries: string[];
    /**
     * The content of the record (an IPv4 for an `A`, a string for a `TXT`...).
     * Cannot be used with `recordId`.
     */
    data: string;
}

export interface GetDomainRecordHttpService {
    /**
     * IPs to check
     */
    ips: string[];
    /**
     * Text to search
     */
    mustContain: string;
    /**
     * Strategy to return an IP from the IPs list
     */
    strategy: string;
    /**
     * URL to match the mustContain text to validate an IP
     */
    url: string;
    /**
     * User-agent used when checking the URL
     */
    userAgent: string;
}

export interface GetDomainRecordView {
    /**
     * The content of the record (an IPv4 for an `A`, a string for a `TXT`...).
     * Cannot be used with `recordId`.
     */
    data: string;
    /**
     * The subnet of the view
     */
    subnet: string;
}

export interface GetDomainRecordWeighted {
    /**
     * The weighted IP
     */
    ip: string;
    /**
     * The weight of the IP
     */
    weight: number;
}

export interface GetFlexibleIpsIp {
    /**
     * The date on which the flexible IP was created (RFC 3339 format).
     */
    createdAt: string;
    /**
     * The description of the flexible IP.
     */
    description: string;
    /**
     * The MAC address ID.
     */
    id: string;
    ipAddress: string;
    /**
     * The MAC address of the Virtual MAC.
     */
    macAddresses: outputs.GetFlexibleIpsIpMacAddress[];
    /**
     * (Defaults to provider `organizationId`) The ID of the organization the IP is in.
     */
    organizationId: string;
    /**
     * (Defaults to provider `projectId`) The ID of the project the IP is in.
     */
    projectId: string;
    /**
     * The reverse domain associated with this IP.
     */
    reverse: string;
    /**
     * The status of virtual MAC.
     */
    status: string;
    /**
     * List of tags used as filter. IPs with these exact tags are listed.
     */
    tags: string[];
    /**
     * The date on which the flexible IP was last updated (RFC 3339 format).
     */
    updatedAt: string;
    /**
     * `zone`) The zone in which IPs exist.
     */
    zone: string;
}

export interface GetFlexibleIpsIpMacAddress {
    /**
     * The date on which the flexible IP was created (RFC 3339 format).
     */
    createdAt: string;
    /**
     * The MAC address ID.
     */
    id: string;
    /**
     * The MAC address of the Virtual MAC.
     */
    macAddress: string;
    /**
     * The type of virtual MAC.
     */
    macType: string;
    /**
     * The status of virtual MAC.
     */
    status: string;
    /**
     * The date on which the flexible IP was last updated (RFC 3339 format).
     */
    updatedAt: string;
    /**
     * `zone`) The zone in which IPs exist.
     */
    zone: string;
}

export interface GetInstanceSecurityGroupInboundRule {
    /**
     * The action to take when rule match. Possible values are: `accept` or `drop`.
     */
    action: string;
    /**
     * The ip this rule apply to.
     */
    ip: string;
    /**
     * The ip range (e.g `192.168.1.0/24`) this rule apply to.
     */
    ipRange: string;
    /**
     * The port this rule apply to. If no port is specified, rule will apply to all port.
     */
    port: number;
    /**
     * Computed port range for this rule (e.g: 1-1024, 22-22)
     */
    portRange: string;
    /**
     * The protocol this rule apply to. Possible values are: `TCP`, `UDP`, `ICMP` or `ANY`.
     */
    protocol: string;
}

export interface GetInstanceSecurityGroupOutboundRule {
    /**
     * The action to take when rule match. Possible values are: `accept` or `drop`.
     */
    action: string;
    /**
     * The ip this rule apply to.
     */
    ip: string;
    /**
     * The ip range (e.g `192.168.1.0/24`) this rule apply to.
     */
    ipRange: string;
    /**
     * The port this rule apply to. If no port is specified, rule will apply to all port.
     */
    port: number;
    /**
     * Computed port range for this rule (e.g: 1-1024, 22-22)
     */
    portRange: string;
    /**
     * The protocol this rule apply to. Possible values are: `TCP`, `UDP`, `ICMP` or `ANY`.
     */
    protocol: string;
}

export interface GetInstanceServerPrivateNetwork {
    /**
     * MAC address of the NIC
     */
    macAddress: string;
    /**
     * The Private Network ID
     */
    pnId: string;
    /**
     * The private NIC state
     */
    status: string;
    /**
     * `zone`) The zone in which the server exists.
     */
    zone: string;
}

export interface GetInstanceServerPublicIp {
    /**
     * The address of the IP
     */
    address: string;
    /**
     * The ID of the IP
     */
    id: string;
}

export interface GetInstanceServerRootVolume {
    /**
     * Set the volume where the boot the server
     */
    boot: boolean;
    /**
     * Forces deletion of the root volume on instance termination.
     */
    deleteOnTermination: boolean;
    /**
     * The server name. Only one of `name` and `serverId` should be specified.
     */
    name: string;
    /**
     * Size of the root volume in gigabytes.
     */
    sizeInGb: number;
    /**
     * The volume ID of the root volume of the server.
     */
    volumeId: string;
    /**
     * Volume type of the root volume
     */
    volumeType: string;
}

export interface GetInstanceServersServer {
    /**
     * The boot Type of the server. Possible values are: `local`, `bootscript` or `rescue`.
     */
    bootType: string;
    /**
     * The ID of the bootscript.
     */
    bootscriptId: string;
    /**
     * If true a dynamic IP will be attached to the server.
     */
    enableDynamicIp: boolean;
    /**
     * Determines if IPv6 is enabled for the server.
     */
    enableIpv6: boolean;
    /**
     * The ID of the IP
     */
    id: string;
    /**
     * The UUID or the label of the base image used by the server.
     */
    image: string;
    /**
     * The default ipv6 address routed to the server. ( Only set when enableIpv6 is set to true )
     */
    ipv6Address: string;
    /**
     * The ipv6 gateway address. ( Only set when enableIpv6 is set to true )
     */
    ipv6Gateway: string;
    /**
     * The prefix length of the ipv6 subnet routed to the server. ( Only set when enableIpv6 is set to true )
     */
    ipv6PrefixLength: number;
    /**
     * The server name used as filter. Servers with a name like it are listed.
     */
    name: string;
    /**
     * The organization ID the server is associated with.
     */
    organizationId: string;
    /**
     * The [placement group](https://developers.scaleway.com/en/products/instance/api/#placement-groups-d8f653) the server is attached to.
     */
    placementGroupId: string;
    placementGroupPolicyRespected: boolean;
    /**
     * The Scaleway internal IP address of the server.
     */
    privateIp: string;
    /**
     * The ID of the project the server is associated with.
     */
    projectId: string;
    /**
     * The public IP address of the server.
     */
    publicIp: string;
    /**
     * The list of public IPs of the server
     */
    publicIps: outputs.GetInstanceServersServerPublicIp[];
    /**
     * True if the server support routed ip only.
     */
    routedIpEnabled: boolean;
    /**
     * The [security group](https://developers.scaleway.com/en/products/instance/api/#security-groups-8d7f89) the server is attached to.
     */
    securityGroupId: string;
    /**
     * The state of the server. Possible values are: `started`, `stopped` or `standby`.
     */
    state: string;
    /**
     * List of tags used as filter. Servers with these exact tags are listed.
     */
    tags: string[];
    /**
     * The commercial type of the server.
     */
    type: string;
    /**
     * `zone`) The zone in which servers exist.
     */
    zone: string;
}

export interface GetInstanceServersServerPublicIp {
    /**
     * The address of the IP
     */
    address: string;
    /**
     * The ID of the IP
     */
    id: string;
}

export interface GetInstanceSnapshotImport {
    /**
     * Bucket containing qcow
     */
    bucket: string;
    /**
     * Key of the qcow file in the specified bucket
     */
    key: string;
}

export interface GetIotDeviceCertificate {
    /**
     * X509 PEM encoded certificate of the device
     */
    crt: string;
    /**
     * X509 PEM encoded key of the device
     */
    key: string;
}

export interface GetIotDeviceMessageFilter {
    /**
     * Rule to restrict topics the device can publish to
     */
    publishes: outputs.GetIotDeviceMessageFilterPublish[];
    /**
     * Rule to restrict topics the device can subscribe to
     */
    subscribes: outputs.GetIotDeviceMessageFilterSubscribe[];
}

export interface GetIotDeviceMessageFilterPublish {
    /**
     * Publish message filter policy
     */
    policy: string;
    /**
     * List of topics in the set
     */
    topics: string[];
}

export interface GetIotDeviceMessageFilterSubscribe {
    /**
     * Subscribe message filter policy
     */
    policy: string;
    /**
     * List of topics in the set
     */
    topics: string[];
}

export interface GetIpamIpResource {
    /**
     * The ID of the resource that the IP is bound to.
     */
    id?: string;
    /**
     * The name of the resource to get the IP from.
     */
    name?: string;
    /**
     * The type of the resource to get the IP from. [Documentation](https://pkg.go.dev/github.com/scaleway/scaleway-sdk-go@master/api/ipam/v1#pkg-constants) with type list.
     */
    type: string;
}

export interface GetIpamIpsIp {
    /**
     * The Scaleway internal IP address of the server.
     */
    address: string;
    /**
     * The date and time of the creation of the IP.
     */
    createdAt: string;
    /**
     * The ID of the resource.
     */
    id: string;
    /**
     * The ID of the project used as filter.
     */
    projectId: string;
    /**
     * The region used as filter.
     */
    region: string;
    /**
     * Filter by resource ID, type or name.
     */
    resources: outputs.GetIpamIpsIpResource[];
    /**
     * The tags used as filter.
     */
    tags: string[];
    /**
     * The date and time of the last update of the IP.
     */
    updatedAt: string;
    /**
     * The zone in which the IP is.
     */
    zone: string;
}

export interface GetIpamIpsIpResource {
    /**
     * The ID of the resource that the IP is bound to.
     */
    id: string;
    /**
     * The Mac Address used as filter.
     */
    macAddress: string;
    /**
     * The name of the resource to get the IP from.
     */
    name: string;
    /**
     * The type of the resource to get the IP from. [Documentation](https://pkg.go.dev/github.com/scaleway/scaleway-sdk-go@master/api/ipam/v1#pkg-constants) with type list.
     */
    type: string;
}

export interface GetIpamIpsResource {
    /**
     * The ID of the resource that the IP is bound to.
     */
    id?: string;
    /**
     * The name of the resource to get the IP from.
     */
    name?: string;
    /**
     * The type of the resource to get the IP from. [Documentation](https://pkg.go.dev/github.com/scaleway/scaleway-sdk-go@master/api/ipam/v1#pkg-constants) with type list.
     */
    type: string;
}

export interface GetKubernetesClusterAutoUpgrade {
    /**
     * True if Kubernetes patch version auto upgrades is enabled.
     */
    enable: boolean;
    /**
     * The day of the auto upgrade maintenance window (`monday` to `sunday`, or `any`).
     */
    maintenanceWindowDay: string;
    /**
     * The start hour (UTC) of the 2-hour auto upgrade maintenance window (0 to 23).
     */
    maintenanceWindowStartHour: number;
}

export interface GetKubernetesClusterAutoscalerConfig {
    /**
     * True if detecting similar node groups and balance the number of nodes between them is enabled.
     */
    balanceSimilarNodeGroups: boolean;
    /**
     * True if the scale down feature of the autoscaler is disabled.
     */
    disableScaleDown: boolean;
    /**
     * The type of resource estimator used in scale up.
     */
    estimator: string;
    /**
     * The type of node group expander be used in scale up.
     */
    expander: string;
    /**
     * Pods with priority below cutoff will be expendable. They can be killed without any consideration during scale down and they don't cause scale up. Pods with null priority (PodPriority disabled) are non expendable.
     */
    expendablePodsPriorityCutoff: number;
    /**
     * True if ignoring DaemonSet pods when calculating resource utilization for scaling down is enabled.
     */
    ignoreDaemonsetsUtilization: boolean;
    /**
     * Maximum number of seconds the cluster autoscaler waits for pod termination when trying to scale down a node
     */
    maxGracefulTerminationSec: number;
    /**
     * The duration after scale up that scale down evaluation resumes.
     */
    scaleDownDelayAfterAdd: string;
    /**
     * The duration a node should be unneeded before it is eligible for scale down.
     */
    scaleDownUnneededTime: string;
    /**
     * Node utilization level, defined as sum of requested resources divided by capacity, below which a node can be considered for scale down
     */
    scaleDownUtilizationThreshold: number;
}

export interface GetKubernetesClusterKubeconfig {
    /**
     * The CA certificate of the Kubernetes API server.
     */
    clusterCaCertificate: string;
    /**
     * The raw kubeconfig file.
     */
    configFile: string;
    /**
     * The URL of the Kubernetes API server.
     */
    host: string;
    /**
     * The token to connect to the Kubernetes API server.
     */
    token: string;
}

export interface GetKubernetesClusterOpenIdConnectConfig {
    /**
     * A client id that all tokens must be issued for
     */
    clientId: string;
    /**
     * JWT claim to use as the user's group
     */
    groupsClaims: string[];
    /**
     * Prefix prepended to group claims
     */
    groupsPrefix: string;
    /**
     * URL of the provider which allows the API server to discover public signing keys
     */
    issuerUrl: string;
    /**
     * Multiple key=value pairs that describes a required claim in the ID Token
     */
    requiredClaims: string[];
    /**
     * JWT claim to use as the user name
     */
    usernameClaim: string;
    /**
     * Prefix prepended to username
     */
    usernamePrefix: string;
}

export interface GetKubernetesNodePoolNode {
    /**
     * The pool name. Only one of `name` and `poolId` should be specified. `clusterId` should be specified with `name`.
     */
    name: string;
    /**
     * The public IPv4.
     */
    publicIp: string;
    /**
     * The public IPv6.
     */
    publicIpV6: string;
    /**
     * The status of the node.
     */
    status: string;
}

export interface GetKubernetesNodePoolUpgradePolicy {
    /**
     * The maximum number of nodes to be created during the upgrade
     */
    maxSurge: number;
    /**
     * The maximum number of nodes that can be not ready at the same time
     */
    maxUnavailable: number;
}

export interface GetLbAclsAcl {
    /**
     * The action that has been undertaken when an ACL filter had matched.
     */
    actions: outputs.GetLbAclsAclAction[];
    /**
     * The date at which the ACL was created (RFC 3339 format).
     */
    createdAt: string;
    /**
     * The description of the ACL resource.
     */
    description: string;
    /**
     * The frontend ID this ACL is attached to. ACLs with a frontend ID like it are listed.
     * > **Important:** LB Frontends' IDs are zoned, which means they are of the form `{zone}/{id}`, e.g. `fr-par-1/11111111-1111-1111-1111-111111111111`
     */
    frontendId: string;
    /**
     * The associated ACL ID.
     * > **Important:** LB ACLs' IDs are zoned, which means they are of the form `{zone}/{id}`, e.g. `fr-par-1/11111111-1111-1111-1111-111111111111`
     */
    id: string;
    /**
     * The order between the ACLs.
     */
    index: number;
    /**
     * The ACL match rule.
     */
    matches: outputs.GetLbAclsAclMatch[];
    /**
     * The ACL name used as filter. ACLs with a name like it are listed.
     */
    name: string;
    /**
     * The date at which the ACL was last updated (RFC 3339 format).
     */
    updateAt: string;
}

export interface GetLbAclsAclAction {
    /**
     * Redirect parameters when using an ACL with `redirect` action.
     */
    redirects: outputs.GetLbAclsAclActionRedirect[];
    /**
     * The redirect type.
     */
    type: string;
}

export interface GetLbAclsAclActionRedirect {
    /**
     * The HTTP redirect code used.
     */
    code: number;
    /**
     * The URL used in case of a location redirect or the scheme name that replaces the request's original scheme.
     */
    target: string;
    /**
     * The redirect type.
     */
    type: string;
}

export interface GetLbAclsAclMatch {
    /**
     * The matched HTTP filter.
     */
    httpFilter: string;
    /**
     * A list of possible values for the HTTP filter based on the HTTP header.
     */
    httpFilterOption: string;
    /**
     * The possible values matched for a given HTTP filter.
     */
    httpFilterValues: string[];
    /**
     * The condition will be of type "unless" if invert is set to `true`
     */
    invert: boolean;
    /**
     * A list of matched IPs or CIDR v4/v6 addresses of the client of the session.
     */
    ipSubnets: string[];
}

export interface GetLbBackendHealthCheckHttp {
    /**
     * The expected HTTP status code
     */
    code: number;
    /**
     * The HTTP host header to use for HC requests
     */
    hostHeader: string;
    /**
     * The HTTP method to use for HC requests
     */
    method: string;
    /**
     * The SNI to use for HC requests over SSL
     */
    sni: string;
    /**
     * The HTTPS endpoint URL to call for HC requests
     */
    uri: string;
}

export interface GetLbBackendHealthCheckTcp {
}

export interface GetLbBackendsBackend {
    /**
     * The date at which the backend was created (RFC 3339 format).
     */
    createdAt: string;
    /**
     * Scaleway S3 bucket website to be served in case all backend servers are down.
     */
    failoverHost: string;
    /**
     * User sessions will be forwarded to this port of backend servers.
     */
    forwardPort: number;
    /**
     * Load balancing algorithm.
     */
    forwardPortAlgorithm: string;
    /**
     * Backend protocol.
     */
    forwardProtocol: string;
    /**
     * Interval between two HC requests.
     */
    healthCheckDelay: string;
    /**
     * This block enable HTTP health check.
     */
    healthCheckHttp: outputs.GetLbBackendsBackendHealthCheckHttp[];
    /**
     * This block enable HTTPS health check.
     */
    healthCheckHttps: outputs.GetLbBackendsBackendHealthCheckHttp[];
    /**
     * Number of allowed failed HC requests before the backend server is marked down.
     */
    healthCheckMaxRetries: number;
    /**
     * Port the HC requests will be sent to.
     */
    healthCheckPort: number;
    /**
     * This block enable TCP health check.
     */
    healthCheckTcps: outputs.GetLbBackendsBackendHealthCheckTcp[];
    /**
     * Timeout before we consider a HC request failed.
     */
    healthCheckTimeout: string;
    /**
     * The associated backend ID.
     */
    id: string;
    /**
     * Specifies whether the Load Balancer should check the backend server’s certificate before initiating a connection.
     */
    ignoreSslServerVerify: boolean;
    /**
     * The load-balancer ID this backend is attached to. backends with a LB ID like it are listed.
     */
    lbId: string;
    /**
     * The backend name used as filter. Backends with a name like it are listed.
     */
    name: string;
    /**
     * Modify what occurs when a backend server is marked down.
     */
    onMarkedDownAction: string;
    /**
     * The type of PROXY protocol.
     */
    proxyProtocol: string;
    /**
     * List of backend server IP addresses.
     */
    serverIps: string[];
    /**
     * Enables SSL between load balancer and backend servers.
     */
    sslBridging: boolean;
    /**
     * Enables cookie-based session persistence.
     */
    stickySessions: string;
    /**
     * Cookie name for sticky sessions.
     */
    stickySessionsCookieName: string;
    /**
     * Maximum initial server connection establishment time.
     */
    timeoutConnect: string;
    /**
     * Maximum server connection inactivity time.
     */
    timeoutServer: string;
    /**
     * Maximum tunnel inactivity time.
     */
    timeoutTunnel: string;
    /**
     * The date at which the backend was last updated (RFC 3339 format).
     */
    updateAt: string;
}

export interface GetLbBackendsBackendHealthCheckHttp {
    /**
     * The expected HTTP status code.
     */
    code: number;
    /**
     * The HTTP host header to use for HC requests.
     */
    hostHeader: string;
    /**
     * The HTTP method to use for HC requests.
     */
    method: string;
    /**
     * The SNI to use for HC requests over SSL.
     */
    sni: string;
    /**
     * The HTTPS endpoint URL to call for HC requests.
     */
    uri: string;
}

export interface GetLbBackendsBackendHealthCheckTcp {
}

export interface GetLbFrontendAcl {
    /**
     * Action to undertake when an ACL filter matches
     */
    actions: outputs.GetLbFrontendAclAction[];
    /**
     * Date and time of ACL's creation (RFC 3339 format)
     */
    createdAt: string;
    /**
     * Description of the ACL
     */
    description: string;
    /**
     * The ACL match rule
     */
    matches: outputs.GetLbFrontendAclMatch[];
    /**
     * The name of the frontend.
     * - When using the `name` you should specify the `lb-id`
     */
    name: string;
    /**
     * Date and time of ACL's update (RFC 3339 format)
     */
    updatedAt: string;
}

export interface GetLbFrontendAclAction {
    /**
     * Redirect parameters when using an ACL with `redirect` action
     */
    redirects: outputs.GetLbFrontendAclActionRedirect[];
    /**
     * The action type
     */
    type: string;
}

export interface GetLbFrontendAclActionRedirect {
    /**
     * The HTTP redirect code to use
     */
    code: number;
    /**
     * An URL can be used in case of a location redirect
     */
    target: string;
    /**
     * The redirect type
     */
    type: string;
}

export interface GetLbFrontendAclMatch {
    /**
     * The HTTP filter to match
     */
    httpFilter: string;
    /**
     * You can use this field with httpHeaderMatch acl type to set the header name to filter
     */
    httpFilterOption: string;
    /**
     * A list of possible values to match for the given HTTP filter
     */
    httpFilterValues: string[];
    /**
     * If set to true, the condition will be of type "unless"
     */
    invert: boolean;
    /**
     * A list of IPs or CIDR v4/v6 addresses of the client of the session to match
     */
    ipSubnets: string[];
}

export interface GetLbFrontendsFrontend {
    /**
     * The load-balancer backend ID this frontend is attached to.
     * > **Important:** LB backends' IDs are zoned, which means they are of the form `{zone}/{id}`, e.g. `fr-par-1/11111111-1111-1111-1111-111111111111`
     */
    backendId: string;
    /**
     * List of Certificate IDs that are used by the frontend.
     */
    certificateIds: string[];
    /**
     * The date at which the frontend was created (RFC 3339 format).
     */
    createdAt: string;
    /**
     * If HTTP/3 protocol is activated.
     */
    enableHttp3: boolean;
    /**
     * The associated frontend ID.
     * > **Important:** LB frontends' IDs are zoned, which means they are of the form `{zone}/{id}`, e.g. `fr-par-1/11111111-1111-1111-1111-111111111111`
     */
    id: string;
    /**
     * TCP port the frontend listen to.
     */
    inboundPort: number;
    /**
     * The load-balancer ID this frontend is attached to. frontends with a LB ID like it are listed.
     */
    lbId: string;
    /**
     * The frontend name used as filter. Frontends with a name like it are listed.
     */
    name: string;
    /**
     * Maximum inactivity time on the client side.
     */
    timeoutClient: string;
    /**
     * The date at which the frontend was last updated (RFC 3339 format).
     */
    updateAt: string;
}

export interface GetLbIpsIp {
    /**
     * The associated IP ID.
     */
    id: string;
    /**
     * The IP Address
     */
    ipAddress: string;
    /**
     * The associated load-balancer ID if any
     */
    lbId: string;
    /**
     * The organization ID the load-balancer is associated with.
     */
    organizationId: string;
    /**
     * The ID of the project the load-balancer is associated with.
     */
    projectId: string;
    /**
     * The reverse domain associated with this IP.
     */
    reverse: string;
    /**
     * `zone`) The zone in which IPs exist.
     */
    zone: string;
}

export interface GetLbRoutesRoute {
    /**
     * The backend ID destination of redirection
     */
    backendId: string;
    /**
     * The date at which the route was created (RFC 3339 format).
     */
    createdAt: string;
    /**
     * The frontend ID origin of redirection used as a filter. routes with a frontend ID like it are listed.
     */
    frontendId: string;
    /**
     * The associated route ID.
     */
    id: string;
    /**
     * Specifies the host of the server to which the request is being sent.
     */
    matchHostHeader: string;
    /**
     * Server Name Indication TLS extension field from an incoming connection made via an SSL/TLS transport layer.
     */
    matchSni: string;
    /**
     * The date at which the route was last updated (RFC 3339 format).
     */
    updateAt: string;
}

export interface GetLbsLb {
    /**
     * Number of backends the Load balancer has.
     */
    backendCount: number;
    /**
     * Date at which the Load balancer was created.
     */
    createdAt: string;
    /**
     * The description of the load-balancer.
     */
    description: string;
    /**
     * Number of frontends the Load balancer has.
     */
    frontendCount: number;
    /**
     * The ID of the load-balancer.
     */
    id: string;
    /**
     * List of underlying instances.
     */
    instances: outputs.GetLbsLbInstance[];
    /**
     * List of IPs attached to the Load balancer.
     */
    ips: outputs.GetLbsLbIp[];
    /**
     * The load balancer name used as a filter. LBs with a name like it are listed.
     */
    name: string;
    /**
     * The organization ID the load-balancer is associated with.
     */
    organizationId: string;
    /**
     * Number of private networks attached to the Load balancer.
     */
    privateNetworkCount: number;
    /**
     * The ID of the project the load-balancer is associated with.
     */
    projectId: string;
    /**
     * Number of routes the Load balancer has.
     */
    routeCount: number;
    /**
     * Determines the minimal SSL version which needs to be supported on client side.
     */
    sslCompatibilityLevel: string;
    /**
     * The state of the LB's instance. Possible values are: `unknown`, `ready`, `pending`, `stopped`, `error`, `locked` and `migrating`.
     */
    status: string;
    /**
     * The subscriber information.
     */
    subscriber: string;
    /**
     * The tags associated with the load-balancer.
     */
    tags: string[];
    /**
     * The offer type of the load-balancer.
     */
    type: string;
    /**
     * Date at which the Load balancer was updated.
     */
    updatedAt: string;
    /**
     * `zone`) The zone in which LBs exist.
     */
    zone: string;
}

export interface GetLbsLbInstance {
    /**
     * Date at which the Load balancer was created.
     */
    createdAt: string;
    /**
     * The ID of the load-balancer.
     */
    id: string;
    ipAddress: string;
    /**
     * The state of the LB's instance. Possible values are: `unknown`, `ready`, `pending`, `stopped`, `error`, `locked` and `migrating`.
     */
    status: string;
    /**
     * Date at which the Load balancer was updated.
     */
    updatedAt: string;
    /**
     * `zone`) The zone in which LBs exist.
     */
    zone: string;
}

export interface GetLbsLbIp {
    /**
     * The ID of the load-balancer.
     */
    id: string;
    ipAddress: string;
    lbId: string;
    /**
     * The organization ID the load-balancer is associated with.
     */
    organizationId: string;
    /**
     * The ID of the project the load-balancer is associated with.
     */
    projectId: string;
    reverse: string;
    /**
     * `zone`) The zone in which LBs exist.
     */
    zone: string;
}

export interface GetLoadbalancerCertificateCustomCertificate {
    /**
     * The full PEM-formatted certificate chain
     */
    certificateChain: string;
}

export interface GetLoadbalancerCertificateLetsencrypt {
    /**
     * The main domain name of the certificate
     */
    commonName: string;
    /**
     * The alternative domain names of the certificate
     */
    subjectAlternativeNames: string[];
}

export interface GetLoadbalancerPrivateNetwork {
    /**
     * Set to true if you want to let DHCP assign IP addresses
     */
    dhcpConfig: boolean;
    /**
     * The Private Network ID
     */
    privateNetworkId: string;
    /**
     * Define an IP address in the subnet of your private network that will be assigned to your load balancer instance
     */
    staticConfigs: string[];
    /**
     * The status of private network connection
     */
    status: string;
    /**
     * (Defaults to provider `zone`) The zone in which the LB exists.
     */
    zone: string;
}

export interface GetObjectBucketCorsRule {
    allowedHeaders: string[];
    allowedMethods: string[];
    allowedOrigins: string[];
    exposeHeaders: string[];
    maxAgeSeconds: number;
}

export interface GetObjectBucketLifecycleRule {
    /**
     * Specifies the number of days after initiating a multipart upload when the multipart upload must be completed
     */
    abortIncompleteMultipartUploadDays: number;
    /**
     * Specifies if the configuration rule is Enabled or Disabled
     */
    enabled: boolean;
    /**
     * Specifies a period in the object's expire
     */
    expirations: outputs.GetObjectBucketLifecycleRuleExpiration[];
    /**
     * The unique name of the bucket.
     */
    id: string;
    /**
     * The prefix identifying one or more objects to which the rule applies
     */
    prefix: string;
    /**
     * The tags associated with the bucket lifecycle
     */
    tags: {[key: string]: string};
    /**
     * Define when objects transition to another storage class
     */
    transitions: outputs.GetObjectBucketLifecycleRuleTransition[];
}

export interface GetObjectBucketLifecycleRuleExpiration {
    /**
     * Specifies the number of days after object creation when the specific rule action takes effect
     */
    days: number;
}

export interface GetObjectBucketLifecycleRuleTransition {
    /**
     * Specifies the number of days after object creation when the specific rule action takes effect
     */
    days: number;
    /**
     * Specifies the Scaleway Object Storage class to which you want the object to transition
     */
    storageClass: string;
}

export interface GetObjectBucketVersioning {
    /**
     * Enable versioning. Once you version-enable a bucket, it can never return to an unversioned state
     */
    enabled: boolean;
}

export interface GetRedisClusterAcl {
    /**
     * Description of the rule.
     */
    description: string;
    /**
     * The ID of the Redis cluster.
     */
    id: string;
    /**
     * IPv4 network address of the rule (IP network in a CIDR format).
     */
    ip: string;
}

export interface GetRedisClusterPrivateNetwork {
    /**
     * UUID of the endpoint to be connected to the cluster
     */
    endpointId: string;
    /**
     * The ID of the Redis cluster.
     */
    id: string;
    /**
     * List of IPv4 addresses of the private network with a CIDR notation
     */
    serviceIps: string[];
    /**
     * `region`) The zone in which the server exists.
     */
    zone: string;
}

export interface GetRedisClusterPublicNetwork {
    /**
     * The ID of the Redis cluster.
     */
    id: string;
    ips: string[];
    /**
     * TCP port of the endpoint
     */
    port: number;
}

export interface GetTemDomainReputation {
    /**
     * The previously-calculated domain's reputation score
     */
    previousScore: number;
    /**
     * Time and date the previous reputation score was calculated
     */
    previousScoredAt: string;
    /**
     * A range from 0 to 100 that determines your domain's reputation score
     */
    score: number;
    /**
     * Time and date the score was calculated
     */
    scoredAt: string;
    /**
     * Status of the domain's reputation
     */
    status: string;
}

export interface GetVpcGatewayNetworkIpamConfig {
    /**
     * Use this IPAM-booked IP ID as the Gateway's IP in this Private Network
     */
    ipamIpId: string;
    /**
     * Defines whether the default route is enabled on that Gateway Network
     */
    pushDefaultRoute: boolean;
}

export interface GetVpcPrivateNetworkIpv4Subnet {
    /**
     * The network address of the subnet in dotted decimal notation, e.g., '192.168.0.0' for a '192.168.0.0/24' subnet
     */
    address: string;
    /**
     * The date and time of the creation of the subnet
     */
    createdAt: string;
    /**
     * The ID of the private network.
     */
    id: string;
    /**
     * The length of the network prefix, e.g., 24 for a 255.255.255.0 mask
     */
    prefixLength: number;
    /**
     * The subnet CIDR
     */
    subnet: string;
    /**
     * The subnet mask expressed in dotted decimal notation, e.g., '255.255.255.0' for a /24 subnet
     */
    subnetMask: string;
    /**
     * The date and time of the last update of the subnet
     */
    updatedAt: string;
}

export interface GetVpcPrivateNetworkIpv6Subnet {
    /**
     * The network address of the subnet in dotted decimal notation, e.g., '192.168.0.0' for a '192.168.0.0/24' subnet
     */
    address: string;
    /**
     * The date and time of the creation of the subnet
     */
    createdAt: string;
    /**
     * The ID of the private network.
     */
    id: string;
    /**
     * The length of the network prefix, e.g., 24 for a 255.255.255.0 mask
     */
    prefixLength: number;
    /**
     * The subnet CIDR
     */
    subnet: string;
    /**
     * The subnet mask expressed in dotted decimal notation, e.g., '255.255.255.0' for a /24 subnet
     */
    subnetMask: string;
    /**
     * The date and time of the last update of the subnet
     */
    updatedAt: string;
}

export interface GetVpcsVpc {
    /**
     * Date and time of VPC's creation (RFC 3339 format).
     */
    createdAt: string;
    /**
     * The associated VPC ID.
     * > **Important:** VPCs' IDs are regional, which means they are of the form `{region}/{id}`, e.g. `fr-par/11111111-1111-1111-1111-111111111111
     */
    id: string;
    /**
     * Defines whether the VPC is the default one for its Project.
     */
    isDefault: boolean;
    /**
     * The VPC name used as filter. VPCs with a name like it are listed.
     */
    name: string;
    /**
     * The organization ID the VPC is associated with.
     */
    organizationId: string;
    /**
     * The ID of the project the VPC is associated with.
     */
    projectId: string;
    /**
     * `region`). The region in which vpcs exist.
     */
    region: string;
    /**
     * List of tags used as filter. VPCs with these exact tags are listed.
     */
    tags: string[];
    updateAt: string;
}

export interface GetWebHostOfferProduct {
    /**
     * The quota of databases.
     */
    databasesQuota: number;
    /**
     * The quota of email accounts.
     */
    emailAccountsQuota: number;
    /**
     * The quota of email storage.
     */
    emailStorageQuota: number;
    /**
     * The quota of hosting storage.
     */
    hostingStorageQuota: number;
    /**
     * The offer name. Only one of `name` and `offerId` should be specified.
     */
    name: string;
    /**
     * The product option.
     */
    option: boolean;
    /**
     * The capacity of the memory in GB.
     */
    ram: number;
    /**
     * If support is included.
     */
    supportIncluded: boolean;
    /**
     * The number of cores.
     */
    vCpu: number;
}

export interface GetWebhostingCpanelUrl {
    dashboard: string;
    webmail: string;
}

export interface GetWebhostingOption {
    id: string;
    name: string;
}

export interface IamPolicyRule {
    /**
     * ID of organization scoped to the rule, this can be used to create a rule for all projects in an organization.
     */
    organizationId?: string;
    /**
     * Names of permission sets bound to the rule.
     *
     * **_TIP:_**  You can use the Scaleway CLI to list the permissions details. e.g:
     *
     * ```shell
     * $ scw iam permission-set list
     * ```
     */
    permissionSetNames: string[];
    /**
     * List of project IDs scoped to the rule.
     *
     * > **Important** One of `organizationId` or `projectIds`  must be set per rule.
     */
    projectIds?: string[];
}

export interface InstanceImageAdditionalVolume {
    /**
     * Date of the volume creation.
     */
    creationDate: string;
    /**
     * The export URI of the volume.
     */
    exportUri: string;
    /**
     * ID of the server containing the volume.
     */
    id: string;
    /**
     * Date of volume latest update.
     */
    modificationDate: string;
    /**
     * The name of the image. If not provided it will be randomly generated.
     */
    name: string;
    /**
     * The organization ID the volume is associated with.
     */
    organization: string;
    /**
     * ID of the project the volume is associated with
     */
    project: string;
    /**
     * Description of the server containing the volume (in case the image is a backup from a server).
     */
    server: {[key: string]: string};
    /**
     * The size of the volume.
     */
    size: number;
    /**
     * State of the volume.
     */
    state: string;
    /**
     * A list of tags to apply to the image.
     */
    tags: string[];
    /**
     * The type of volume, possible values are `lSsd` and `bSsd`.
     */
    volumeType: string;
    /**
     * The zone in which the image should be created.
     */
    zone: string;
}

export interface InstanceSecurityGroupInboundRule {
    /**
     * The action to take when rule match. Possible values are: `accept` or `drop`.
     */
    action: string;
    /**
     * The ip this rule apply to. If no `ip` nor `ipRange` are specified, rule will apply to all ip. Only one of `ip` and `ipRange` should be specified.
     *
     * @deprecated Ip address is deprecated. Please use ipRange instead
     */
    ip?: string;
    /**
     * The ip range (e.g `192.168.1.0/24`) this rule applies to. If no `ip` nor `ipRange` are specified, rule will apply to all ip. Only one of `ip` and `ipRange` should be specified.
     */
    ipRange?: string;
    /**
     * The port this rule applies to. If no `port` nor `portRange` are specified, the rule will apply to all port. Only one of `port` and `portRange` should be specified.
     */
    port?: number;
    /**
     * Computed port range for this rule (e.g: 1-1024, 22-22)
     */
    portRange?: string;
    /**
     * The protocol this rule apply to. Possible values are: `TCP`, `UDP`, `ICMP` or `ANY`.
     */
    protocol?: string;
}

export interface InstanceSecurityGroupOutboundRule {
    /**
     * Action when rule match request (drop or accept)
     */
    action: string;
    /**
     * Ip address for this rule (e.g: 1.1.1.1). Only one of ip or ipRange should be provided
     *
     * @deprecated Ip address is deprecated. Please use ipRange instead
     */
    ip?: string;
    /**
     * Ip range for this rule (e.g: 192.168.1.0/24). Only one of ip or ipRange should be provided
     */
    ipRange?: string;
    /**
     * Network port for this rule
     */
    port?: number;
    /**
     * Computed port range for this rule (e.g: 1-1024, 22-22)
     */
    portRange?: string;
    /**
     * Protocol for this rule (TCP, UDP, ICMP or ANY)
     */
    protocol?: string;
}

export interface InstanceSecurityGroupRulesInboundRule {
    /**
     * The action to take when rule match. Possible values are: `accept` or `drop`.
     */
    action: string;
    /**
     * The ip this rule apply to. If no `ip` nor `ipRange` are specified, rule will apply to all ip. Only one of `ip` and `ipRange` should be specified.
     *
     * @deprecated Ip address is deprecated. Please use ipRange instead
     */
    ip?: string;
    /**
     * The ip range (e.g `192.168.1.0/24`) this rule applies to. If no `ip` nor `ipRange` are specified, rule will apply to all ip. Only one of `ip` and `ipRange` should be specified.
     */
    ipRange?: string;
    /**
     * The port this rule apply to. If no port is specified, rule will apply to all port.
     */
    port?: number;
    /**
     * Computed port range for this rule (e.g: 1-1024, 22-22)
     */
    portRange?: string;
    /**
     * The protocol this rule apply to. Possible values are: `TCP`, `UDP`, `ICMP` or `ANY`.
     */
    protocol?: string;
}

export interface InstanceSecurityGroupRulesOutboundRule {
    /**
     * Action when rule match request (drop or accept)
     */
    action: string;
    /**
     * Ip address for this rule (e.g: 1.1.1.1). Only one of ip or ipRange should be provided
     *
     * @deprecated Ip address is deprecated. Please use ipRange instead
     */
    ip?: string;
    /**
     * Ip range for this rule (e.g: 192.168.1.0/24). Only one of ip or ipRange should be provided
     */
    ipRange?: string;
    /**
     * Network port for this rule
     */
    port?: number;
    /**
     * Computed port range for this rule (e.g: 1-1024, 22-22)
     */
    portRange?: string;
    /**
     * Protocol for this rule (TCP, UDP, ICMP or ANY)
     */
    protocol?: string;
}

export interface InstanceServerPrivateNetwork {
    /**
     * MAC address of the NIC
     */
    macAddress: string;
    /**
     * The Private Network ID
     */
    pnId: string;
    /**
     * The private NIC state
     */
    status: string;
    /**
     * `zone`) The zone in which the server should be created.
     */
    zone: string;
}

export interface InstanceServerPublicIp {
    /**
     * The address of the IP
     */
    address: string;
    /**
     * The ID of the IP
     */
    id: string;
}

export interface InstanceServerRootVolume {
    /**
     * Set the volume where the boot the server
     */
    boot?: boolean;
    /**
     * Forces deletion of the root volume on instance termination.
     *
     * > **Important:** Updates to `root_volume.size_in_gb` will be ignored after the creation of the server.
     */
    deleteOnTermination?: boolean;
    /**
     * The name of the server.
     */
    name: string;
    /**
     * Size of the root volume in gigabytes.
     * To find the right size use [this endpoint](https://api.scaleway.com/instance/v1/zones/fr-par-1/products/servers) and
     * check the `volumes_constraint.{min|max}_size` (in bytes) for your `commercialType`.
     * Updates to this field will recreate a new resource.
     */
    sizeInGb: number;
    /**
     * The volume ID of the root volume of the server, allows you to create server with an existing volume. If empty, will be computed to a created volume ID.
     */
    volumeId: string;
    /**
     * Volume type of root volume, can be `bSsd` or `lSsd`, default value depends on server type
     */
    volumeType: string;
}

export interface InstanceSnapshotImport {
    /**
     * Bucket name containing [qcow2](https://en.wikipedia.org/wiki/Qcow) to import
     */
    bucket: string;
    /**
     * Key of the object to import
     *
     * > **Note:** The type `unified` could be instantiated on both `lSsd` and `bSsd` volumes.
     */
    key: string;
}

export interface IotDeviceCertificate {
    /**
     * X509 PEM encoded certificate of the device
     */
    crt: string;
    /**
     * The private key of the device, in case it is generated by Scaleway.
     */
    key: string;
}

export interface IotDeviceMessageFilters {
    /**
     * Rules used to restrict topics the device can publish to.
     */
    publish?: outputs.IotDeviceMessageFiltersPublish;
    /**
     * Rules used to restrict topics the device can subscribe to.
     */
    subscribe?: outputs.IotDeviceMessageFiltersSubscribe;
}

export interface IotDeviceMessageFiltersPublish {
    /**
     * Publish message filter policy
     */
    policy?: string;
    /**
     * List of topics in the set
     */
    topics?: string[];
}

export interface IotDeviceMessageFiltersSubscribe {
    /**
     * Subscribe message filter policy
     */
    policy?: string;
    /**
     * List of topics in the set
     */
    topics?: string[];
}

export interface IotRouteDatabase {
    /**
     * The database name (e.g. `measurements`).
     */
    dbname: string;
    /**
     * The database hostname. Can be an IP or a FQDN.
     */
    host: string;
    /**
     * The database password.
     */
    password: string;
    /**
     * The database port (e.g. `5432`)
     */
    port: number;
    /**
     * The SQL query that will be executed when receiving a message ($TOPIC and $PAYLOAD variables are available, see documentation, e.g. `INSERT INTO mytable(date, topic, value) VALUES (NOW(), $TOPIC, $PAYLOAD)`).
     */
    query: string;
    /**
     * The database username.
     */
    username: string;
}

export interface IotRouteRest {
    /**
     * a map of the extra headers to send with the HTTP call (e.g. `X-Header = Value`).
     */
    headers: {[key: string]: string};
    /**
     * The URI of the Rest endpoint (e.g. `https://internal.mycompany.com/ingest/mqttdata`).
     */
    uri: string;
    /**
     * The HTTP Verb used to call Rest URI (e.g. `post`).
     */
    verb: string;
}

export interface IotRouteS3 {
    /**
     * The name of the S3 route's destination bucket (e.g. `my-object-storage`).
     */
    bucketName: string;
    /**
     * The region of the S3 route's destination bucket (e.g. `fr-par`).
     */
    bucketRegion: string;
    /**
     * The string to prefix object names with (e.g. `mykeyprefix-`).
     */
    objectPrefix?: string;
    /**
     * How the S3 route's objects will be created (e.g. `perTopic`). See [documentation](https://www.scaleway.com/en/docs/scaleway-iothub-route/#-Messages-Store-Strategies) for behaviour details.
     */
    strategy: string;
}

export interface IpamIpResource {
    /**
     * The ID of the resource that the IP is bound to.
     */
    id: string;
    /**
     * The MAC Address of the resource the IP is attached to.
     */
    macAddress: string;
    /**
     * The name of the resource the IP is attached to.
     */
    name: string;
    /**
     * The type of resource the IP is attached to.
     */
    type: string;
}

export interface IpamIpReverse {
    /**
     * Request a specific IP in the requested source pool.
     */
    address: string;
    /**
     * The reverse domain name.
     */
    hostname: string;
}

export interface IpamIpSource {
    /**
     * The private network the IP lives in if the IP is a private IP.
     */
    privateNetworkId: string;
    /**
     * The private network subnet the IP lives in if the IP is a private IP in a private network.
     */
    subnetId: string;
    /**
     * The zone the IP lives in if the IP is a public zoned one
     */
    zonal: string;
}

export interface JobDefinitionCron {
    schedule: string;
    timezone: string;
}

export interface KubernetesClusterAutoUpgrade {
    /**
     * Set to `true` to enable Kubernetes patch version auto upgrades.
     * > **Important:** When enabling auto upgrades, the `version` field take a minor version like x.y (ie 1.18).
     */
    enable: boolean;
    /**
     * The day of the auto upgrade maintenance window (`monday` to `sunday`, or `any`).
     */
    maintenanceWindowDay: string;
    /**
     * The start hour (UTC) of the 2-hour auto upgrade maintenance window (0 to 23).
     */
    maintenanceWindowStartHour: number;
}

export interface KubernetesClusterAutoscalerConfig {
    /**
     * Detect similar node groups and balance the number of nodes between them.
     */
    balanceSimilarNodeGroups?: boolean;
    /**
     * Disables the scale down feature of the autoscaler.
     */
    disableScaleDown?: boolean;
    /**
     * Type of resource estimator to be used in scale up.
     */
    estimator?: string;
    /**
     * Type of node group expander to be used in scale up.
     */
    expander?: string;
    /**
     * Pods with priority below cutoff will be expendable. They can be killed without any consideration during scale down and they don't cause scale up. Pods with null priority (PodPriority disabled) are non expendable.
     */
    expendablePodsPriorityCutoff?: number;
    /**
     * Ignore DaemonSet pods when calculating resource utilization for scaling down.
     */
    ignoreDaemonsetsUtilization?: boolean;
    /**
     * Maximum number of seconds the cluster autoscaler waits for pod termination when trying to scale down a node
     */
    maxGracefulTerminationSec?: number;
    /**
     * How long after scale up that scale down evaluation resumes.
     */
    scaleDownDelayAfterAdd?: string;
    /**
     * How long a node should be unneeded before it is eligible for scale down.
     */
    scaleDownUnneededTime?: string;
    /**
     * Node utilization level, defined as sum of requested resources divided by capacity, below which a node can be considered for scale down
     */
    scaleDownUtilizationThreshold?: number;
}

export interface KubernetesClusterKubeconfig {
    /**
     * The CA certificate of the Kubernetes API server.
     */
    clusterCaCertificate: string;
    /**
     * The raw kubeconfig file.
     */
    configFile: string;
    /**
     * The URL of the Kubernetes API server.
     */
    host: string;
    /**
     * The token to connect to the Kubernetes API server.
     */
    token: string;
}

export interface KubernetesClusterOpenIdConnectConfig {
    /**
     * A client id that all tokens must be issued for
     */
    clientId: string;
    /**
     * JWT claim to use as the user's group
     */
    groupsClaims?: string[];
    /**
     * Prefix prepended to group claims
     */
    groupsPrefix?: string;
    /**
     * URL of the provider which allows the API server to discover public signing keys
     */
    issuerUrl: string;
    /**
     * Multiple key=value pairs that describes a required claim in the ID Token
     */
    requiredClaims?: string[];
    /**
     * JWT claim to use as the user name
     */
    usernameClaim?: string;
    /**
     * Prefix prepended to username
     */
    usernamePrefix?: string;
}

export interface KubernetesNodePoolNode {
    /**
     * The name for the pool.
     * > **Important:** Updates to this field will recreate a new resource.
     */
    name: string;
    /**
     * The public IPv4.
     */
    publicIp: string;
    /**
     * The public IPv6.
     */
    publicIpV6: string;
    /**
     * The status of the node.
     */
    status: string;
}

export interface KubernetesNodePoolUpgradePolicy {
    /**
     * The maximum number of nodes to be created during the upgrade
     */
    maxSurge?: number;
    /**
     * The maximum number of nodes that can be not ready at the same time
     */
    maxUnavailable?: number;
}

export interface LoadbalancerAclAction {
    /**
     * Redirect parameters when using an ACL with `redirect` action.
     */
    redirects?: outputs.LoadbalancerAclActionRedirect[];
    /**
     * The redirect type. Possible values are: `location` or `scheme`.
     */
    type: string;
}

export interface LoadbalancerAclActionRedirect {
    /**
     * The HTTP redirect code to use
     */
    code?: number;
    /**
     * An URL can be used in case of a location redirect
     */
    target?: string;
    /**
     * The redirect type
     */
    type?: string;
}

export interface LoadbalancerAclMatch {
    /**
     * The HTTP filter to match. This filter is supported only if your backend protocol has an HTTP forward protocol.
     * It extracts the request's URL path, which starts at the first slash and ends before the question mark (without the host part).
     * Possible values are: `aclHttpFilterNone`, `pathBegin`, `pathEnd`, `httpHeaderMatch` or `regex`.
     */
    httpFilter?: string;
    /**
     * If you have `httpFilter` at `httpHeaderMatch`, you can use this field to filter on the HTTP header's value.
     */
    httpFilterOption?: string;
    /**
     * A list of possible values to match for the given HTTP filter.
     * Keep in mind that in the case of `httpHeaderMatch` the HTTP header field name is case-insensitive.
     */
    httpFilterValues?: string[];
    /**
     * If set to `true`, the condition will be of type "unless".
     */
    invert?: boolean;
    /**
     * A list of IPs or CIDR v4/v6 addresses of the client of the session to match.
     */
    ipSubnets?: string[];
}

export interface LoadbalancerBackendHealthCheckHttp {
    /**
     * The expected HTTP status code
     */
    code?: number;
    /**
     * The HTTP host header to use for HC requests
     */
    hostHeader?: string;
    /**
     * The HTTP method to use for HC requests
     */
    method?: string;
    /**
     * The HTTP endpoint URL to call for HC requests
     */
    uri: string;
}

export interface LoadbalancerBackendHealthCheckHttps {
    /**
     * The expected HTTP status code
     */
    code?: number;
    /**
     * The HTTP host header to use for HC requests
     */
    hostHeader?: string;
    /**
     * The HTTP method to use for HC requests
     */
    method?: string;
    /**
     * The SNI to use for HC requests over SSL
     */
    sni?: string;
    /**
     * The HTTPS endpoint URL to call for HC requests
     */
    uri: string;
}

export interface LoadbalancerBackendHealthCheckTcp {
}

export interface LoadbalancerCertificateCustomCertificate {
    /**
     * The full PEM-formatted certificate chain
     */
    certificateChain: string;
}

export interface LoadbalancerCertificateLetsencrypt {
    /**
     * Main domain of the certificate
     */
    commonName: string;
    /**
     * The alternative domain names of the certificate
     */
    subjectAlternativeNames?: string[];
}

export interface LoadbalancerFrontendAcl {
    /**
     * Action to undertake when an ACL filter matches.
     */
    action: outputs.LoadbalancerFrontendAclAction;
    /**
     * Date and time of ACL's creation (RFC 3339 format)
     */
    createdAt: string;
    /**
     * Description of the ACL
     */
    description?: string;
    /**
     * The ACL match rule. At least `ipSubnet` or `httpFilter` and `httpFilterValue` are required.
     */
    match: outputs.LoadbalancerFrontendAclMatch;
    /**
     * The ACL name. If not provided it will be randomly generated.
     */
    name: string;
    /**
     * Date and time of ACL's update (RFC 3339 format)
     */
    updatedAt: string;
}

export interface LoadbalancerFrontendAclAction {
    /**
     * Redirect parameters when using an ACL with `redirect` action.
     */
    redirects?: outputs.LoadbalancerFrontendAclActionRedirect[];
    /**
     * The redirect type. Possible values are: `location` or `scheme`.
     */
    type: string;
}

export interface LoadbalancerFrontendAclActionRedirect {
    /**
     * The HTTP redirect code to use
     */
    code?: number;
    /**
     * An URL can be used in case of a location redirect
     */
    target?: string;
    /**
     * The redirect type
     */
    type?: string;
}

export interface LoadbalancerFrontendAclMatch {
    /**
     * The HTTP filter to match. This filter is supported only if your backend protocol has an HTTP forward protocol.
     * It extracts the request's URL path, which starts at the first slash and ends before the question mark (without the host part).
     * Possible values are: `aclHttpFilterNone`, `pathBegin`, `pathEnd`, `httpHeaderMatch` or `regex`.
     */
    httpFilter?: string;
    /**
     * If you have `httpFilter` at `httpHeaderMatch`, you can use this field to filter on the HTTP header's value.
     */
    httpFilterOption?: string;
    /**
     * A list of possible values to match for the given HTTP filter.
     * Keep in mind that in the case of `httpHeaderMatch` the HTTP header field name is case-insensitive.
     */
    httpFilterValues?: string[];
    /**
     * If set to `true`, the condition will be of type "unless".
     */
    invert?: boolean;
    /**
     * A list of IPs or CIDR v4/v6 addresses of the client of the session to match.
     */
    ipSubnets?: string[];
}

export interface LoadbalancerPrivateNetwork {
    /**
     * (Optional) Set to true if you want to let DHCP assign IP addresses. See below.
     */
    dhcpConfig: boolean;
    /**
     * (Required) The ID of the Private Network to associate.
     */
    privateNetworkId: string;
    /**
     * (Optional) Define a local ip address of your choice for the load balancer instance. See below.
     */
    staticConfig?: string;
    /**
     * The status of private network connection
     */
    status: string;
    /**
     * `zone`) The zone of the load-balancer.
     */
    zone: string;
}

export interface MnqSnsCredentialsPermissions {
    /**
     * . Defines if user can manage the associated resource(s).
     */
    canManage: boolean;
    /**
     * . Defines if user can publish messages to the service.
     */
    canPublish: boolean;
    /**
     * . Defines if user can receive messages from the service.
     */
    canReceive: boolean;
}

export interface MnqSqsCredentialsPermissions {
    /**
     * . Defines if user can manage the associated resource(s).
     */
    canManage: boolean;
    /**
     * . Defines if user can publish messages to the service.
     */
    canPublish: boolean;
    /**
     * . Defines if user can receive messages from the service.
     */
    canReceive: boolean;
}

export interface ObjectBucketAclAccessControlPolicy {
    grants?: outputs.ObjectBucketAclAccessControlPolicyGrant[];
    /**
     * Configuration block of the bucket project owner's display organization ID.
     */
    owner: outputs.ObjectBucketAclAccessControlPolicyOwner;
}

export interface ObjectBucketAclAccessControlPolicyGrant {
    /**
     * Configuration block for the project being granted permissions.
     */
    grantee?: outputs.ObjectBucketAclAccessControlPolicyGrantGrantee;
    /**
     * Logging permissions assigned to the grantee for the bucket.
     */
    permission: string;
}

export interface ObjectBucketAclAccessControlPolicyGrantGrantee {
    displayName: string;
    /**
     * The `region`,`bucket` and `acl` separated by (`/`).
     */
    id: string;
    /**
     * Type of grantee. Valid values: `CanonicalUser`
     */
    type: string;
}

export interface ObjectBucketAclAccessControlPolicyOwner {
    /**
     * The project ID of the grantee.
     */
    displayName: string;
    /**
     * The `region`,`bucket` and `acl` separated by (`/`).
     */
    id: string;
}

export interface ObjectBucketCorsRule {
    /**
     * Specifies which headers are allowed.
     */
    allowedHeaders?: string[];
    /**
     * Specifies which methods are allowed. Can be `GET`, `PUT`, `POST`, `DELETE` or `HEAD`.
     */
    allowedMethods: string[];
    /**
     * Specifies which origins are allowed.
     */
    allowedOrigins: string[];
    /**
     * Specifies expose header in the response.
     */
    exposeHeaders?: string[];
    /**
     * Specifies time in seconds that browser can cache the response for a preflight request.
     */
    maxAgeSeconds?: number;
}

export interface ObjectBucketLifecycleRule {
    /**
     * Specifies the number of days after initiating a multipart upload when the multipart upload must be completed.
     *
     * * > **Important:** It's not recommended using `prefix` for `AbortIncompleteMultipartUpload` as any incomplete multipart upload will be billed
     */
    abortIncompleteMultipartUploadDays?: number;
    /**
     * The element value can be either Enabled or Disabled. If a rule is disabled, Scaleway S3 doesn't perform any of the actions defined in the rule.
     */
    enabled: boolean;
    /**
     * Specifies a period in the object's expire (documented below).
     */
    expiration?: outputs.ObjectBucketLifecycleRuleExpiration;
    /**
     * Unique identifier for the rule. Must be less than or equal to 255 characters in length.
     */
    id: string;
    /**
     * Object key prefix identifying one or more objects to which the rule applies.
     */
    prefix?: string;
    /**
     * Specifies object tags key and value.
     */
    tags?: {[key: string]: string};
    /**
     * Specifies a period in the object's transitions (documented below).
     *
     * At least one of `abortIncompleteMultipartUploadDays`, `expiration`, `transition` must be specified.
     */
    transitions?: outputs.ObjectBucketLifecycleRuleTransition[];
}

export interface ObjectBucketLifecycleRuleExpiration {
    /**
     * Specifies the number of days after object creation when the specific rule action takes effect.
     *
     * > **Important:**  If versioning is enabled, this rule only deletes the current version of an object.
     */
    days: number;
}

export interface ObjectBucketLifecycleRuleTransition {
    /**
     * Specifies the number of days after object creation when the specific rule action takes effect.
     */
    days?: number;
    /**
     * Specifies the Scaleway [storage class](https://www.scaleway.com/en/docs/storage/object/concepts/#storage-class) `STANDARD`, `GLACIER`, `ONEZONE_IA`  to which you want the object to transition.
     *
     * > **Important:**  `ONEZONE_IA` is only available in `fr-par` region. The storage class `GLACIER` is not available in `pl-waw` region.
     */
    storageClass: string;
}

export interface ObjectBucketLockConfigurationRule {
    /**
     * The default retention for the lock.
     */
    defaultRetention: outputs.ObjectBucketLockConfigurationRuleDefaultRetention;
}

export interface ObjectBucketLockConfigurationRuleDefaultRetention {
    /**
     * The number of days that you want to specify for the default retention period.
     */
    days?: number;
    /**
     * The default Object Lock retention mode you want to apply to new objects placed in the specified bucket.
     */
    mode: string;
    /**
     * The number of years that you want to specify for the default retention period.
     */
    years?: number;
}

export interface ObjectBucketVersioning {
    /**
     * Enable versioning. Once you version-enable a bucket, it can never return to an unversioned state. You can, however, suspend versioning on that bucket.
     */
    enabled: boolean;
}

export interface ObjectBucketWebsiteConfigurationErrorDocument {
    /**
     * The object key name to use when a 4XX class error occurs.
     */
    key: string;
}

export interface ObjectBucketWebsiteConfigurationIndexDocument {
    /**
     * A suffix that is appended to a request that is for a directory on the website endpoint.
     *
     * > **Important:** The suffix must not be empty and must not include a slash character. The routing is not supported.
     */
    suffix: string;
}

export interface RedisClusterAcl {
    /**
     * A text describing this rule. Default description: `Allow IP`
     *
     * > The `acl` conflict with `privateNetwork`. Only one should be specified.
     */
    description: string;
    /**
     * (Required) The UUID of the endpoint.
     */
    id: string;
    /**
     * The ip range to whitelist
     * in [CIDR notation](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#CIDR_notation)
     */
    ip: string;
}

export interface RedisClusterPrivateNetwork {
    /**
     * The ID of the endpoint.
     */
    endpointId: string;
    /**
     * The UUID of the Private Network resource.
     */
    id: string;
    /**
     * Endpoint IPv4 addresses in [CIDR notation](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#CIDR_notation). You must provide at least one IP per node.
     * Keep in mind that in Cluster mode you cannot edit your Private Network after its creation so if you want to be able to
     * scale your Cluster horizontally (adding nodes) later, you should provide more IPs than nodes.
     * If not set, the IP network address within the private subnet is determined by the IP Address Management (IPAM) service.
     *
     * > The `privateNetwork` conflicts with `acl`. Only one should be specified.
     *
     * > **Important:** The way to use private networks differs whether you are using Redis in Standalone or Cluster mode.
     *
     * - Standalone mode (`clusterSize` = 1) : you can attach as many Private Networks as you want (each must be a separate
     * block). If you detach your only private network, your cluster won't be reachable until you define a new Private or
     * Public Network. You can modify your `privateNetwork` and its specs, you can have both a Private and Public Network side
     * by side.
     *
     * - Cluster mode (`clusterSize` > 2) : you can define a single Private Network as you create your Cluster, you won't be
     * able to edit or detach it afterward, unless you create another Cluster. This also means that, if you are using a static
     * configuration (`serviceIps`), you won't be able to scale your Cluster horizontally (add more nodes) since it would
     * require updating the private network to add IPs.
     * Your `serviceIps` must be listed as follows:
     *
     * ```typescript
     * import * as pulumi from "@pulumi/pulumi";
     * ```
     */
    serviceIps: string[];
    /**
     * `zone`) The zone in which the
     * Redis Cluster should be created.
     */
    zone: string;
}

export interface RedisClusterPublicNetwork {
    /**
     * (Required) The UUID of the endpoint.
     */
    id: string;
    /**
     * Lis of IPv4 address of the endpoint (IP address).
     */
    ips: string[];
    /**
     * TCP port of the endpoint.
     */
    port: number;
}

export interface TemDomainReputation {
    /**
     * The previously-calculated domain's reputation score.
     */
    previousScore: number;
    /**
     * The time and date the previous reputation score was calculated.
     */
    previousScoredAt: string;
    /**
     * A range from 0 to 100 that determines your domain's reputation score.
     */
    score: number;
    /**
     * The time and date the score was calculated.
     */
    scoredAt: string;
    /**
     * The status of the domain's reputation.
     */
    status: string;
}

export interface VpcGatewayNetworkIpamConfig {
    /**
     * Use this IPAM-booked IP ID as the Gateway's IP in this Private Network.
     */
    ipamIpId: string;
    /**
     * Defines whether the default route is enabled on that Gateway Network.
     */
    pushDefaultRoute?: boolean;
}

export interface VpcPrivateNetworkIpv4Subnet {
    /**
     * The network address of the subnet in dotted decimal notation, e.g., '192.168.0.0' for a '192.168.0.0/24' subnet.
     */
    address: string;
    /**
     * The date and time of the creation of the subnet.
     */
    createdAt: string;
    /**
     * The subnet ID.
     */
    id: string;
    /**
     * The length of the network prefix, e.g., 24 for a 255.255.255.0 mask.
     */
    prefixLength: number;
    /**
     * The subnet CIDR.
     */
    subnet: string;
    /**
     * The subnet mask expressed in dotted decimal notation, e.g., '255.255.255.0' for a /24 subnet
     */
    subnetMask: string;
    /**
     * The date and time of the last update of the subnet.
     */
    updatedAt: string;
}

export interface VpcPrivateNetworkIpv6Subnet {
    /**
     * The network address of the subnet in dotted decimal notation, e.g., '192.168.0.0' for a '192.168.0.0/24' subnet.
     */
    address: string;
    /**
     * The date and time of the creation of the subnet.
     */
    createdAt: string;
    /**
     * The subnet ID.
     */
    id: string;
    /**
     * The length of the network prefix, e.g., 24 for a 255.255.255.0 mask.
     */
    prefixLength: number;
    /**
     * The subnet CIDR.
     */
    subnet: string;
    /**
     * The subnet mask expressed in dotted decimal notation, e.g., '255.255.255.0' for a /24 subnet
     */
    subnetMask: string;
    /**
     * The date and time of the last update of the subnet.
     */
    updatedAt: string;
}

export interface WebhostingCpanelUrl {
    /**
     * The URL of the Dashboard.
     */
    dashboard: string;
    /**
     * The URL of the Webmail interface.
     */
    webmail: string;
}

export interface WebhostingOption {
    /**
     * The option ID.
     */
    id: string;
    /**
     * The option name.
     */
    name: string;
}

