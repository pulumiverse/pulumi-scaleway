// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface AppleSiliconServerPrivateIp {
    /**
     * The private IP address.
     */
    address: string;
    /**
     * The ID of the IP address resource.
     */
    id: string;
}

export interface AppleSiliconServerPrivateNetwork {
    /**
     * The date and time the private network was created.
     */
    createdAt: string;
    /**
     * The private network ID
     */
    id: string;
    /**
     * A list of IPAM IP IDs to attach to the server.
     */
    ipamIpIds: string[];
    /**
     * The current status of the private network.
     */
    status: string;
    /**
     * The date and time the private network was last updated.
     */
    updatedAt: string;
    /**
     * The VLAN ID associated with the private network.
     */
    vlan: number;
}

export interface BaremetalServerIp {
    /**
     * The address of the IPv6.
     */
    address: string;
    /**
     * The ID of the IPv6.
     */
    id: string;
    /**
     * The reverse of the IPv6.
     */
    reverse: string;
    /**
     * The type of the IPv6.
     */
    version: string;
}

export interface BaremetalServerIpv4 {
    /**
     * The address of the IPv6.
     */
    address: string;
    /**
     * The ID of the IPv6.
     */
    id: string;
    /**
     * The reverse of the IPv6.
     */
    reverse: string;
    /**
     * The type of the IPv6.
     */
    version: string;
}

export interface BaremetalServerIpv6 {
    /**
     * The address of the IPv6.
     */
    address: string;
    /**
     * The ID of the IPv6.
     */
    id: string;
    /**
     * The reverse of the IPv6.
     */
    reverse: string;
    /**
     * The type of the IPv6.
     */
    version: string;
}

export interface BaremetalServerOption {
    /**
     * The auto expiration date for compatible options
     */
    expiresAt: string;
    /**
     * The id of the option to enable. Use [this endpoint](https://www.scaleway.com/en/developers/api/elastic-metal/#path-options-list-options) to find the available options IDs.
     */
    id: string;
    /**
     * The name of the server.
     */
    name: string;
}

export interface BaremetalServerPrivateIp {
    /**
     * The address of the IPv6.
     */
    address: string;
    /**
     * The ID of the IPv6.
     */
    id: string;
}

export interface BaremetalServerPrivateNetwork {
    /**
     * The date and time of the creation of the private network.
     */
    createdAt: string;
    /**
     * The id of the private network to attach.
     */
    id: string;
    /**
     * List of IPAM IP IDs to assign to the server in the requested private network.
     */
    ipamIpIds: string[];
    /**
     * The ID of the Server-to-Private Network mapping.
     */
    mappingId: string;
    /**
     * The private network status.
     */
    status: string;
    /**
     * The date and time of the last update of the private network.
     */
    updatedAt: string;
    /**
     * The VLAN ID associated to the private network.
     */
    vlan: number;
}

export interface BlockSnapshotExport {
    /**
     * The name of the bucket where the QCOW file will be saved.
     */
    bucket: string;
    /**
     * The desired key (path) for the QCOW file within the bucket.
     */
    key: string;
}

export interface BlockSnapshotImport {
    /**
     * The name of the bucket containing the QCOW file.
     */
    bucket: string;
    /**
     * The key of the QCOW file within the bucket.
     */
    key: string;
}

export interface CockpitAlertManagerContactPoint {
    /**
     * Email addresses for the alert receivers
     */
    email?: string;
}

export interface CockpitEndpoint {
    /**
     * (Deprecated) URL for the [Alert manager](https://www.scaleway.com/en/docs/observability/cockpit/concepts/#alert-manager).
     */
    alertmanagerUrl: string;
    /**
     * (Deprecated) URL for Grafana.
     */
    grafanaUrl: string;
    /**
     * (Deprecated) URL for [logs](https://www.scaleway.com/en/docs/observability/cockpit/concepts/#logs) to retrieve in the [Data sources tab](https://console.scaleway.com/cockpit/dataSource) of the Scaleway console.
     */
    logsUrl: string;
    /**
     * (Deprecated) URL for [metrics](https://www.scaleway.com/en/docs/observability/cockpit/concepts/#metric) to retrieve in the [Data sources tab](https://console.scaleway.com/cockpit/dataSource) of the Scaleway console.
     */
    metricsUrl: string;
    /**
     * (Deprecated) URL for [traces](https://www.scaleway.com/en/docs/observability/cockpit/concepts/#traces) to retrieve in the [Data sources tab](https://console.scaleway.com/cockpit/dataSource) of the Scaleway console.
     */
    tracesUrl: string;
}

export interface CockpitPushUrl {
    /**
     * Push URL for logs (Grafana Loki)
     */
    pushLogsUrl: string;
    /**
     * Push URL for metrics (Grafana Mimir)
     */
    pushMetricsUrl: string;
}

export interface CockpitTokenScopes {
    /**
     * Permission to query logs.
     */
    queryLogs?: boolean;
    /**
     * Permission to query metrics.
     */
    queryMetrics?: boolean;
    /**
     * Permission to query traces.
     */
    queryTraces?: boolean;
    /**
     * Permission to set up alerts.
     */
    setupAlerts?: boolean;
    /**
     * Permission to set up logs rules.
     */
    setupLogsRules?: boolean;
    /**
     * Permission to set up metrics rules.
     */
    setupMetricsRules?: boolean;
    /**
     * Permission to write logs.
     */
    writeLogs?: boolean;
    /**
     * Permission to write metrics.
     */
    writeMetrics?: boolean;
    /**
     * Permission to write traces.
     */
    writeTraces?: boolean;
}

export interface ContainerHealthCheck {
    /**
     * Number of consecutive health check failures before considering the container unhealthy.
     */
    failureThreshold: number;
    /**
     * HTTP health check configuration.
     */
    https: outputs.ContainerHealthCheckHttp[];
    /**
     * Period between health checks (in seconds).
     */
    interval: string;
}

export interface ContainerHealthCheckHttp {
    /**
     * Path to use for the HTTP health check.
     */
    path: string;
}

export interface ContainerScalingOption {
    /**
     * Scale depending on the number of concurrent requests being processed per container instance.
     */
    concurrentRequestsThreshold?: number;
    /**
     * Scale depending on the CPU usage of a container instance.
     */
    cpuUsageThreshold?: number;
    /**
     * Scale depending on the memory usage of a container instance.
     */
    memoryUsageThreshold?: number;
}

export interface ContainerTriggerNats {
    /**
     * unique identifier of the Messaging and Queuing NATS account.
     */
    accountId?: string;
    /**
     * THe ID of the project that contains the Messaging and Queuing NATS account (defaults to provider `projectId`)
     */
    projectId: string;
    /**
     * Region where the Messaging and Queuing NATS account is enabled (defaults to provider `region`)
     */
    region: string;
    /**
     * The subject to listen to.
     */
    subject: string;
}

export interface ContainerTriggerSqs {
    /**
     * ID of the Messaging and Queuing namespace. This argument is deprecated.
     *
     * @deprecated The 'namespace_id' field is deprecated and will be removed in the next major version. It is no longer necessary to specify it
     */
    namespaceId?: string;
    /**
     * The ID of the project in which SQS is enabled, (defaults to provider `projectId`)
     */
    projectId: string;
    /**
     * The name of the SQS queue.
     */
    queue: string;
    /**
     * Region where SQS is enabled (defaults to provider `region`)
     */
    region: string;
}

export interface DatabaseAclAclRule {
    /**
     * A text describing this rule. Default description: `IP allowed`
     */
    description: string;
    /**
     * The IP range to whitelist in [CIDR notation](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#CIDR_notation)
     */
    ip: string;
}

export interface DatabaseInstanceLoadBalancer {
    /**
     * The ID of the endpoint.
     */
    endpointId: string;
    /**
     * Hostname of the endpoint.
     */
    hostname: string;
    /**
     * IPv4 address on the network.
     */
    ip: string;
    /**
     * The name of the Database Instance.
     */
    name: string;
    /**
     * Port in the Private Network.
     */
    port: number;
}

export interface DatabaseInstanceLogsPolicy {
    /**
     * The max age (in days) of remote logs to keep on the Database Instance
     */
    maxAgeRetention: number;
    /**
     * The max disk size of remote logs to keep on the Database Instance.
     */
    totalDiskRetention: number;
}

export interface DatabaseInstancePrivateIp {
    /**
     * The private IPv4 address.
     */
    address: string;
    /**
     * The ID of the IPv4 address resource.
     */
    id: string;
}

export interface DatabaseInstancePrivateNetwork {
    /**
     * Whether or not the private network endpoint should be configured with IPAM
     */
    enableIpam: boolean;
    /**
     * The ID of the endpoint.
     */
    endpointId: string;
    /**
     * Hostname of the endpoint.
     */
    hostname: string;
    /**
     * IPv4 address on the network.
     */
    ip: string;
    /**
     * The IP with the given mask within the private subnet
     */
    ipNet: string;
    /**
     * The name of the Database Instance.
     */
    name: string;
    /**
     * The private network ID
     */
    pnId: string;
    /**
     * Port in the Private Network.
     */
    port: number;
    /**
     * The zone you want to attach the resource to
     */
    zone?: string;
}

export interface DatabaseInstanceReadReplica {
    /**
     * IPv4 address on the network.
     */
    ip: string;
    /**
     * The name of the Database Instance.
     */
    name: string;
    /**
     * Port in the Private Network.
     */
    port: number;
}

export interface DatabaseReadReplicaDirectAccess {
    /**
     * The ID of the endpoint of the Read Replica.
     */
    endpointId: string;
    /**
     * Hostname of the endpoint. Only one of IP and hostname may be set.
     */
    hostname: string;
    /**
     * IPv4 address of the endpoint (IP address). Only one of IP and hostname may be set.
     */
    ip: string;
    /**
     * Name of the endpoint.
     */
    name: string;
    /**
     * TCP port of the endpoint.
     */
    port: number;
}

export interface DatabaseReadReplicaPrivateNetwork {
    /**
     * If true, the IP network address within the private subnet is determined by the IP Address Management (IPAM) service.
     *
     * > **Important:** One of `serviceIp` or `enable_ipam=true` must be set.
     */
    enableIpam: boolean;
    /**
     * The ID of the endpoint of the Read Replica.
     */
    endpointId: string;
    /**
     * Hostname of the endpoint. Only one of IP and hostname may be set.
     */
    hostname: string;
    /**
     * IPv4 address of the endpoint (IP address). Only one of IP and hostname may be set.
     */
    ip: string;
    /**
     * Name of the endpoint.
     */
    name: string;
    /**
     * TCP port of the endpoint.
     */
    port: number;
    /**
     * UUID of the Private Netork to be connected to the Read Replica.
     */
    privateNetworkId: string;
    /**
     * The IP network address within the private subnet. This must be an IPv4 address with a CIDR notation. If not set, The IP network address within the private subnet is determined by the IP Address Management (IPAM) service.
     */
    serviceIp: string;
    /**
     * Private network zone
     */
    zone: string;
}

export interface DomainRecordGeoIp {
    /**
     * The list of matches
     */
    matches: outputs.DomainRecordGeoIpMatch[];
}

export interface DomainRecordGeoIpMatch {
    /**
     * List of continents (eg: EU for Europe, NA for North America, AS for Asia...). List of all continents code: https://api.scaleway.com/domain-private/v2beta1/continents
     */
    continents?: string[];
    /**
     * List of countries (eg: FR for France, US for the United States, GB for Great Britain...). List of all countries code: https://api.scaleway.com/domain-private/v2beta1/countries
     */
    countries?: string[];
    /**
     * The content of the record (an IPv4 for an `A` record, a string for a `TXT` record, etc.).
     */
    data: string;
}

export interface DomainRecordHttpService {
    /**
     * IPs to check
     */
    ips: string[];
    /**
     * Text to search
     */
    mustContain: string;
    /**
     * Strategy to return an IP from the IPs list
     */
    strategy: string;
    /**
     * URL to match the mustContain text to validate an IP
     */
    url: string;
    /**
     * User-agent used when checking the URL
     */
    userAgent?: string;
}

export interface DomainRecordView {
    /**
     * The content of the record (an IPv4 for an `A` record, a string for a `TXT` record, etc.).
     */
    data: string;
    /**
     * The subnet of the view
     */
    subnet: string;
}

export interface DomainRecordWeighted {
    /**
     * The weighted IP
     */
    ip: string;
    /**
     * The weight of the IP
     */
    weight: number;
}

export interface EdgeServicesBackendStageLbBackendConfig {
    /**
     * The Load Balancer config.
     */
    lbConfig?: outputs.EdgeServicesBackendStageLbBackendConfigLbConfig;
}

export interface EdgeServicesBackendStageLbBackendConfigLbConfig {
    /**
     * The Fully Qualified Domain Name (in the format subdomain.example.com) to use in HTTP requests sent towards your Load Balancer.
     */
    domainName?: string;
    /**
     * The ID of the frontend.
     */
    frontendId?: string;
    /**
     * The ID of the Load Balancer.
     */
    id?: string;
    /**
     * Defines whether the Load Balancer's frontend handles SSL connections.
     */
    isSsl?: boolean;
    /**
     * `zone`) The zone of the Load Balancer.
     */
    zone?: string;
}

export interface EdgeServicesBackendStageS3BackendConfig {
    /**
     * The name of the Bucket.
     */
    bucketName?: string;
    /**
     * The region of the Bucket.
     */
    bucketRegion?: string;
    /**
     * Defines whether the bucket website feature is enabled.
     */
    isWebsite?: boolean;
}

export interface EdgeServicesCacheStagePurgeRequest {
    /**
     * Defines whether to purge all content.
     */
    all?: boolean;
    /**
     * The list of asserts to purge.
     */
    assets?: string[];
    /**
     * The pipeline ID in which the purge request will be created.
     */
    pipelineId?: string;
}

export interface EdgeServicesRouteStageRule {
    /**
     * The ID of the backend stage that requests matching the rule should be forwarded to.
     */
    backendStageId: string;
    /**
     * The rule condition to be matched. Requests matching the condition defined here will be directly forwarded to the backend specified by the `backendStageId` field. Requests that do not match will be checked by the next rule's condition.
     */
    ruleHttpMatch?: outputs.EdgeServicesRouteStageRuleRuleHttpMatch;
}

export interface EdgeServicesRouteStageRuleRuleHttpMatch {
    /**
     * HTTP methods to filter for. A request using any of these methods will be considered to match the rule. Possible values are `get`, `post`, `put`, `patch`, `delete`, `head`, `options`. All methods will match if none is provided.
     */
    methodFilters: string[];
    /**
     * HTTP URL path to filter for. A request whose path matches the given filter will be considered to match the rule. All paths will match if none is provided.
     */
    pathFilter?: outputs.EdgeServicesRouteStageRuleRuleHttpMatchPathFilter;
}

export interface EdgeServicesRouteStageRuleRuleHttpMatchPathFilter {
    /**
     * The type of filter to match for the HTTP URL path. For now, all path filters must be written in regex and use the `regex` type.
     */
    pathFilterType: string;
    /**
     * The value to be matched for the HTTP URL path.
     */
    value: string;
}

export interface EdgeServicesTlsStageSecret {
    /**
     * The region of the secret.
     */
    region?: string;
    /**
     * The ID of the Secret
     */
    secretId: string;
}

export interface FunctionTriggerNats {
    /**
     * unique identifier of the Messaging and Queuing NATS account.
     */
    accountId?: string;
    /**
     * THe ID of the project that contains the Messaging and Queuing NATS account (defaults to provider `projectId`)
     */
    projectId: string;
    /**
     * Region where the Messaging and Queuing NATS account is enabled (defaults to provider `region`)
     */
    region: string;
    /**
     * The subject to listen to.
     */
    subject: string;
}

export interface FunctionTriggerSqs {
    /**
     * ID of the Messaging and Queuing namespace. This argument is deprecated.
     *
     * @deprecated The 'namespace_id' field is deprecated and will be removed in the next major version. It is no longer necessary to specify it
     */
    namespaceId?: string;
    /**
     * The ID of the project in which SQS is enabled, (defaults to provider `projectId`)
     */
    projectId: string;
    /**
     * The name of the SQS queue.
     */
    queue: string;
    /**
     * Region where SQS is enabled (defaults to provider `region`)
     */
    region: string;
}

export interface GetBaremetalOfferCpu {
    /**
     * Number of core on this CPU.
     */
    coreCount: number;
    /**
     * Frequency of the memory in MHz.
     */
    frequency: number;
    /**
     * The offer name. Only one of `name` and `offerId` should be specified.
     */
    name: string;
    /**
     * Number of thread on this CPU.
     */
    threadCount: number;
}

export interface GetBaremetalOfferDisk {
    /**
     * Capacity of the memory in GB.
     */
    capacity: number;
    /**
     * Type of memory.
     */
    type: string;
}

export interface GetBaremetalOfferMemory {
    /**
     * Capacity of the memory in GB.
     */
    capacity: number;
    /**
     * Frequency of the memory in MHz.
     */
    frequency: number;
    /**
     * True if error-correcting code is available on this memory.
     */
    isEcc: boolean;
    /**
     * Type of memory.
     */
    type: string;
}

export interface GetBaremetalServerIp {
    /**
     * The IPv6 address
     */
    address: string;
    /**
     * The ID of the server.
     */
    id: string;
    /**
     * The Reverse of the IPv6
     */
    reverse: string;
    /**
     * The version of the IPv6
     */
    version: string;
}

export interface GetBaremetalServerIpv4 {
    /**
     * The IPv6 address
     */
    address: string;
    /**
     * The ID of the server.
     */
    id: string;
    /**
     * The Reverse of the IPv6
     */
    reverse: string;
    /**
     * The version of the IPv6
     */
    version: string;
}

export interface GetBaremetalServerIpv6 {
    /**
     * The IPv6 address
     */
    address: string;
    /**
     * The ID of the server.
     */
    id: string;
    /**
     * The Reverse of the IPv6
     */
    reverse: string;
    /**
     * The version of the IPv6
     */
    version: string;
}

export interface GetBaremetalServerOption {
    /**
     * Auto expire the option after this date
     */
    expiresAt: string;
    /**
     * The ID of the server.
     */
    id: string;
    /**
     * The server name. Only one of `name` and `serverId` should be specified.
     */
    name: string;
}

export interface GetBaremetalServerPrivateIp {
    /**
     * The private IP address
     */
    address: string;
    /**
     * The ID of the server.
     */
    id: string;
}

export interface GetBaremetalServerPrivateNetwork {
    /**
     * The date and time of the creation of the private network
     */
    createdAt: string;
    /**
     * The ID of the server.
     */
    id: string;
    /**
     * List of IPAM IP IDs to attach to the server
     */
    ipamIpIds: string[];
    /**
     * The ID of the Server-to-Private Network mapping
     */
    mappingId: string;
    /**
     * The private network status
     */
    status: string;
    /**
     * The date and time of the last update of the private network
     */
    updatedAt: string;
    /**
     * The VLAN ID associated to the private network
     */
    vlan: number;
}

export interface GetBillingConsumptionsConsumption {
    /**
     * The consumed quantity.
     */
    billedQuantity: string;
    /**
     * The name of the consumption category.
     */
    categoryName: string;
    /**
     * The product name.
     */
    productName: string;
    /**
     * `projectId`) The ID of the project the consumption list is associated with.
     */
    projectId: string;
    /**
     * The unique identifier of the product.
     */
    sku: string;
    /**
     * The unit of consumed quantity.
     */
    unit: string;
    /**
     * The monetary value of the consumption.
     */
    value: string;
}

export interface GetBillingInvoicesInvoice {
    /**
     * The billing period of the invoice in the YYYY-MM format.
     */
    billingPeriod: string;
    /**
     * The payment time limit, set according to the Organization's payment conditions (RFC 3339 format).
     */
    dueDate: string;
    /**
     * The associated invoice ID.
     */
    id: string;
    /**
     * Invoices with the given type are listed. Valid values are `periodic` and `purchase`.
     */
    invoiceType: string;
    /**
     * The date when the invoice was sent to the customer (RFC 3339 format).
     */
    issuedDate: string;
    /**
     * The invoice number.
     */
    number: number;
    /**
     * The organization name.
     */
    organizationName: string;
    /**
     * The name of the seller (Scaleway).
     */
    sellerName: string;
    /**
     * The start date of the billing period (RFC 3339 format).
     */
    startDate: string;
    /**
     * The state of the invoice.
     */
    state: string;
    /**
     * The end date of the billing period (RFC 3339 format).
     */
    stopDate: string;
    /**
     * The total discount amount of the invoice.
     */
    totalDiscount: string;
    /**
     * The total tax amount of the invoice.
     */
    totalTax: string;
    /**
     * The total amount, taxed.
     */
    totalTaxed: string;
    /**
     * The total amount of the invoice before applying the discount.
     */
    totalUndiscount: string;
    /**
     * The total amount, untaxed.
     */
    totalUntaxed: string;
}

export interface GetBlockSnapshotExport {
    /**
     * Bucket containing qcow
     */
    bucket: string;
    /**
     * Key of the qcow file in the specified bucket
     */
    key: string;
}

export interface GetBlockSnapshotImport {
    /**
     * Bucket containing qcow
     */
    bucket: string;
    /**
     * Key of the qcow file in the specified bucket
     */
    key: string;
}

export interface GetCockpitEndpoint {
    /**
     * (Deprecated) URL for the [Alert manager](https://www.scaleway.com/en/docs/observability/cockpit/concepts/#alert-manager).
     */
    alertmanagerUrl: string;
    /**
     * (Deprecated) URL for Grafana.
     */
    grafanaUrl: string;
    /**
     * (Deprecated) URL for [logs](https://www.scaleway.com/en/docs/observability/cockpit/concepts/#logs) to retrieve in the [Data sources tab](https://console.scaleway.com/cockpit/dataSource) of the Scaleway console.
     */
    logsUrl: string;
    /**
     * (Deprecated) URL for [metrics](https://www.scaleway.com/en/docs/observability/cockpit/concepts/#metric) to retrieve in the [Data sources tab](https://console.scaleway.com/cockpit/dataSource) of the Scaleway console.
     */
    metricsUrl: string;
    /**
     * The traces URL.
     */
    tracesUrl: string;
}

export interface GetCockpitPushUrl {
    /**
     * Push URL for logs (Grafana Loki)
     */
    pushLogsUrl: string;
    /**
     * Push URL for metrics (Grafana Mimir)
     */
    pushMetricsUrl: string;
}

export interface GetContainerHealthCheck {
    /**
     * Number of consecutive health check failures before considering the container unhealthy.
     */
    failureThreshold: number;
    /**
     * HTTP health check configuration.
     */
    https: outputs.GetContainerHealthCheckHttp[];
    /**
     * Period between health checks (in seconds).
     */
    interval: string;
}

export interface GetContainerHealthCheckHttp {
    /**
     * Path to use for the HTTP health check.
     */
    path: string;
}

export interface GetContainerScalingOption {
    /**
     * Scale depending on the number of concurrent requests being processed per container instance.
     */
    concurrentRequestsThreshold: number;
    /**
     * Scale depending on the CPU usage of a container instance.
     */
    cpuUsageThreshold: number;
    /**
     * Scale depending on the memory usage of a container instance.
     */
    memoryUsageThreshold: number;
}

export interface GetDatabaseAclAclRule {
    /**
     * A simple text describing this rule
     */
    description: string;
    /**
     * The ip range to whitelist in [CIDR notation](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#CIDR_notation)
     */
    ip: string;
}

export interface GetDatabaseInstanceLoadBalancer {
    /**
     * The endpoint ID
     */
    endpointId: string;
    /**
     * The hostname of your endpoint
     */
    hostname: string;
    /**
     * The IP of your load balancer service
     */
    ip: string;
    /**
     * The name of the RDB instance.
     */
    name: string;
    /**
     * The port of your load balancer service
     */
    port: number;
}

export interface GetDatabaseInstanceLogsPolicy {
    /**
     * The max age (in days) of remote logs to keep on the Database Instance
     */
    maxAgeRetention: number;
    /**
     * The max disk size of remote logs to keep on the Database Instance.
     */
    totalDiskRetention: number;
}

export interface GetDatabaseInstancePrivateIp {
    /**
     * The private IPv4 address
     */
    address: string;
    /**
     * The ID of the Database Instance.
     */
    id: string;
}

export interface GetDatabaseInstancePrivateNetwork {
    /**
     * Whether or not the private network endpoint should be configured with IPAM
     */
    enableIpam: boolean;
    /**
     * The endpoint ID
     */
    endpointId: string;
    /**
     * The hostname of your endpoint
     */
    hostname: string;
    /**
     * The IP of your Instance within the private service
     */
    ip: string;
    /**
     * The IP with the given mask within the private subnet
     */
    ipNet: string;
    /**
     * The name of the RDB instance.
     */
    name: string;
    /**
     * The private network ID
     */
    pnId: string;
    /**
     * The port of your private service
     */
    port: number;
    /**
     * The zone you want to attach the resource to
     */
    zone: string;
}

export interface GetDatabaseInstanceReadReplica {
    /**
     * IP of the replica
     */
    ip: string;
    /**
     * The name of the RDB instance.
     */
    name: string;
    /**
     * Port of the replica
     */
    port: number;
}

export interface GetDomainRecordGeoIp {
    /**
     * The list of matches
     */
    matches: outputs.GetDomainRecordGeoIpMatch[];
}

export interface GetDomainRecordGeoIpMatch {
    /**
     * List of continents (eg: EU for Europe, NA for North America, AS for Asia...). List of all continents code: https://api.scaleway.com/domain-private/v2beta1/continents
     */
    continents: string[];
    /**
     * List of countries (eg: FR for France, US for the United States, GB for Great Britain...). List of all countries code: https://api.scaleway.com/domain-private/v2beta1/countries
     */
    countries: string[];
    /**
     * The content of the record (e.g., an IPv4 address for an `A` record or a string for a `TXT` record). Cannot be used with `recordId`.
     */
    data: string;
}

export interface GetDomainRecordHttpService {
    /**
     * IPs to check
     */
    ips: string[];
    /**
     * Text to search
     */
    mustContain: string;
    /**
     * Strategy to return an IP from the IPs list
     */
    strategy: string;
    /**
     * URL to match the mustContain text to validate an IP
     */
    url: string;
    /**
     * User-agent used when checking the URL
     */
    userAgent: string;
}

export interface GetDomainRecordView {
    /**
     * The content of the record (e.g., an IPv4 address for an `A` record or a string for a `TXT` record). Cannot be used with `recordId`.
     */
    data: string;
    /**
     * The subnet of the view
     */
    subnet: string;
}

export interface GetDomainRecordWeighted {
    /**
     * The weighted IP
     */
    ip: string;
    /**
     * The weight of the IP
     */
    weight: number;
}

export interface GetFlexibleIpsIp {
    /**
     * The date on which the flexible IP was created (RFC 3339 format).
     */
    createdAt: string;
    /**
     * The description of the flexible IP.
     */
    description: string;
    /**
     * The MAC address ID.
     */
    id: string;
    /**
     * IP address of the flexible IP
     */
    ipAddress: string;
    /**
     * The MAC address of the Virtual MAC.
     */
    macAddresses: outputs.GetFlexibleIpsIpMacAddress[];
    /**
     * (Defaults to provider `organizationId`) The ID of the organization the IP is in.
     */
    organizationId: string;
    /**
     * (Defaults to provider `projectId`) The ID of the project the IP is in.
     */
    projectId: string;
    /**
     * The reverse domain associated with this IP.
     */
    reverse: string;
    /**
     * The status of virtual MAC.
     */
    status: string;
    /**
     * List of tags used as filter. IPs with these exact tags are listed.
     */
    tags: string[];
    /**
     * The date on which the flexible IP was last updated (RFC 3339 format).
     */
    updatedAt: string;
    /**
     * `zone`) The zone in which IPs exist.
     */
    zone: string;
}

export interface GetFlexibleIpsIpMacAddress {
    /**
     * The date on which the flexible IP was created (RFC 3339 format).
     */
    createdAt: string;
    /**
     * The MAC address ID.
     */
    id: string;
    /**
     * The MAC address of the Virtual MAC.
     */
    macAddress: string;
    /**
     * The type of virtual MAC.
     */
    macType: string;
    /**
     * The status of virtual MAC.
     */
    status: string;
    /**
     * The date on which the flexible IP was last updated (RFC 3339 format).
     */
    updatedAt: string;
    /**
     * `zone`) The zone in which IPs exist.
     */
    zone?: string;
}

export interface GetInstancePrivateNicPrivateIp {
    /**
     * The private IP address
     */
    address: string;
    /**
     * The ID of the IP address resource
     */
    id: string;
}

export interface GetInstanceSecurityGroupInboundRule {
    /**
     * The action to take when rule match. Possible values are: `accept` or `drop`.
     */
    action: string;
    /**
     * The ip this rule apply to.
     */
    ip: string;
    /**
     * The ip range (e.g `192.168.1.0/24`) this rule apply to.
     */
    ipRange: string;
    /**
     * The port this rule apply to. If no port is specified, rule will apply to all port.
     */
    port: number;
    /**
     * The port range (e.g `22-23`) this rule applies to.
     * If no `port` nor `portRange` are specified, rule will apply to all port.
     * Only one of `port` and `portRange` should be specified.
     */
    portRange: string;
    /**
     * The protocol this rule apply to. Possible values are: `TCP`, `UDP`, `ICMP` or `ANY`.
     */
    protocol: string;
}

export interface GetInstanceSecurityGroupOutboundRule {
    /**
     * The action to take when rule match. Possible values are: `accept` or `drop`.
     */
    action: string;
    /**
     * The ip this rule apply to.
     */
    ip: string;
    /**
     * The ip range (e.g `192.168.1.0/24`) this rule apply to.
     */
    ipRange: string;
    /**
     * The port this rule apply to. If no port is specified, rule will apply to all port.
     */
    port: number;
    /**
     * The port range (e.g `22-23`) this rule applies to.
     * If no `port` nor `portRange` are specified, rule will apply to all port.
     * Only one of `port` and `portRange` should be specified.
     */
    portRange: string;
    /**
     * The protocol this rule apply to. Possible values are: `TCP`, `UDP`, `ICMP` or `ANY`.
     */
    protocol: string;
}

export interface GetInstanceServerPrivateIp {
    /**
     * The address of the IP
     */
    address: string;
    /**
     * The ID of the IP
     */
    id: string;
}

export interface GetInstanceServerPrivateNetwork {
    /**
     * MAC address of the NIC
     */
    macAddress: string;
    /**
     * The Private Network ID
     */
    pnId: string;
    /**
     * The ID of the NIC
     */
    pnicId: string;
    /**
     * The private NIC state
     */
    status: string;
    /**
     * `zone`) The zone in which the server exists.
     */
    zone: string;
}

export interface GetInstanceServerPublicIp {
    /**
     * The address of the IP
     */
    address: string;
    /**
     * Whether the IP is dynamic
     */
    dynamic: boolean;
    /**
     * IP address family (inet or inet6)
     */
    family: string;
    /**
     * Gateway's IP address
     */
    gateway: string;
    /**
     * The ID of the IP
     */
    id: string;
    /**
     * CIDR netmask
     */
    netmask: string;
    /**
     * Provisioning mode of the IP address
     */
    provisioningMode: string;
}

export interface GetInstanceServerRootVolume {
    /**
     * Set the volume where the boot the server
     */
    boot: boolean;
    /**
     * Forces deletion of the root volume on instance termination.
     */
    deleteOnTermination: boolean;
    /**
     * The server name. Only one of `name` and `serverId` should be specified.
     */
    name: string;
    /**
     * SBS Volume IOPS, only with volumeType as sbs_volume
     */
    sbsIops: number;
    /**
     * Size of the root volume in gigabytes.
     */
    sizeInGb: number;
    /**
     * The volume ID of the root volume of the server.
     */
    volumeId: string;
    /**
     * Volume type of the root volume
     */
    volumeType: string;
}

export interface GetInstanceServersServer {
    /**
     * The boot Type of the server. Possible values are: `local`, `bootscript` or `rescue`.
     */
    bootType: string;
    /**
     * UUID of the bootscript
     *
     * @deprecated bootscript are not supported
     */
    bootscriptId: string;
    /**
     * If true a dynamic IP will be attached to the server.
     */
    enableDynamicIp: boolean;
    /**
     * Determines if IPv6 is enabled for the server.
     */
    enableIpv6: boolean;
    /**
     * The ID of the IP
     */
    id: string;
    /**
     * The UUID or the label of the base image used by the server.
     */
    image: string;
    /**
     * The default ipv6 address routed to the server. ( Only set when enableIpv6 is set to true )
     */
    ipv6Address: string;
    /**
     * The ipv6 gateway address. ( Only set when enableIpv6 is set to true )
     */
    ipv6Gateway: string;
    /**
     * The prefix length of the ipv6 subnet routed to the server. ( Only set when enableIpv6 is set to true )
     */
    ipv6PrefixLength: number;
    /**
     * The server name used as filter. Servers with a name like it are listed.
     */
    name: string;
    /**
     * The organization ID the server is associated with.
     */
    organizationId: string;
    /**
     * The [placement group](https://developers.scaleway.com/en/products/instance/api/#placement-groups-d8f653) the server is attached to.
     */
    placementGroupId: string;
    /**
     * Whether the placement group policy respected or not
     */
    placementGroupPolicyRespected: boolean;
    /**
     * The Scaleway internal IP address of the server.
     */
    privateIp: string;
    /**
     * The list of private IPv4 and IPv6 addresses associated with the server.
     */
    privateIps: outputs.GetInstanceServersServerPrivateIp[];
    /**
     * The ID of the project the server is associated with.
     */
    projectId: string;
    /**
     * The public IP address of the server.
     *
     * @deprecated Use publicIps instead
     */
    publicIp: string;
    /**
     * The list of public IPs of the server
     */
    publicIps: outputs.GetInstanceServersServerPublicIp[];
    /**
     * The [security group](https://developers.scaleway.com/en/products/instance/api/#security-groups-8d7f89) the server is attached to.
     */
    securityGroupId: string;
    /**
     * The state of the server. Possible values are: `started`, `stopped` or `standby`.
     */
    state: string;
    /**
     * List of tags used as filter. Servers with these exact tags are listed.
     */
    tags: string[];
    /**
     * The commercial type of the server.
     */
    type: string;
    /**
     * `zone`) The zone in which servers exist.
     */
    zone?: string;
}

export interface GetInstanceServersServerPrivateIp {
    /**
     * The address of the IP
     */
    address: string;
    /**
     * The ID of the IP
     */
    id: string;
}

export interface GetInstanceServersServerPublicIp {
    /**
     * The address of the IP
     */
    address: string;
    /**
     * The ID of the IP
     */
    id: string;
}

export interface GetInstanceSnapshotImport {
    /**
     * Bucket containing qcow
     */
    bucket: string;
    /**
     * Key of the qcow file in the specified bucket
     */
    key: string;
}

export interface GetIotDeviceCertificate {
    /**
     * X509 PEM encoded certificate of the device
     */
    crt: string;
    /**
     * X509 PEM encoded key of the device
     */
    key: string;
}

export interface GetIotDeviceMessageFilter {
    /**
     * Rule to restrict topics the device can publish to
     */
    publishes: outputs.GetIotDeviceMessageFilterPublish[];
    /**
     * Rule to restrict topics the device can subscribe to
     */
    subscribes: outputs.GetIotDeviceMessageFilterSubscribe[];
}

export interface GetIotDeviceMessageFilterPublish {
    /**
     * Publish message filter policy
     */
    policy: string;
    /**
     * List of topics in the set
     */
    topics: string[];
}

export interface GetIotDeviceMessageFilterSubscribe {
    /**
     * Subscribe message filter policy
     */
    policy: string;
    /**
     * List of topics in the set
     */
    topics: string[];
}

export interface GetIpamIpResource {
    /**
     * The ID of the resource that the IP is attached to.
     */
    id?: string;
    /**
     * The name of the resource the IP is attached to.
     */
    name?: string;
    /**
     * The type of the resource the IP is attached to. [Documentation](https://pkg.go.dev/github.com/scaleway/scaleway-sdk-go@master/api/ipam/v1#pkg-constants) with type list.
     */
    type: string;
}

export interface GetIpamIpsIp {
    /**
     * The Scaleway internal IP address of the resource.
     */
    address: string;
    /**
     * The date and time of the creation of the IP.
     */
    createdAt: string;
    /**
     * The ID of the resource.
     */
    id: string;
    /**
     * The ID of the Project to filter for.
     */
    projectId: string;
    /**
     * The region to filter for.
     */
    region: string;
    /**
     * Filter for a resource attached to the IP, using resource ID, type or name.
     */
    resources: outputs.GetIpamIpsIpResource[];
    /**
     * The IP tags to filter for.
     */
    tags: string[];
    /**
     * The date and time of the last update of the IP.
     */
    updatedAt: string;
    /**
     * The zone of the IP.
     */
    zone: string;
}

export interface GetIpamIpsIpResource {
    /**
     * The ID of the attached resource.
     */
    id: string;
    /**
     * The linked MAC address to filter for.
     */
    macAddress: string;
    /**
     * The name of the attached resource.
     */
    name: string;
    /**
     * The type of the attached resource. [Documentation](https://pkg.go.dev/github.com/scaleway/scaleway-sdk-go@master/api/ipam/v1#pkg-constants) with type list.
     */
    type: string;
}

export interface GetIpamIpsResource {
    /**
     * The ID of the attached resource.
     */
    id?: string;
    /**
     * The name of the attached resource.
     */
    name?: string;
    /**
     * The type of the attached resource. [Documentation](https://pkg.go.dev/github.com/scaleway/scaleway-sdk-go@master/api/ipam/v1#pkg-constants) with type list.
     */
    type: string;
}

export interface GetKubernetesClusterAutoUpgrade {
    /**
     * True if Kubernetes patch version auto upgrades is enabled.
     */
    enable: boolean;
    /**
     * The day of the auto upgrade maintenance window (`monday` to `sunday`, or `any`).
     */
    maintenanceWindowDay: string;
    /**
     * The start hour (UTC) of the 2-hour auto upgrade maintenance window (0 to 23).
     */
    maintenanceWindowStartHour: number;
}

export interface GetKubernetesClusterAutoscalerConfig {
    /**
     * True if detecting similar node groups and balance the number of nodes between them is enabled.
     */
    balanceSimilarNodeGroups: boolean;
    /**
     * True if the scale down feature of the autoscaler is disabled.
     */
    disableScaleDown: boolean;
    /**
     * The type of resource estimator used in scale up.
     */
    estimator: string;
    /**
     * The type of node group expander be used in scale up.
     */
    expander: string;
    /**
     * Pods with priority below cutoff will be expendable. They can be killed without any consideration during scale down and they don't cause scale up. Pods with null priority (PodPriority disabled) are non expendable.
     */
    expendablePodsPriorityCutoff: number;
    /**
     * True if ignoring DaemonSet pods when calculating resource utilization for scaling down is enabled.
     */
    ignoreDaemonsetsUtilization: boolean;
    /**
     * Maximum number of seconds the cluster autoscaler waits for pod termination when trying to scale down a node
     */
    maxGracefulTerminationSec: number;
    /**
     * The duration after scale up that scale down evaluation resumes.
     */
    scaleDownDelayAfterAdd: string;
    /**
     * The duration a node should be unneeded before it is eligible for scale down.
     */
    scaleDownUnneededTime: string;
    /**
     * Node utilization level, defined as sum of requested resources divided by capacity, below which a node can be considered for scale down
     */
    scaleDownUtilizationThreshold: number;
}

export interface GetKubernetesClusterKubeconfig {
    /**
     * The CA certificate of the Kubernetes API server.
     */
    clusterCaCertificate: string;
    /**
     * The raw kubeconfig file.
     */
    configFile: string;
    /**
     * The URL of the Kubernetes API server.
     */
    host: string;
    /**
     * The token to connect to the Kubernetes API server.
     */
    token: string;
}

export interface GetKubernetesClusterOpenIdConnectConfig {
    /**
     * A client id that all tokens must be issued for
     */
    clientId: string;
    /**
     * JWT claim to use as the user's group
     */
    groupsClaims: string[];
    /**
     * Prefix prepended to group claims
     */
    groupsPrefix: string;
    /**
     * URL of the provider which allows the API server to discover public signing keys
     */
    issuerUrl: string;
    /**
     * Multiple key=value pairs that describes a required claim in the ID Token
     */
    requiredClaims: string[];
    /**
     * JWT claim to use as the user name
     */
    usernameClaim: string;
    /**
     * Prefix prepended to username
     */
    usernamePrefix: string;
}

export interface GetKubernetesNodePoolNode {
    /**
     * The ID of the pool.
     */
    id: string;
    /**
     * The pool name. Only one of `name` and `poolId` should be specified. `clusterId` should be specified with `name`.
     */
    name: string;
    /**
     * List of private IPv4 and IPv6 addresses associated with the node
     */
    privateIps: outputs.GetKubernetesNodePoolNodePrivateIp[];
    /**
     * The public IPv4.
     */
    publicIp: string;
    /**
     * The public IPv6.
     */
    publicIpV6: string;
    /**
     * The status of the node.
     */
    status: string;
}

export interface GetKubernetesNodePoolNodePrivateIp {
    /**
     * The private IP address
     */
    address: string;
    /**
     * The ID of the pool.
     */
    id: string;
}

export interface GetKubernetesNodePoolUpgradePolicy {
    /**
     * The maximum number of nodes to be created during the upgrade
     */
    maxSurge: number;
    /**
     * The maximum number of nodes that can be not ready at the same time
     */
    maxUnavailable: number;
}

export interface GetLbAclsAcl {
    /**
     * The action to be undertaken when an ACL filter matches.
     */
    actions: outputs.GetLbAclsAclAction[];
    /**
     * The date on which the ACL was created (RFC 3339 format).
     */
    createdAt: string;
    /**
     * The description of the ACL resource.
     */
    description: string;
    /**
     * The frontend ID this ACL is attached to. ACLs with a matching frontend ID are listed.
     * > **Important:** LB frontend IDs are zoned, which means they are of the form `{zone}/{id}`, e.g. `fr-par-1/11111111-1111-1111-1111-111111111111`
     */
    frontendId: string;
    /**
     * The associated ACL ID.
     * > **Important:** LB ACLs' IDs are zoned, which means they are of the form `{zone}/{id}`, e.g. `fr-par-1/11111111-1111-1111-1111-111111111111`
     */
    id: string;
    /**
     * The priority of this ACL in the ordered list.
     */
    index: number;
    /**
     * The ACL match rule.
     */
    matches: outputs.GetLbAclsAclMatch[];
    /**
     * The ACL name to filter for. ACLs with a matching name are listed.
     */
    name: string;
    /**
     * The date on which the ACL was last updated (RFC 3339 format).
     */
    updateAt: string;
}

export interface GetLbAclsAclAction {
    /**
     * Redirect parameters when using an ACL with `redirect` action.
     */
    redirects: outputs.GetLbAclsAclActionRedirect[];
    /**
     * The redirect type.
     */
    type: string;
}

export interface GetLbAclsAclActionRedirect {
    /**
     * The HTTP redirect code to use.
     */
    code: number;
    /**
     * The URL used in case of a location redirect, or the scheme name that replaces the request's original scheme.
     */
    target: string;
    /**
     * The redirect type.
     */
    type: string;
}

export interface GetLbAclsAclMatch {
    /**
     * The HTTP filter to match.
     */
    httpFilter: string;
    /**
     * A list of possible values for the HTTP filter based on the HTTP header.
     */
    httpFilterOption: string;
    /**
     * The possible values to match for a given HTTP filter.
     */
    httpFilterValues: string[];
    /**
     * The condition will be of type "unless" if invert is set to `true`
     */
    invert: boolean;
    /**
     * A list of IPs, or CIDR v4/v6 addresses of the session client, to match.
     */
    ipSubnets: string[];
    /**
     * Defines whether Edge Services IPs should be matched.
     */
    ipsEdgeServices: boolean;
}

export interface GetLbBackendHealthCheckHttp {
    /**
     * The expected HTTP status code
     */
    code: number;
    /**
     * The HTTP host header to use for HC requests
     */
    hostHeader: string;
    /**
     * The HTTP method to use for HC requests
     */
    method: string;
    /**
     * The SNI to use for HC requests over SSL
     */
    sni: string;
    /**
     * The HTTPS endpoint URL to call for HC requests
     */
    uri: string;
}

export interface GetLbBackendHealthCheckTcp {
}

export interface GetLbBackendsBackend {
    /**
     * The date on which the backend was created (RFC 3339 format).
     */
    createdAt: string;
    /**
     * Scaleway S3 bucket website to be served if all backend servers are down.
     */
    failoverHost: string;
    /**
     * User sessions will be forwarded to this backend server port.
     */
    forwardPort: number;
    /**
     * Load balancing algorithm.
     */
    forwardPortAlgorithm: string;
    /**
     * Backend protocol.
     */
    forwardProtocol: string;
    /**
     * Interval between two health check requests.
     */
    healthCheckDelay: string;
    /**
     * This block enables HTTP health checks.
     */
    healthCheckHttp: outputs.GetLbBackendsBackendHealthCheckHttp[];
    /**
     * This block enables HTTPS health checks.
     */
    healthCheckHttps: outputs.GetLbBackendsBackendHealthCheckHttp[];
    /**
     * Number of allowed failed health check requests before the backend server is marked as down.
     */
    healthCheckMaxRetries: number;
    /**
     * Port the health check requests will be sent to.
     */
    healthCheckPort: number;
    /**
     * This block enables TCP health checks.
     */
    healthCheckTcps: outputs.GetLbBackendsBackendHealthCheckTcp[];
    /**
     * Timeout before a health check request is considered failed.
     */
    healthCheckTimeout: string;
    /**
     * The associated backend ID.
     */
    id: string;
    /**
     * Specifies whether the Load Balancer should check the backend serverâ€™s certificate before initiating a connection.
     */
    ignoreSslServerVerify: boolean;
    /**
     * The Load Balancer ID this backend is attached to. Backends with a matching ID are listed.
     */
    lbId: string;
    /**
     * The backend name to filter for. Backends with a matching name are listed.
     */
    name: string;
    /**
     * Modify what occurs when a backend server is marked down.
     */
    onMarkedDownAction: string;
    /**
     * The type of PROXY protocol.
     */
    proxyProtocol: string;
    /**
     * List of backend server IP addresses.
     */
    serverIps: string[];
    /**
     * Enables SSL between Load Balancer and backend servers.
     */
    sslBridging: boolean;
    /**
     * Enables cookie-based session persistence.
     */
    stickySessions: string;
    /**
     * Cookie name for sticky sessions.
     */
    stickySessionsCookieName: string;
    /**
     * Maximum initial server connection establishment time.
     */
    timeoutConnect: string;
    /**
     * Maximum server connection inactivity time.
     */
    timeoutServer: string;
    /**
     * Maximum tunnel inactivity time.
     */
    timeoutTunnel: string;
    /**
     * The date on which the backend was last updated (RFC 3339 format).
     */
    updateAt: string;
}

export interface GetLbBackendsBackendHealthCheckHttp {
    /**
     * The expected HTTP status code.
     */
    code: number;
    /**
     * The HTTP host header to use for health check requests.
     */
    hostHeader: string;
    /**
     * The HTTP method to use for health check requests.
     */
    method: string;
    /**
     * The SNI to use for HC requests over SSL.
     */
    sni: string;
    /**
     * The path of health check requests.
     */
    uri: string;
}

export interface GetLbBackendsBackendHealthCheckTcp {
}

export interface GetLbFrontendAcl {
    /**
     * Action to undertake when an ACL filter matches
     */
    actions: outputs.GetLbFrontendAclAction[];
    /**
     * IsDate and time of ACL's creation (RFC 3339 format)
     */
    createdAt: string;
    /**
     * Description of the ACL
     */
    description: string;
    /**
     * The ACL match rule
     */
    matches: outputs.GetLbFrontendAclMatch[];
    /**
     * The name of the frontend.
     * - When using the `name` you should specify the `lb-id`
     */
    name: string;
    /**
     * IsDate and time of ACL's update (RFC 3339 format)
     */
    updatedAt: string;
}

export interface GetLbFrontendAclAction {
    /**
     * Redirect parameters when using an ACL with `redirect` action
     */
    redirects: outputs.GetLbFrontendAclActionRedirect[];
    /**
     * The action type
     */
    type: string;
}

export interface GetLbFrontendAclActionRedirect {
    /**
     * The HTTP redirect code to use
     */
    code: number;
    /**
     * An URL can be used in case of a location redirect
     */
    target: string;
    /**
     * The redirect type
     */
    type: string;
}

export interface GetLbFrontendAclMatch {
    /**
     * The HTTP filter to match
     */
    httpFilter: string;
    /**
     * You can use this field with httpHeaderMatch acl type to set the header name to filter
     */
    httpFilterOption: string;
    /**
     * A list of possible values to match for the given HTTP filter
     */
    httpFilterValues: string[];
    /**
     * If set to true, the condition will be of type "unless"
     */
    invert: boolean;
    /**
     * A list of IPs or CIDR v4/v6 addresses of the client of the session to match
     */
    ipSubnets: string[];
    /**
     * Defines whether Edge Services IPs should be matched
     */
    ipsEdgeServices: boolean;
}

export interface GetLbFrontendsFrontend {
    /**
     * The Load Balancer backend ID this frontend is attached to.
     * > **Important:** Load Balancer backend IDs are zoned, which means they are of the form `{zone}/{id}`, e.g. `fr-par-1/11111111-1111-1111-1111-111111111111`
     */
    backendId: string;
    /**
     * List of certificate IDs that are used by the frontend.
     */
    certificateIds: string[];
    /**
     * The rate limit for new connections established on this frontend. Use 0 value to disable, else value is connections per second.
     */
    connectionRateLimit: number;
    /**
     * The date on which the frontend was created (RFC 3339 format).
     */
    createdAt: string;
    /**
     * Defines whether to enable access logs on the frontend.
     */
    enableAccessLogs: boolean;
    /**
     * Whether HTTP/3 protocol is activated.
     */
    enableHttp3: boolean;
    /**
     * The ID of the associated frontend.
     * > **Important:** LB frontend IDs are zoned, which means they are of the form `{zone}/{id}`, e.g. `fr-par-1/11111111-1111-1111-1111-111111111111`
     */
    id: string;
    /**
     * TCP port the frontend listens to.
     */
    inboundPort: number;
    /**
     * The Load Balancer ID this frontend is attached to. Frontends with a matching ID are listed.
     */
    lbId: string;
    /**
     * The frontend name to filter for. Frontends with a matching name are listed.
     */
    name: string;
    /**
     * Maximum inactivity time on the client side.
     */
    timeoutClient: string;
    /**
     * The date on which the frontend was last updated (RFC 3339 format).
     */
    updateAt: string;
}

export interface GetLbIpsIp {
    /**
     * The ID of the associated IP.
     */
    id: string;
    /**
     * The IP address
     */
    ipAddress: string;
    /**
     * The ID of the associated Load BalancerD, if any
     */
    lbId: string;
    /**
     * The ID of the Organization the Load Balancer is associated with.
     */
    organizationId: string;
    /**
     * The ID of the Project the Load Balancer is associated with.
     */
    projectId: string;
    /**
     * The reverse domain associated with this IP.
     */
    reverse: string;
    /**
     * List of tags used as filter. IPs with these exact tags are listed.
     */
    tags: string[];
    /**
     * `zone`) The zone in which the IPs exist.
     */
    zone?: string;
}

export interface GetLbRoutesRoute {
    /**
     * The backend ID to redirect to
     */
    backendId: string;
    /**
     * The date on which the route was created (RFC 3339 format).
     */
    createdAt: string;
    /**
     * The frontend ID (the origin of the redirection), to filter for. Routes with a matching frontend ID are listed.
     */
    frontendId: string;
    /**
     * The associated route ID.
     */
    id: string;
    /**
     * Specifies the host of the server to which the request is being sent.
     */
    matchHostHeader: string;
    /**
     * Server Name Indication TLS extension field from an incoming connection made via an SSL/TLS transport layer.
     */
    matchSni: string;
    /**
     * If true, all subdomains will match.
     */
    matchSubdomains: boolean;
    /**
     * The date on which the route was last updated (RFC 3339 format).
     */
    updateAt: string;
}

export interface GetLbsLb {
    /**
     * Number of backends the Load Balancer has.
     */
    backendCount: number;
    /**
     * Date on which the Load Balancer was created.
     */
    createdAt: string;
    /**
     * The description of the Load Balancer.
     */
    description: string;
    /**
     * Number of frontends the Load Balancer has.
     */
    frontendCount: number;
    /**
     * The ID of the Load Balancer.
     */
    id: string;
    /**
     * List of underlying Instances.
     */
    instances: outputs.GetLbsLbInstance[];
    /**
     * List of IPs attached to the Load Balancer.
     */
    ips: outputs.GetLbsLbIp[];
    /**
     * The Load Balancer name to filter for. Load Balancers with a matching name are listed.
     */
    name: string;
    /**
     * The ID of the Organization the Load Balancer is associated with.
     */
    organizationId: string;
    /**
     * Number of Private Networks attached to the Load balancer.
     */
    privateNetworkCount: number;
    /**
     * The ID of the Project the Load Balancer is associated with.
     */
    projectId: string;
    /**
     * Number of routes the Load balancer has.
     */
    routeCount: number;
    /**
     * Determines the minimal SSL version which needs to be supported on the client side.
     */
    sslCompatibilityLevel: string;
    /**
     * The state of the Load Balancer Instance. Possible values are: `unknown`, `ready`, `pending`, `stopped`, `error`, `locked` and `migrating`.
     */
    status: string;
    /**
     * The subscriber information.
     */
    subscriber: string;
    /**
     * List of tags to filter for. Load Balancers with these exact tags are listed.
     */
    tags: string[];
    /**
     * The offer type of the Load Balancer.
     */
    type: string;
    /**
     * Date on which the Load Balancer was updated.
     */
    updatedAt: string;
    /**
     * `zone`) The zone in which the Load Balancers exist.
     */
    zone?: string;
}

export interface GetLbsLbInstance {
    /**
     * Date on which the Load Balancer was created.
     */
    createdAt: string;
    /**
     * The ID of the Load Balancer.
     */
    id: string;
    /**
     * IP address of the instance
     */
    ipAddress: string;
    /**
     * The state of the Load Balancer Instance. Possible values are: `unknown`, `ready`, `pending`, `stopped`, `error`, `locked` and `migrating`.
     */
    status: string;
    /**
     * Date on which the Load Balancer was updated.
     */
    updatedAt: string;
    /**
     * `zone`) The zone in which the Load Balancers exist.
     */
    zone?: string;
}

export interface GetLbsLbIp {
    /**
     * The ID of the Load Balancer.
     */
    id: string;
    /**
     * IP address
     */
    ipAddress: string;
    /**
     * UUID of the load balancer attached to the IP
     */
    lbId: string;
    /**
     * The ID of the Organization the Load Balancer is associated with.
     */
    organizationId: string;
    /**
     * The ID of the Project the Load Balancer is associated with.
     */
    projectId: string;
    /**
     * Reverse DNS attached to the IP
     */
    reverse: string;
    /**
     * `zone`) The zone in which the Load Balancers exist.
     */
    zone?: string;
}

export interface GetLoadbalancerCertificateCustomCertificate {
    /**
     * The full PEM-formatted certificate chain
     */
    certificateChain: string;
}

export interface GetLoadbalancerCertificateLetsencrypt {
    /**
     * The main domain name of the certificate
     */
    commonName: string;
    /**
     * The alternative domain names of the certificate
     */
    subjectAlternativeNames: string[];
}

export interface GetLoadbalancerPrivateIp {
    /**
     * The private IP address
     */
    address: string;
    /**
     * The ID of the Load Balancer.
     */
    id: string;
}

export interface GetLoadbalancerPrivateNetwork {
    /**
     * Set to true if you want to let DHCP assign IP addresses
     */
    dhcpConfig: boolean;
    /**
     * IPAM ID of a pre-reserved IP address to assign to the Load Balancer on this Private Network
     */
    ipamIds: string[];
    /**
     * The Private Network ID
     */
    privateNetworkId: string;
    /**
     * Define an IP address in the subnet of your private network that will be assigned to your load balancer instance
     */
    staticConfigs: string[];
    /**
     * The status of private network connection
     */
    status: string;
    /**
     * (Defaults to provider `zone`) The zone in which the Load Balancer exists.
     */
    zone: string;
}

export interface GetMongoDbInstancePrivateIp {
    /**
     * The private IPv4 address
     */
    address: string;
    /**
     * The ID of the MongoDBÂ® Instance.
     */
    id: string;
}

export interface GetMongoDbInstancePrivateNetwork {
    /**
     * List of DNS records for your endpoint
     */
    dnsRecords: string[];
    /**
     * The ID of the MongoDBÂ® Instance.
     */
    id: string;
    /**
     * List of IP addresses for your endpoint
     */
    ips: string[];
    /**
     * The private network ID
     */
    pnId: string;
    /**
     * TCP port of the endpoint
     */
    port: number;
}

export interface GetMongoDbInstancePublicNetwork {
    /**
     * The DNS record of your endpoint
     */
    dnsRecord: string;
    /**
     * The ID of the MongoDBÂ® Instance.
     */
    id: string;
    /**
     * TCP port of the endpoint
     */
    port: number;
}

export interface GetObjectBucketCorsRule {
    /**
     * Allowed headers in the CORS rule
     */
    allowedHeaders: string[];
    /**
     * Allowed HTTP methods allowed in the CORS rule
     */
    allowedMethods: string[];
    /**
     * Allowed origins allowed in the CORS rule
     */
    allowedOrigins: string[];
    /**
     * Exposed headers in the CORS rule
     */
    exposeHeaders: string[];
    /**
     * Max age of the CORS rule
     */
    maxAgeSeconds: number;
}

export interface GetObjectBucketLifecycleRule {
    /**
     * Specifies the number of days after initiating a multipart upload when the multipart upload must be completed
     */
    abortIncompleteMultipartUploadDays: number;
    /**
     * Specifies if the configuration rule is Enabled or Disabled
     */
    enabled: boolean;
    /**
     * Specifies a period in the object's expire
     */
    expirations: outputs.GetObjectBucketLifecycleRuleExpiration[];
    /**
     * The unique identifier of the bucket.
     */
    id: string;
    /**
     * The prefix identifying one or more objects to which the rule applies
     */
    prefix: string;
    /**
     * The tags associated with the bucket lifecycle
     */
    tags: {[key: string]: string};
    /**
     * Define when objects transition to another storage class
     */
    transitions: outputs.GetObjectBucketLifecycleRuleTransition[];
}

export interface GetObjectBucketLifecycleRuleExpiration {
    /**
     * Specifies the number of days after object creation when the specific rule action takes effect
     */
    days: number;
}

export interface GetObjectBucketLifecycleRuleTransition {
    /**
     * Specifies the number of days after object creation when the specific rule action takes effect
     */
    days: number;
    /**
     * Specifies the Scaleway Object Storage class to which you want the object to transition
     */
    storageClass: string;
}

export interface GetObjectBucketVersioning {
    /**
     * Enable versioning. Once you version-enable a bucket, it can never return to an unversioned state
     */
    enabled: boolean;
}

export interface GetRedisClusterAcl {
    /**
     * Description of the rule.
     */
    description: string;
    /**
     * The ID of the Redis cluster.
     */
    id: string;
    /**
     * IPv4 network address of the rule (IP network in a CIDR format).
     */
    ip: string;
}

export interface GetRedisClusterPrivateIp {
    /**
     * The private IPv4 address
     */
    address: string;
    /**
     * The ID of the Redis cluster.
     */
    id: string;
}

export interface GetRedisClusterPrivateNetwork {
    /**
     * The ID of the endpoint.
     */
    endpointId: string;
    /**
     * The ID of the Redis cluster.
     */
    id: string;
    /**
     * List of IPv4 addresses of the endpoint.
     */
    ips: string[];
    /**
     * TCP port of the endpoint.
     */
    port: number;
    /**
     * List of IPv4 addresses of the private network with a CIDR notation
     */
    serviceIps: string[];
    /**
     * `region`) The zone in which the server exists.
     */
    zone: string;
}

export interface GetRedisClusterPublicNetwork {
    /**
     * The ID of the Redis cluster.
     */
    id: string;
    /**
     * List of IPv4 addresses of the endpoint.
     */
    ips: string[];
    /**
     * TCP port of the endpoint.
     */
    port: number;
}

export interface GetSecretEphemeralPolicy {
    /**
     * Action to perform when the version of a secret expires.
     */
    action: string;
    /**
     * True if the secret version expires after a single user access.
     */
    expiresOnceAccessed: boolean;
    /**
     * Time frame, from one second and up to one year, during which the secret's versions are valid. Has to be specified in Go Duration format
     */
    ttl: string;
}

export interface GetSecretVersion {
    /**
     * Date and time of secret version's creation (RFC 3339 format)
     */
    createdAt: string;
    /**
     * Description of the secret version
     */
    description: string;
    /**
     * Returns true if the version is the latest.
     */
    latest: boolean;
    /**
     * The revision of secret version
     */
    revision: string;
    /**
     * The ID of the secret.
     * Only one of `name` and `secretId` should be specified.
     */
    secretId: string;
    /**
     * Status of the secret version
     */
    status: string;
    /**
     * Date and time of secret version's creation (RFC 3339 format)
     */
    updatedAt: string;
}

export interface GetTemDomainReputation {
    /**
     * The previously-calculated domain's reputation score
     */
    previousScore: number;
    /**
     * Time and date the previous reputation score was calculated
     */
    previousScoredAt: string;
    /**
     * A range from 0 to 100 that determines your domain's reputation score
     */
    score: number;
    /**
     * Time and date the score was calculated
     */
    scoredAt: string;
    /**
     * Status of the domain's reputation
     */
    status: string;
}

export interface GetVpcGatewayNetworkIpamConfig {
    /**
     * Use this IPAM-booked IP ID as the Gateway's IP in this Private Network
     */
    ipamIpId: string;
    /**
     * Defines whether the default route is enabled on that Gateway Network
     */
    pushDefaultRoute: boolean;
}

export interface GetVpcGatewayNetworkPrivateIp {
    /**
     * The private IPv4 address.
     */
    address: string;
    /**
     * The ID of the IPv4 address resource.
     */
    id: string;
}

export interface GetVpcPrivateNetworkIpv4Subnet {
    /**
     * The network address of the subnet in dotted decimal notation, e.g., '192.168.0.0' for a '192.168.0.0/24' subnet
     */
    address: string;
    /**
     * The date and time of the creation of the subnet
     */
    createdAt: string;
    /**
     * The ID of the Private Network.
     */
    id: string;
    /**
     * The length of the network prefix, e.g., 24 for a 255.255.255.0 mask
     */
    prefixLength: number;
    /**
     * The subnet CIDR
     */
    subnet: string;
    /**
     * The subnet mask expressed in dotted decimal notation, e.g., '255.255.255.0' for a /24 subnet
     */
    subnetMask: string;
    /**
     * The date and time of the last update of the subnet
     */
    updatedAt: string;
}

export interface GetVpcPrivateNetworkIpv6Subnet {
    /**
     * The network address of the subnet in dotted decimal notation, e.g., '192.168.0.0' for a '192.168.0.0/24' subnet
     */
    address: string;
    /**
     * The date and time of the creation of the subnet
     */
    createdAt: string;
    /**
     * The ID of the Private Network.
     */
    id: string;
    /**
     * The length of the network prefix, e.g., 24 for a 255.255.255.0 mask
     */
    prefixLength: number;
    /**
     * The subnet CIDR
     */
    subnet: string;
    /**
     * The subnet mask expressed in dotted decimal notation, e.g., '255.255.255.0' for a /24 subnet
     */
    subnetMask: string;
    /**
     * The date and time of the last update of the subnet
     */
    updatedAt: string;
}

export interface GetVpcRoutesRoute {
    /**
     * The date on which the route was created (RFC 3339 format).
     */
    createdAt: string;
    /**
     * The description of the route.
     */
    description: string;
    /**
     * The destination IP or IP range of the route.
     */
    destination: string;
    /**
     * The ID of the route.
     * > **Important:** route IDs are regional, which means they are of the form `{region}/{id}`, e.g. `fr-par/11111111-1111-1111-1111-111111111111
     */
    id: string;
    /**
     * The IP of the route's next hop.
     */
    nexthopIp: string;
    /**
     * The name of the route's next hop.
     */
    nexthopName: string;
    /**
     * The next hop private network ID to filter for. routes with a similar next hop private network ID are listed.
     */
    nexthopPrivateNetworkId: string;
    /**
     * The next hop resource ID to filter for. routes with a similar next hop resource ID are listed.
     */
    nexthopResourceId: string;
    /**
     * The next hop resource type to filter for. routes with a similar next hop resource type are listed.
     */
    nexthopResourceType: string;
    /**
     * `region`). The region in which the routes exist.
     */
    region?: string;
    /**
     * List of tags to filter for. routes with these exact tags are listed.
     */
    tags: string[];
    /**
     * The VPC ID to filter for. routes with a similar VPC ID are listed.
     */
    vpcId: string;
}

export interface GetVpcsVpc {
    /**
     * Date and time of VPC's creation (RFC 3339 format).
     */
    createdAt: string;
    /**
     * The associated VPC ID.
     * > **Important:** VPC IDs are regional, which means they are of the form `{region}/{id}`, e.g. `fr-par/11111111-1111-1111-1111-111111111111
     */
    id: string;
    /**
     * Defines whether the VPC is the default one for its Project.
     */
    isDefault: boolean;
    /**
     * The VPC name to filter for. VPCs with a similar name are listed.
     */
    name: string;
    /**
     * The Organization ID the VPC is associated with.
     */
    organizationId: string;
    /**
     * The ID of the Project the VPC is associated with.
     */
    projectId: string;
    /**
     * `region`). The region in which the VPCs exist.
     */
    region?: string;
    /**
     * List of tags to filter for. VPCs with these exact tags are listed.
     */
    tags: string[];
    /**
     * Date on which the VPC was last updated (RFC 3339 format)
     */
    updateAt: string;
}

export interface GetWebHostOfferOffer {
    /**
     * Indicates if the offer is available.
     */
    available: boolean;
    /**
     * The billing operation identifier for the option.
     */
    billingOperationPath: string;
    /**
     * The name of the control panel (e.g., Cpanel or Plesk).
     */
    controlPanelName: string;
    /**
     * Indicates if the offer is deprecated or no longer supported.
     */
    endOfLife: boolean;
    /**
     * The unique identifier of the option.
     */
    id: string;
    /**
     * The offer name. Only one of `name` and `offerId` should be specified.
     */
    name: string;
    /**
     * A list of available options for the offer:
     */
    options: outputs.GetWebHostOfferOfferOption[];
    /**
     * The offer price.
     */
    price: string;
    /**
     * Warning information regarding quota limitations for the option.
     */
    quotaWarning: string;
}

export interface GetWebHostOfferOfferOption {
    /**
     * The billing operation identifier for the option.
     */
    billingOperationPath: string;
    /**
     * The current value set for the option.
     */
    currentValue: number;
    /**
     * The unique identifier of the option.
     */
    id: string;
    /**
     * The maximum allowed value for the option.
     */
    maxValue: number;
    /**
     * The minimum value for the option.
     */
    minValue: number;
    /**
     * The offer name. Only one of `name` and `offerId` should be specified.
     */
    name: string;
    /**
     * The offer price.
     */
    price: string;
    /**
     * Warning information regarding quota limitations for the option.
     */
    quotaWarning: string;
}

export interface GetWebHostOfferProduct {
    /**
     * The quota of databases.
     */
    databasesQuota: number;
    /**
     * The quota of email accounts.
     */
    emailAccountsQuota: number;
    /**
     * The quota of email storage.
     */
    emailStorageQuota: number;
    /**
     * The quota of hosting storage.
     */
    hostingStorageQuota: number;
    /**
     * The offer name. Only one of `name` and `offerId` should be specified.
     */
    name: string;
    /**
     * The product option.
     */
    option: boolean;
    /**
     * The capacity of the memory in GB.
     */
    ram: number;
    /**
     * If support is included.
     */
    supportIncluded: boolean;
    /**
     * The number of cores.
     */
    vCpu: number;
}

export interface GetWebhostingCpanelUrl {
    /**
     * URL to connect to dashboard interface
     */
    dashboard: string;
    /**
     * URL to connect to Webmail interface
     */
    webmail: string;
}

export interface GetWebhostingNameServer {
    /**
     * Hostname of the server
     */
    hostname: string;
    /**
     * Whether or not the webhosting is the default one
     */
    isDefault: boolean;
    /**
     * Status of the nameserver
     */
    status: string;
}

export interface GetWebhostingOption {
    /**
     * ID of the active option
     */
    id: string;
    /**
     * Name of the option
     */
    name: string;
}

export interface GetWebhostingRecord {
    /**
     * Name of the DNS record
     */
    name: string;
    /**
     * Priority of DNS records associated with the webhosting.
     */
    priority: number;
    /**
     * Status of the hosting record
     */
    status: string;
    /**
     * Time to live in seconds of the record
     */
    ttl: number;
    /**
     * Type of the DNS record
     */
    type: string;
    /**
     * Value of the DNS record
     */
    value: string;
}

export interface IamPolicyRule {
    /**
     * The condition of the rule.
     *
     * **_TIP:_** You can use the Scaleway CLI to list the permissions details. e.g:
     *
     * ```shell
     * scw iam permission-set list
     * ```
     */
    condition?: string;
    /**
     * ID of organization scoped to the rule, this can be used to create a rule for all projects in an organization.
     */
    organizationId?: string;
    /**
     * Names of permission sets bind to the rule.
     */
    permissionSetNames: string[];
    /**
     * List of project IDs scoped to the rule.
     *
     * > **Important** One `organizationId` or `projectIds` must be set per rule.
     */
    projectIds?: string[];
}

export interface InferenceDeploymentPrivateEndpoint {
    /**
     * Disable the authentication on the endpoint.
     */
    disableAuth?: boolean;
    /**
     * (Optional) The id of the public endpoint.
     */
    id: string;
    /**
     * The ID of the private network to use.
     */
    privateNetworkId?: string;
    /**
     * (Optional) The URL of the endpoint.
     */
    url: string;
}

export interface InferenceDeploymentPrivateIp {
    /**
     * The private IPv4 address.
     */
    address: string;
    /**
     * (Optional) The id of the public endpoint.
     */
    id: string;
}

export interface InferenceDeploymentPublicEndpoint {
    /**
     * Disable the authentication on the endpoint.
     */
    disableAuth?: boolean;
    /**
     * (Optional) The id of the public endpoint.
     */
    id: string;
    /**
     * Enable or disable public endpoint.
     */
    isEnabled?: boolean;
    /**
     * (Optional) The URL of the endpoint.
     */
    url: string;
}

export interface InstanceImageAdditionalVolume {
    /**
     * ID of the server containing the volume.
     */
    id: string;
    /**
     * The name of the image. If not provided it will be randomly generated.
     */
    name: string;
    /**
     * Description of the server containing the volume (in case the image is a backup from a server).
     */
    server: {[key: string]: string};
    /**
     * The size of the volume.
     */
    size: number;
    /**
     * A list of tags to apply to the image.
     */
    tags: string[];
    /**
     * The type of volume, possible values are `lSsd` and `sbsSnapshot`.
     */
    volumeType: string;
}

export interface InstanceImageRootVolume {
    /**
     * ID of the server containing the volume.
     */
    id: string;
    /**
     * The name of the image. If not provided it will be randomly generated.
     */
    name: string;
    /**
     * The size of the volume.
     */
    size: number;
    /**
     * The type of volume, possible values are `lSsd` and `sbsSnapshot`.
     */
    volumeType: string;
}

export interface InstancePrivateNicPrivateIp {
    /**
     * The private IP address.
     */
    address: string;
    /**
     * The ID of the IP address resource.
     */
    id: string;
}

export interface InstanceSecurityGroupInboundRule {
    /**
     * The action to take when rule match. Possible values are: `accept` or `drop`.
     */
    action: string;
    /**
     * The ip this rule apply to. If no `ip` nor `ipRange` are specified, rule will apply to all ip. Only one of `ip` and `ipRange` should be specified.
     *
     * @deprecated Ip address is deprecated. Please use ipRange instead
     */
    ip?: string;
    /**
     * The ip range (e.g `192.168.1.0/24`) this rule applies to. If no `ip` nor `ipRange` are specified, rule will apply to all ip. Only one of `ip` and `ipRange` should be specified.
     */
    ipRange?: string;
    /**
     * The port this rule applies to. If no `port` nor `portRange` are specified, the rule will apply to all port. Only one of `port` and `portRange` should be specified.
     */
    port?: number;
    /**
     * Computed port range for this rule (e.g: 1-1024, 22-22)
     */
    portRange?: string;
    /**
     * The protocol this rule apply to. Possible values are: `TCP`, `UDP`, `ICMP` or `ANY`.
     */
    protocol?: string;
}

export interface InstanceSecurityGroupOutboundRule {
    /**
     * Action when rule match request (drop or accept)
     */
    action: string;
    /**
     * Ip address for this rule (e.g: 1.1.1.1). Only one of ip or ipRange should be provided
     *
     * @deprecated Ip address is deprecated. Please use ipRange instead
     */
    ip?: string;
    /**
     * Ip range for this rule (e.g: 192.168.1.0/24). Only one of ip or ipRange should be provided
     */
    ipRange?: string;
    /**
     * Network port for this rule
     */
    port?: number;
    /**
     * Computed port range for this rule (e.g: 1-1024, 22-22)
     */
    portRange?: string;
    /**
     * Protocol for this rule (TCP, UDP, ICMP or ANY)
     */
    protocol?: string;
}

export interface InstanceSecurityGroupRulesInboundRule {
    /**
     * The action to take when rule match. Possible values are: `accept` or `drop`.
     */
    action: string;
    /**
     * The ip this rule apply to. If no `ip` nor `ipRange` are specified, rule will apply to all ip. Only one of `ip` and `ipRange` should be specified.
     *
     * @deprecated Ip address is deprecated. Please use ipRange instead
     */
    ip?: string;
    /**
     * The ip range (e.g `192.168.1.0/24`) this rule applies to. If no `ip` nor `ipRange` are specified, rule will apply to all ip. Only one of `ip` and `ipRange` should be specified.
     */
    ipRange?: string;
    /**
     * The port this rule apply to. If no port is specified, rule will apply to all port.
     */
    port?: number;
    /**
     * Computed port range for this rule (e.g: 1-1024, 22-22)
     */
    portRange?: string;
    /**
     * The protocol this rule apply to. Possible values are: `TCP`, `UDP`, `ICMP` or `ANY`.
     */
    protocol?: string;
}

export interface InstanceSecurityGroupRulesOutboundRule {
    /**
     * Action when rule match request (drop or accept)
     */
    action: string;
    /**
     * Ip address for this rule (e.g: 1.1.1.1). Only one of ip or ipRange should be provided
     *
     * @deprecated Ip address is deprecated. Please use ipRange instead
     */
    ip?: string;
    /**
     * Ip range for this rule (e.g: 192.168.1.0/24). Only one of ip or ipRange should be provided
     */
    ipRange?: string;
    /**
     * Network port for this rule
     */
    port?: number;
    /**
     * Computed port range for this rule (e.g: 1-1024, 22-22)
     */
    portRange?: string;
    /**
     * Protocol for this rule (TCP, UDP, ICMP or ANY)
     */
    protocol?: string;
}

export interface InstanceServerPrivateIp {
    /**
     * The private IP address.
     */
    address: string;
    /**
     * The ID of the IP address resource.
     */
    id: string;
}

export interface InstanceServerPrivateNetwork {
    /**
     * MAC address of the NIC
     */
    macAddress: string;
    /**
     * The Private Network ID
     */
    pnId: string;
    /**
     * The ID of the NIC
     */
    pnicId: string;
    /**
     * The private NIC state
     */
    status: string;
    /**
     * `zone`) The zone in which the server should be created.
     */
    zone?: string;
}

export interface InstanceServerPublicIp {
    /**
     * The address of the IP.
     */
    address: string;
    /**
     * Whether the IP is dynamic.
     */
    dynamic: boolean;
    /**
     * The IP address' family.
     */
    family: string;
    /**
     * The IP of the Gateway associated with the IP.
     */
    gateway: string;
    /**
     * The ID of the IP.
     */
    id: string;
    /**
     * The CIDR netmask of the IP.
     */
    netmask: string;
    /**
     * The provisioning mode of the IP
     */
    provisioningMode: string;
}

export interface InstanceServerRootVolume {
    /**
     * Set the volume where the boot the server
     */
    boot?: boolean;
    /**
     * Forces deletion of the root volume on instance termination.
     */
    deleteOnTermination?: boolean;
    /**
     * The name of the server.
     */
    name: string;
    /**
     * Choose IOPS of your sbs volume, has to be used with `sbsVolume` for root volume type.
     *
     * > **Important:** Updates to `root_volume.size_in_gb` will be ignored after the creation of the server.
     */
    sbsIops: number;
    /**
     * Size of the root volume in gigabytes.
     * To find the right size use [this endpoint](https://www.scaleway.com/en/developers/api/instance/#path-instances-list-all-instances) and
     * check the `volumes_constraint.{min|max}_size` (in bytes) for your `commercialType`.
     * Depending on `volumeType`, updates to this field may recreate a new resource.
     */
    sizeInGb: number;
    /**
     * The volume ID of the root volume of the server, allows you to create server with an existing volume. If empty, will be computed to a created volume ID.
     */
    volumeId: string;
    /**
     * Volume type of root volume, can be `lSsd` or `sbsVolume`, default value depends on server type
     */
    volumeType: string;
}

export interface InstanceSnapshotImport {
    /**
     * Bucket name containing [qcow2](https://en.wikipedia.org/wiki/Qcow) to import
     */
    bucket: string;
    /**
     * Key of the object to import
     */
    key: string;
}

export interface IotDeviceCertificate {
    /**
     * X509 PEM encoded certificate of the device
     */
    crt: string;
    /**
     * The private key of the device, in case it is generated by Scaleway.
     */
    key: string;
}

export interface IotDeviceMessageFilters {
    /**
     * Rules used to restrict topics the device can publish to.
     */
    publish?: outputs.IotDeviceMessageFiltersPublish;
    /**
     * Rules used to restrict topics the device can subscribe to.
     */
    subscribe?: outputs.IotDeviceMessageFiltersSubscribe;
}

export interface IotDeviceMessageFiltersPublish {
    /**
     * Filtering policy (eg `accept` or `reject`)
     */
    policy?: string;
    /**
     * List of topics to match (eg `foo/bar/+/baz/#`)
     */
    topics?: string[];
}

export interface IotDeviceMessageFiltersSubscribe {
    /**
     * Same as publish rules.
     */
    policy?: string;
    /**
     * Same as publish rules.
     *
     * - `certificate.crt` - (Optional) The certificate of the device, either generated by Scaleway or provided.
     *
     * > **Important:** Updates to `certificate.crt` will disconnect connected devices and the previous certificate will be deleted and won't be recoverable.
     */
    topics?: string[];
}

export interface IotRouteDatabase {
    /**
     * The database name (e.g. `measurements`).
     */
    dbname: string;
    /**
     * The database hostname. Can be an IP or a FQDN.
     */
    host: string;
    /**
     * The database password.
     */
    password: string;
    /**
     * The database port (e.g. `5432`)
     */
    port: number;
    /**
     * The SQL query that will be executed when receiving a message ($TOPIC and $PAYLOAD variables are available, see documentation, e.g. `INSERT INTO mytable(date, topic, value) VALUES (NOW(), $TOPIC, $PAYLOAD)`).
     */
    query: string;
    /**
     * The database username.
     */
    username: string;
}

export interface IotRouteRest {
    /**
     * a map of the extra headers to send with the HTTP call (e.g. `X-Header = Value`).
     */
    headers: {[key: string]: string};
    /**
     * The URI of the Rest endpoint (e.g. `https://internal.mycompany.com/ingest/mqttdata`).
     */
    uri: string;
    /**
     * The HTTP Verb used to call Rest URI (e.g. `post`).
     */
    verb: string;
}

export interface IotRouteS3 {
    /**
     * The name of the S3 route's destination bucket (e.g. `my-object-storage`).
     */
    bucketName: string;
    /**
     * The region of the S3 route's destination bucket (e.g. `fr-par`).
     */
    bucketRegion: string;
    /**
     * The string to prefix object names with (e.g. `mykeyprefix-`).
     */
    objectPrefix?: string;
    /**
     * How the S3 route's objects will be created (e.g. `perTopic`). See [documentation](https://www.scaleway.com/en/docs/iot-hub/how-to/create-route/) for behaviour details.
     */
    strategy: string;
}

export interface IpamIpCustomResource {
    /**
     * The MAC address of the resource the IP is attached to.
     */
    macAddress: string;
    /**
     * The name of the resource the IP is attached to.
     */
    name?: string;
}

export interface IpamIpResource {
    /**
     * The ID of the resource that the IP is attached to.
     */
    id: string;
    /**
     * The MAC address of the resource the IP is attached to.
     */
    macAddress: string;
    /**
     * The name of the resource the IP is attached to.
     */
    name: string;
    /**
     * The type of resource the IP is attached to.
     */
    type: string;
}

export interface IpamIpReverse {
    /**
     * The IP corresponding to the hostname
     */
    address: string;
    /**
     * The reverse domain name.
     */
    hostname: string;
}

export interface IpamIpSource {
    /**
     * The Private Network of the IP (if the IP is a private IP).
     */
    privateNetworkId: string;
    /**
     * The Private Network subnet of the IP (if the IP is a private IP).
     */
    subnetId: string;
    /**
     * The zone of the IP (if the IP is public and zoned, rather than private and/or regional)
     */
    zonal: string;
}

export interface JobDefinitionCron {
    /**
     * Cron format string.
     */
    schedule: string;
    /**
     * The timezone, must be a canonical TZ identifier as found in this [list](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones).
     */
    timezone: string;
}

export interface JobDefinitionSecretReference {
    /**
     * An environment variable containing the secret value. Must be specified if `file` is not specified.
     */
    environment?: string;
    /**
     * The absolute file path where the secret will be mounted. Must be specified if `environment` is not specified.
     */
    file?: string;
    /**
     * The secret unique identifier, it could be formatted as region/UUID or UUID. In case the region is passed, it must be the same as the job definition. You could reference the same secret multiple times in the same job definition.
     */
    secretId: string;
    /**
     * The secret reference UUID that is automatically generated by the provider.
     */
    secretReferenceId: string;
    /**
     * The secret version.
     */
    secretVersion?: string;
}

export interface KeyManagerKeyRotationPolicy {
    /**
     * The date and time of the next scheduled rotation.
     */
    nextRotationAt?: string;
    /**
     * â€“ The period between key rotations (e.g., `"720h"` for 30 days).
     */
    rotationPeriod: string;
}

export interface KubernetesClusterAutoUpgrade {
    /**
     * Set to `true` to enable Kubernetes patch version auto upgrades.
     * > **Important:** When enabling auto upgrades, the `version` field take a minor version like x.y (ie 1.18).
     */
    enable: boolean;
    /**
     * The day of the auto upgrade maintenance window (`monday` to `sunday`, or `any`).
     */
    maintenanceWindowDay: string;
    /**
     * The start hour (UTC) of the 2-hour auto upgrade maintenance window (0 to 23).
     */
    maintenanceWindowStartHour: number;
}

export interface KubernetesClusterAutoscalerConfig {
    /**
     * Detect similar node groups and balance the number of nodes between them.
     */
    balanceSimilarNodeGroups?: boolean;
    /**
     * Disables the scale down feature of the autoscaler.
     */
    disableScaleDown?: boolean;
    /**
     * Type of resource estimator to be used in scale up.
     */
    estimator?: string;
    /**
     * Type of node group expander to be used in scale up.
     */
    expander?: string;
    /**
     * Pods with priority below cutoff will be expendable. They can be killed without any consideration during scale down and they don't cause scale up. Pods with null priority (PodPriority disabled) are non expendable.
     */
    expendablePodsPriorityCutoff?: number;
    /**
     * Ignore DaemonSet pods when calculating resource utilization for scaling down.
     */
    ignoreDaemonsetsUtilization?: boolean;
    /**
     * Maximum number of seconds the cluster autoscaler waits for pod termination when trying to scale down a node
     */
    maxGracefulTerminationSec?: number;
    /**
     * How long after scale up that scale down evaluation resumes.
     */
    scaleDownDelayAfterAdd?: string;
    /**
     * How long a node should be unneeded before it is eligible for scale down.
     */
    scaleDownUnneededTime?: string;
    /**
     * Node utilization level, defined as sum of requested resources divided by capacity, below which a node can be considered for scale down
     */
    scaleDownUtilizationThreshold?: number;
}

export interface KubernetesClusterKubeconfig {
    /**
     * The CA certificate of the Kubernetes API server.
     */
    clusterCaCertificate: string;
    /**
     * The raw kubeconfig file.
     */
    configFile: string;
    /**
     * The URL of the Kubernetes API server.
     */
    host: string;
    /**
     * The token to connect to the Kubernetes API server.
     */
    token: string;
}

export interface KubernetesClusterOpenIdConnectConfig {
    /**
     * A client id that all tokens must be issued for
     */
    clientId: string;
    /**
     * JWT claim to use as the user's group
     */
    groupsClaims?: string[];
    /**
     * Prefix prepended to group claims
     */
    groupsPrefix?: string;
    /**
     * URL of the provider which allows the API server to discover public signing keys
     */
    issuerUrl: string;
    /**
     * Multiple key=value pairs that describes a required claim in the ID Token
     */
    requiredClaims?: string[];
    /**
     * JWT claim to use as the user name
     */
    usernameClaim?: string;
    /**
     * Prefix prepended to username
     */
    usernamePrefix?: string;
}

export interface KubernetesNodePoolNode {
    /**
     * The ID of the IP address resource.
     */
    id: string;
    /**
     * The name for the pool.
     *
     * > **Important:** Updates to this field will recreate a new resource.
     */
    name: string;
    /**
     * The list of private IPv4 and IPv6 addresses associated with the node.
     */
    privateIps: outputs.KubernetesNodePoolNodePrivateIp[];
    /**
     * The public IPv4. (Deprecated, Please use the official Kubernetes provider and the kubernetesNodes data source)
     *
     * @deprecated Please use the official Kubernetes provider and the kubernetesNodes data source
     */
    publicIp: string;
    /**
     * The public IPv6. (Deprecated, Please use the official Kubernetes provider and the kubernetesNodes data source)
     *
     * @deprecated Please use the official Kubernetes provider and the kubernetesNodes data source
     */
    publicIpV6: string;
    /**
     * The status of the node.
     */
    status: string;
}

export interface KubernetesNodePoolNodePrivateIp {
    /**
     * The private IP address.
     */
    address: string;
    /**
     * The ID of the IP address resource.
     */
    id: string;
}

export interface KubernetesNodePoolUpgradePolicy {
    /**
     * The maximum number of nodes to be created during the upgrade
     */
    maxSurge?: number;
    /**
     * The maximum number of nodes that can be not ready at the same time
     */
    maxUnavailable?: number;
}

export interface LoadbalancerAclAction {
    /**
     * Redirect parameters when using an ACL with `redirect` action.
     */
    redirects?: outputs.LoadbalancerAclActionRedirect[];
    /**
     * The action type. Possible values are: `allow` or `deny` or `redirect`.
     */
    type: string;
}

export interface LoadbalancerAclActionRedirect {
    /**
     * The HTTP redirect code to use. Valid values are `301`, `302`, `303`, `307` and `308`.
     */
    code?: number;
    /**
     * An URL can be used in case of a location redirect (e.g. `https://scaleway.com` will redirect to this same URL). A scheme name (e.g. `https`, `http`, `ftp`, `git`) will replace the request's original scheme.
     */
    target?: string;
    /**
     * The redirect type. Possible values are: `location` or `scheme`.
     */
    type?: string;
}

export interface LoadbalancerAclMatch {
    /**
     * The HTTP filter to match. This filter is supported only if your backend protocol has an HTTP forward protocol.
     * It extracts the request's URL path, which starts at the first slash and ends before the question mark (without the host part).
     * Possible values are: `aclHttpFilterNone`, `pathBegin`, `pathEnd`, `httpHeaderMatch` or `regex`.
     */
    httpFilter?: string;
    /**
     * If you have `httpFilter` at `httpHeaderMatch`, you can use this field to filter on the HTTP header's value.
     */
    httpFilterOption?: string;
    /**
     * A list of possible values to match for the given HTTP filter.
     * Keep in mind that in the case of `httpHeaderMatch` the HTTP header field name is case insensitive.
     */
    httpFilterValues?: string[];
    /**
     * If set to `true`, the condition will be of type "unless".
     */
    invert?: boolean;
    /**
     * A list of IPs, or CIDR v4/v6 addresses of the session client, to match. Only one of `ipSubnet` and `ipsEdgeServices` should be specified.
     */
    ipSubnets?: string[];
    /**
     * Defines whether Edge Services IPs should be matched. Only one of `ipSubnet` and `ipsEdgeServices` should be specified.
     */
    ipsEdgeServices?: boolean;
}

export interface LoadbalancerBackendHealthCheckHttp {
    /**
     * The expected HTTP status code
     */
    code?: number;
    /**
     * The HTTP host header to use for HC requests
     */
    hostHeader?: string;
    /**
     * The HTTP method to use for HC requests
     */
    method?: string;
    /**
     * The HTTP endpoint URL to call for HC requests
     */
    uri: string;
}

export interface LoadbalancerBackendHealthCheckHttps {
    /**
     * The expected HTTP status code
     */
    code?: number;
    /**
     * The HTTP host header to use for HC requests
     */
    hostHeader?: string;
    /**
     * The HTTP method to use for HC requests
     */
    method?: string;
    /**
     * The SNI to use for HC requests over SSL
     */
    sni?: string;
    /**
     * The HTTPS endpoint URL to call for HC requests
     */
    uri: string;
}

export interface LoadbalancerBackendHealthCheckTcp {
}

export interface LoadbalancerCertificateCustomCertificate {
    /**
     * The full PEM-formatted certificate chain
     */
    certificateChain: string;
}

export interface LoadbalancerCertificateLetsencrypt {
    /**
     * Main domain of the certificate
     */
    commonName: string;
    /**
     * The alternative domain names of the certificate
     */
    subjectAlternativeNames?: string[];
}

export interface LoadbalancerFrontendAcl {
    /**
     * Action to undertake when an ACL filter matches.
     */
    action: outputs.LoadbalancerFrontendAclAction;
    /**
     * The date and time the frontend was created.
     */
    createdAt: string;
    /**
     * Description of the ACL
     */
    description?: string;
    /**
     * The ACL match rule. At least `ipSubnet` or `ipsEdgeServices` or `httpFilter` and `httpFilterValue` are required.
     */
    match: outputs.LoadbalancerFrontendAclMatch;
    /**
     * The ACL name. If not provided it will be randomly generated.
     */
    name: string;
    /**
     * The date and time the frontend resource was updated.
     */
    updatedAt: string;
}

export interface LoadbalancerFrontendAclAction {
    /**
     * Redirect parameters when using an ACL with `redirect` action.
     */
    redirects?: outputs.LoadbalancerFrontendAclActionRedirect[];
    /**
     * The action type. Possible values are: `allow` or `deny` or `redirect`.
     */
    type: string;
}

export interface LoadbalancerFrontendAclActionRedirect {
    /**
     * The HTTP redirect code to use. Valid values are `301`, `302`, `303`, `307` and `308`.
     */
    code?: number;
    /**
     * A URL can be used in case of a location redirect (e.g. `https://scaleway.com` will redirect to this same URL). A scheme name (e.g. `https`, `http`, `ftp`, `git`) will replace the request's original scheme.
     */
    target?: string;
    /**
     * The redirect type. Possible values are: `location` or `scheme`.
     */
    type?: string;
}

export interface LoadbalancerFrontendAclMatch {
    /**
     * The HTTP filter to match. This filter is supported only if your backend protocol has an HTTP forward protocol.
     * It extracts the request's URL path, which starts at the first slash and ends before the question mark (without the host part).
     * Possible values are: `aclHttpFilterNone`, `pathBegin`, `pathEnd`, `httpHeaderMatch` or `regex`.
     */
    httpFilter?: string;
    /**
     * If you have `httpFilter` at `httpHeaderMatch`, you can use this field to filter on the HTTP header's value.
     */
    httpFilterOption?: string;
    /**
     * A list of possible values to match for the given HTTP filter.
     * Keep in mind that in the case of `httpHeaderMatch` the HTTP header field name is case insensitive.
     */
    httpFilterValues?: string[];
    /**
     * If set to `true`, the condition will be of type "unless".
     */
    invert?: boolean;
    /**
     * A list of IPs, or CIDR v4/v6 addresses of the session client, to match. Only one of `ipSubnet` and `ipsEdgeServices` should be specified.
     */
    ipSubnets?: string[];
    /**
     * Defines whether Edge Services IPs should be matched. Only one of `ipSubnet` and `ipsEdgeServices` should be specified.
     */
    ipsEdgeServices?: boolean;
}

export interface LoadbalancerPrivateIp {
    /**
     * The private IP address.
     */
    address: string;
    /**
     * The ID of the IP address resource.
     */
    id: string;
}

export interface LoadbalancerPrivateNetwork {
    /**
     * Set to true if you want to let DHCP assign IP addresses
     *
     * @deprecated dhcp_config field is deprecated, please use `privateNetworkId` or `ipamIds` instead
     */
    dhcpConfig: boolean;
    /**
     * IPAM ID of a pre-reserved IP address to assign to the Load Balancer on this Private Network.
     */
    ipamIds: string;
    /**
     * The ID of the Private Network to attach to.
     * - > **Important:** Updates to `privateNetwork` will recreate the attachment.
     */
    privateNetworkId: string;
    /**
     * Define an IP address in the subnet of your private network that will be assigned to your load balancer instance
     *
     * @deprecated static_config field is deprecated, please use `privateNetworkId` or `ipamIds` instead
     */
    staticConfigs: string[];
    /**
     * The status of the private network connection.
     */
    status: string;
    /**
     * `zone`) The zone of the Load Balancer.
     */
    zone: string;
}

export interface MnqSnsCredentialsPermissions {
    /**
     * . Defines whether the user can manage the associated resource(s).
     */
    canManage: boolean;
    /**
     * . Defines whether the user can publish messages to the service.
     */
    canPublish: boolean;
    /**
     * . Defines whether the user can receive messages from the service.
     */
    canReceive: boolean;
}

export interface MnqSqsCredentialsPermissions {
    /**
     * . Defines whether the user can manage the associated resource(s).
     */
    canManage: boolean;
    /**
     * . Defines whether the user can publish messages to the service.
     */
    canPublish: boolean;
    /**
     * . Defines whether the user can receive messages from the service.
     */
    canReceive: boolean;
}

export interface MnqSqsQueueDeadLetterQueue {
    /**
     * The ID of the queue with format `{region/{project-id}/{queue-name}`
     */
    id: string;
    /**
     * The number of times a message is delivered to the source queue before being sent to the dead-letter queue. Must be between 1 and 1,000.
     */
    maxReceiveCount: number;
}

export interface MongoDbInstancePrivateIp {
    /**
     * The private IPv4 address.
     */
    address: string;
    /**
     * The ID of the endpoint.
     */
    id: string;
}

export interface MongoDbInstancePrivateNetwork {
    /**
     * List of DNS records for your endpoint.
     */
    dnsRecords: string[];
    /**
     * The ID of the endpoint.
     */
    id: string;
    /**
     * List of IP addresses for your endpoint.
     */
    ips: string[];
    /**
     * The ID of the Private Network.
     */
    pnId: string;
    /**
     * TCP port of the endpoint.
     */
    port: number;
}

export interface MongoDbInstancePublicNetwork {
    /**
     * The DNS record of your endpoint
     */
    dnsRecord: string;
    /**
     * The ID of the endpoint.
     */
    id: string;
    /**
     * TCP port of the endpoint.
     */
    port: number;
}

export interface ObjectBucketAclAccessControlPolicy {
    /**
     * Grant
     */
    grants?: outputs.ObjectBucketAclAccessControlPolicyGrant[];
    /**
     * Configuration block of the bucket project owner's display organization ID.
     */
    owner: outputs.ObjectBucketAclAccessControlPolicyOwner;
}

export interface ObjectBucketAclAccessControlPolicyGrant {
    /**
     * Configuration block for the project being granted permissions.
     */
    grantee?: outputs.ObjectBucketAclAccessControlPolicyGrantGrantee;
    /**
     * Logging permissions assigned to the grantee for the bucket.
     */
    permission: string;
}

export interface ObjectBucketAclAccessControlPolicyGrantGrantee {
    /**
     * Display name of the grantee to grant access to.
     */
    displayName: string;
    /**
     * The `region`, `bucket` and `acl` separated by (`/`).
     */
    id?: string;
    /**
     * Type of grantee. Valid values: `CanonicalUser`, `Group`
     */
    type?: string;
    /**
     * The uri of the grantee if you are granting permissions to a predefined group.
     */
    uri?: string;
}

export interface ObjectBucketAclAccessControlPolicyOwner {
    /**
     * The project ID of the grantee.
     */
    displayName: string;
    /**
     * The `region`, `bucket` and `acl` separated by (`/`).
     */
    id: string;
}

export interface ObjectBucketCorsRule {
    /**
     * Specifies which headers are allowed.
     */
    allowedHeaders?: string[];
    /**
     * Specifies which methods are allowed (`GET`, `PUT`, `POST`, `DELETE` or `HEAD`).
     */
    allowedMethods: string[];
    /**
     * Specifies which origins are allowed.
     */
    allowedOrigins: string[];
    /**
     * Specifies header exposure in the response.
     */
    exposeHeaders?: string[];
    /**
     * Specifies time in seconds that the browser can cache the response for a preflight request.
     */
    maxAgeSeconds?: number;
}

export interface ObjectBucketLifecycleRule {
    /**
     * Specifies the number of days after initiating a multipart upload when the multipart upload must be completed.
     *
     * > **Important:** Avoid using `prefix` for `AbortIncompleteMultipartUpload`, as any incomplete multipart upload will be billed
     */
    abortIncompleteMultipartUploadDays?: number;
    /**
     * The element value can be either Enabled or Disabled. If a rule is disabled, Scaleway Object Storage does not perform any of the actions defined in the rule.
     */
    enabled: boolean;
    /**
     * Specifies a period in the object's expire
     */
    expiration?: outputs.ObjectBucketLifecycleRuleExpiration;
    /**
     * Unique identifier for the rule. Must be less than or equal to 255 characters in length.
     */
    id: string;
    /**
     * Object key prefix identifying one or more objects to which the rule applies.
     */
    prefix?: string;
    /**
     * Specifies object tags key and value.
     */
    tags?: {[key: string]: string};
    /**
     * Define when objects transition to another storage class
     */
    transitions?: outputs.ObjectBucketLifecycleRuleTransition[];
}

export interface ObjectBucketLifecycleRuleExpiration {
    /**
     * Specifies the number of days after object creation when the specific rule action takes effect.
     */
    days: number;
}

export interface ObjectBucketLifecycleRuleTransition {
    /**
     * Specifies the number of days after object creation when the specific rule action takes effect.
     */
    days?: number;
    /**
     * Specifies the Scaleway [storage class](https://www.scaleway.com/en/docs/object-storage/concepts/#storage-class) `STANDARD`, `GLACIER`, `ONEZONE_IA`  to which you want the object to transition.
     *
     *
     * > **Important:**  If versioning is enabled, this rule only deletes the current version of an object.
     * > **Important:**  If versioning is enabled, this rule only deletes the current version of an object.
     *
     *
     * > **Important:**  `ONEZONE_IA` is only available in `fr-par` region. The storage class `GLACIER` is not available in `pl-waw` region.
     * > **Important:**  `ONEZONE_IA` is only available in `fr-par` region. The storage class `GLACIER` is not available in `pl-waw` region.
     */
    storageClass: string;
}

export interface ObjectBucketLockConfigurationRule {
    /**
     * The default retention for the lock.
     */
    defaultRetention: outputs.ObjectBucketLockConfigurationRuleDefaultRetention;
}

export interface ObjectBucketLockConfigurationRuleDefaultRetention {
    /**
     * The number of days you want to specify for the default retention period.
     */
    days?: number;
    /**
     * The default object lock retention mode you want to apply to new objects placed in the specified bucket. Valid values are `GOVERNANCE` or `COMPLIANCE`. Refer to the [dedicated documentation](https://www.scaleway.com/en/docs/object-storage/api-cli/object-lock/#retention-modes) for more information on retention modes.
     */
    mode: string;
    /**
     * The number of years you want to specify for the default retention period.
     */
    years?: number;
}

export interface ObjectBucketVersioning {
    /**
     * Enable versioning. Once you version-enable a bucket, it can never return to an unversioned state. You can, however, suspend versioning on that bucket.
     */
    enabled: boolean;
}

export interface ObjectBucketWebsiteConfigurationErrorDocument {
    /**
     * The object key name to use when a 4XX class error occurs.
     */
    key: string;
}

export interface ObjectBucketWebsiteConfigurationIndexDocument {
    /**
     * A suffix that is appended to a request targeting a specific directory on the website endpoint.
     *
     * > **Important:** The suffix must not be empty and must not include a slash character. The routing is not supported.
     */
    suffix: string;
}

export interface RedisClusterAcl {
    /**
     * A text describing this rule. Default description: `Allow IP`
     *
     * > The `acl` conflict with `privateNetwork`. Only one should be specified.
     */
    description: string;
    /**
     * The ID of the IPv4 address resource.
     */
    id: string;
    /**
     * The IP range to whitelist
     * in [CIDR notation](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#CIDR_notation)
     */
    ip: string;
}

export interface RedisClusterPrivateIp {
    /**
     * The private IPv4 address.
     */
    address: string;
    /**
     * The ID of the IPv4 address resource.
     */
    id: string;
}

export interface RedisClusterPrivateNetwork {
    /**
     * The ID of the endpoint.
     */
    endpointId: string;
    /**
     * The UUID of the Private Network resource.
     */
    id: string;
    /**
     * List of IPv4 addresses of the endpoint.
     */
    ips: string[];
    /**
     * TCP port of the endpoint.
     */
    port: number;
    /**
     * Endpoint IPv4 addresses in [CIDR notation](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#CIDR_notation). You must provide at least one IP per node.
     * Keep in mind that in cluster mode you cannot edit your Private Network after its creation so if you want to be able to
     * scale your cluster horizontally (adding nodes) later, you should provide more IPs than nodes.
     * If not set, the IP network address within the private subnet is determined by the IP Address Management (IPAM) service.
     * > **Important:** When IPAM is enabled, the IPs specified here will be ignored and should not be provided.
     *
     * > The `privateNetwork` conflicts with `acl`. Only one should be specified.
     *
     * > **Important:** The way to use Private Networks differs whether you are using Redisâ„¢ in Standalone or cluster mode.
     *
     * - Standalone mode (`clusterSize` = 1) : you can attach as many Private Networks as you want (each must be a separate
     * block). If you detach your only Private Network, your cluster won't be reachable until you define a new Private or
     * Public Network. You can modify your `privateNetwork` and its specs, you can have both a Private and Public Network side
     * by side.
     *
     * - Cluster mode (`clusterSize` > 2) : you can define a single Private Network as you create your cluster, you won't be
     * able to edit or detach it afterward, unless you create another cluster. This also means that, if you are using a static
     * configuration (`serviceIps`), you won't be able to scale your cluster horizontally (add more nodes) since it would
     * require updating the Private Network to add IPs.
     * Your `serviceIps` must be listed as follows:
     */
    serviceIps: string[];
    /**
     * `zone`) The zone in which the
     * Redisâ„¢ cluster should be created.
     */
    zone: string;
}

export interface RedisClusterPublicNetwork {
    /**
     * The ID of the IPv4 address resource.
     */
    id: string;
    /**
     * List of IPv4 addresses of the endpoint.
     */
    ips: string[];
    /**
     * TCP port of the endpoint.
     */
    port: number;
}

export interface SecretEphemeralPolicy {
    /**
     * Action to perform when the version of a secret expires. Available values can be found in [SDK constants](https://pkg.go.dev/github.com/scaleway/scaleway-sdk-go@master/api/secret/v1beta1#pkg-constants).
     */
    action: string;
    /**
     * True if the secret version expires after a single user access.
     */
    expiresOnceAccessed?: boolean;
    /**
     * Time frame, from one second and up to one year, during which the secret's versions are valid. Has to be specified in [Go Duration format](https://pkg.go.dev/time#ParseDuration) (ex: "30m", "24h").
     */
    ttl?: string;
}

export interface SecretVersion {
    /**
     * Date and time of the secret's creation (in RFC 3339 format).
     */
    createdAt: string;
    /**
     * Description of the secret (e.g. `my-new-description`).
     */
    description?: string;
    /**
     * Returns true if the version is the latest.
     */
    latest?: boolean;
    /**
     * The revision of secret version
     */
    revision: string;
    /**
     * The secret ID associated with this version
     */
    secretId: string;
    /**
     * The status of the secret.
     */
    status: string;
    /**
     * Date and time of the secret's last update (in RFC 3339 format).
     */
    updatedAt: string;
}

export interface TemDomainReputation {
    /**
     * The previously-calculated domain's reputation score.
     */
    previousScore: number;
    /**
     * The time and date the previous reputation score was calculated.
     */
    previousScoredAt: string;
    /**
     * A range from 0 to 100 that determines your domain's reputation score.
     */
    score: number;
    /**
     * The time and date the score was calculated.
     */
    scoredAt: string;
    /**
     * The status of the domain's reputation.
     */
    status: string;
}

export interface VpcGatewayNetworkIpamConfig {
    /**
     * Use this IPAM-booked IP ID as the Gateway's IP in this Private Network.
     */
    ipamIpId: string;
    /**
     * Defines whether to enable the default route on the GatewayNetwork.
     */
    pushDefaultRoute?: boolean;
}

export interface VpcGatewayNetworkPrivateIp {
    /**
     * The private IPv4 address.
     */
    address: string;
    /**
     * The ID of the IPv4 address resource.
     */
    id: string;
}

export interface VpcPrivateNetworkIpv4Subnet {
    /**
     * The network address of the subnet in hexadecimal notation, e.g., '2001:db8::' for a '2001:db8::/64' subnet.
     */
    address: string;
    /**
     * The date and time of the creation of the subnet.
     */
    createdAt: string;
    /**
     * The subnet ID.
     */
    id: string;
    /**
     * The length of the network prefix, e.g., 64 for a 'ffff:ffff:ffff:ffff::' mask.
     */
    prefixLength: number;
    /**
     * The subnet CIDR.
     */
    subnet: string;
    /**
     * The subnet mask expressed in dotted decimal notation, e.g., '255.255.255.0' for a /24 subnet
     */
    subnetMask: string;
    /**
     * The date and time of the last update of the subnet.
     */
    updatedAt: string;
}

export interface VpcPrivateNetworkIpv6Subnet {
    /**
     * The network address of the subnet in hexadecimal notation, e.g., '2001:db8::' for a '2001:db8::/64' subnet.
     */
    address: string;
    /**
     * The date and time of the creation of the subnet.
     */
    createdAt: string;
    /**
     * The subnet ID.
     */
    id: string;
    /**
     * The length of the network prefix, e.g., 64 for a 'ffff:ffff:ffff:ffff::' mask.
     */
    prefixLength: number;
    /**
     * The subnet CIDR.
     */
    subnet: string;
    /**
     * The subnet mask expressed in dotted decimal notation, e.g., '255.255.255.0' for a /24 subnet
     */
    subnetMask: string;
    /**
     * The date and time of the last update of the subnet.
     */
    updatedAt: string;
}

export interface WebhostingCpanelUrl {
    /**
     * The URL of the Dashboard.
     */
    dashboard: string;
    /**
     * The URL of the Webmail interface.
     */
    webmail: string;
}

export interface WebhostingNameServer {
    /**
     * Hostname of the server
     */
    hostname: string;
    /**
     * Whether or not the webhosting is the default one
     */
    isDefault: boolean;
    /**
     * The hosting status.
     */
    status: string;
}

export interface WebhostingOption {
    /**
     * The option ID.
     */
    id: string;
    /**
     * The option name.
     */
    name: string;
}

export interface WebhostingRecord {
    /**
     * The option name.
     */
    name: string;
    /**
     * Priority of DNS records associated with the webhosting.
     */
    priority: number;
    /**
     * The hosting status.
     */
    status: string;
    /**
     * Time to live in seconds of the record
     */
    ttl: number;
    /**
     * Type of the DNS record
     */
    type: string;
    /**
     * Value of the DNS record
     */
    value: string;
}

export namespace account {
    export interface GetProjectsProject {
        /**
         * (Computed) The date and time when the project was created.
         */
        createdAt: string;
        /**
         * (Computed) The description of the project.
         */
        description: string;
        /**
         * (Computed) The unique identifier of the project.
         */
        id: string;
        /**
         * (Computed) The name of the project.
         */
        name: string;
        /**
         * The unique identifier of the Organization with which the Projects are associated.
         * If no default `organizationId` is set, one must be set explicitly in this datasource
         */
        organizationId: string;
        /**
         * (Computed) The date and time when the project was updated.
         */
        updatedAt: string;
    }

}

export namespace applesilicon {
    export interface ServerPrivateIp {
        /**
         * The private IP address.
         */
        address: string;
        /**
         * The ID of the IP address resource.
         */
        id: string;
    }

    export interface ServerPrivateNetwork {
        /**
         * The date and time the private network was created.
         */
        createdAt: string;
        /**
         * The private network ID
         */
        id: string;
        /**
         * A list of IPAM IP IDs to attach to the server.
         */
        ipamIpIds: string[];
        /**
         * The current status of the private network.
         */
        status: string;
        /**
         * The date and time the private network was last updated.
         */
        updatedAt: string;
        /**
         * The VLAN ID associated with the private network.
         */
        vlan: number;
    }

}

export namespace autoscaling {
    export interface InstanceGroupCapacity {
        /**
         * Time (in seconds) after a scaling action during which requests to carry out a new scaling action will be denied.
         */
        cooldownDelay?: number;
        /**
         * The maximum count of Instances for the Instance group.
         */
        maxReplicas?: number;
        /**
         * The minimum count of Instances for the Instance group.
         */
        minReplicas?: number;
    }

    export interface InstanceGroupLoadBalancer {
        /**
         * The Load Balancer backend IDs.
         */
        backendIds?: string[];
        /**
         * The ID of the Load Balancer.
         */
        id?: string;
        /**
         * The ID of the Private Network attached to the Load Balancer.
         */
        privateNetworkId?: string;
    }

    export interface InstancePolicyMetric {
        /**
         * How the values sampled for the `metric` should be aggregated.
         */
        aggregate: string;
        /**
         * The custom metric to use for this policy. This must be stored in Scaleway Cockpit. The metric forms the basis of the condition that will be checked to determine whether a scaling action should be triggered
         */
        cockpitMetricName?: string;
        /**
         * The managed metric to use for this policy. These are available by default in Cockpit without any configuration or `nodeExporter`. The chosen metric forms the basis of the condition that will be checked to determine whether a scaling action should be triggered.
         */
        managedMetric?: string;
        /**
         * Name or description of the metric policy.
         */
        name: string;
        /**
         * Operator used when comparing the threshold value of the chosen `metric` to the actual sampled and aggregated value.
         */
        operator: string;
        /**
         * The Interval of time, in minutes, during which metric is sampled.
         */
        samplingRangeMin?: number;
        /**
         * The threshold value to measure the aggregated sampled `metric` value against. Combined with the `operator` field, determines whether a scaling action should be triggered.
         */
        threshold?: number;
    }

    export interface InstanceTemplateVolume {
        /**
         * Force the Instance to boot on this volume.
         */
        boot?: boolean;
        /**
         * Volume instance template from empty
         */
        fromEmpty?: outputs.autoscaling.InstanceTemplateVolumeFromEmpty;
        /**
         * Volume instance template from snapshot
         */
        fromSnapshot?: outputs.autoscaling.InstanceTemplateVolumeFromSnapshot;
        /**
         * The name of the volume.
         */
        name: string;
        /**
         * The maximum IO/s expected, according to the different options available in stock (`5000 | 15000`).
         */
        perfIops?: number;
        /**
         * The list of tags assigned to the volume.
         */
        tags?: string[];
        /**
         * The type of the volume.
         */
        volumeType: string;
    }

    export interface InstanceTemplateVolumeFromEmpty {
        /**
         * Size in GB of the new empty volume
         */
        size: number;
    }

    export interface InstanceTemplateVolumeFromSnapshot {
        /**
         * Override size (in GB) of the cloned volume
         */
        size?: number;
        /**
         * ID of the snapshot to clone
         */
        snapshotId: string;
    }

}

export namespace billing {
    export interface GetConsumptionsConsumption {
        /**
         * The consumed quantity.
         */
        billedQuantity: string;
        /**
         * The name of the consumption category.
         */
        categoryName: string;
        /**
         * The product name.
         */
        productName: string;
        /**
         * `projectId`) The ID of the project the consumption list is associated with.
         */
        projectId: string;
        /**
         * The unique identifier of the product.
         */
        sku: string;
        /**
         * The unit of consumed quantity.
         */
        unit: string;
        /**
         * The monetary value of the consumption.
         */
        value: string;
    }

    export interface GetInvoicesInvoice {
        /**
         * The billing period of the invoice in the YYYY-MM format.
         */
        billingPeriod: string;
        /**
         * The payment time limit, set according to the Organization's payment conditions (RFC 3339 format).
         */
        dueDate: string;
        /**
         * The associated invoice ID.
         */
        id: string;
        /**
         * Invoices with the given type are listed. Valid values are `periodic` and `purchase`.
         */
        invoiceType: string;
        /**
         * The date when the invoice was sent to the customer (RFC 3339 format).
         */
        issuedDate: string;
        /**
         * The invoice number.
         */
        number: number;
        /**
         * The organization name.
         */
        organizationName: string;
        /**
         * The name of the seller (Scaleway).
         */
        sellerName: string;
        /**
         * The start date of the billing period (RFC 3339 format).
         */
        startDate: string;
        /**
         * The state of the invoice.
         */
        state: string;
        /**
         * The end date of the billing period (RFC 3339 format).
         */
        stopDate: string;
        /**
         * The total discount amount of the invoice.
         */
        totalDiscount: string;
        /**
         * The total tax amount of the invoice.
         */
        totalTax: string;
        /**
         * The total amount, taxed.
         */
        totalTaxed: string;
        /**
         * The total amount of the invoice before applying the discount.
         */
        totalUndiscount: string;
        /**
         * The total amount, untaxed.
         */
        totalUntaxed: string;
    }

}

export namespace block {
    export interface GetSnapshotExport {
        /**
         * Bucket containing qcow
         */
        bucket: string;
        /**
         * Key of the qcow file in the specified bucket
         */
        key: string;
    }

    export interface GetSnapshotImport {
        /**
         * Bucket containing qcow
         */
        bucket: string;
        /**
         * Key of the qcow file in the specified bucket
         */
        key: string;
    }

    export interface SnapshotExport {
        /**
         * The name of the bucket where the QCOW file will be saved.
         */
        bucket: string;
        /**
         * The desired key (path) for the QCOW file within the bucket.
         */
        key: string;
    }

    export interface SnapshotImport {
        /**
         * The name of the bucket containing the QCOW file.
         */
        bucket: string;
        /**
         * The key of the QCOW file within the bucket.
         */
        key: string;
    }

}

export namespace containers {
    export interface ContainerHealthCheck {
        /**
         * Number of consecutive health check failures before considering the container unhealthy.
         */
        failureThreshold: number;
        /**
         * HTTP health check configuration.
         */
        https: outputs.containers.ContainerHealthCheckHttp[];
        /**
         * Period between health checks (in seconds).
         */
        interval: string;
    }

    export interface ContainerHealthCheckHttp {
        /**
         * Path to use for the HTTP health check.
         */
        path: string;
    }

    export interface ContainerScalingOption {
        /**
         * Scale depending on the number of concurrent requests being processed per container instance.
         */
        concurrentRequestsThreshold?: number;
        /**
         * Scale depending on the CPU usage of a container instance.
         */
        cpuUsageThreshold?: number;
        /**
         * Scale depending on the memory usage of a container instance.
         */
        memoryUsageThreshold?: number;
    }

    export interface GetContainerHealthCheck {
        /**
         * Number of consecutive health check failures before considering the container unhealthy.
         */
        failureThreshold: number;
        /**
         * HTTP health check configuration.
         */
        https: outputs.containers.GetContainerHealthCheckHttp[];
        /**
         * Period between health checks (in seconds).
         */
        interval: string;
    }

    export interface GetContainerHealthCheckHttp {
        /**
         * Path to use for the HTTP health check.
         */
        path: string;
    }

    export interface GetContainerScalingOption {
        /**
         * Scale depending on the number of concurrent requests being processed per container instance.
         */
        concurrentRequestsThreshold: number;
        /**
         * Scale depending on the CPU usage of a container instance.
         */
        cpuUsageThreshold: number;
        /**
         * Scale depending on the memory usage of a container instance.
         */
        memoryUsageThreshold: number;
    }

    export interface TriggerNats {
        /**
         * unique identifier of the Messaging and Queuing NATS account.
         */
        accountId?: string;
        /**
         * THe ID of the project that contains the Messaging and Queuing NATS account (defaults to provider `projectId`)
         */
        projectId: string;
        /**
         * Region where the Messaging and Queuing NATS account is enabled (defaults to provider `region`)
         */
        region: string;
        /**
         * The subject to listen to.
         */
        subject: string;
    }

    export interface TriggerSqs {
        /**
         * ID of the Messaging and Queuing namespace. This argument is deprecated.
         *
         * @deprecated The 'namespace_id' field is deprecated and will be removed in the next major version. It is no longer necessary to specify it
         */
        namespaceId?: string;
        /**
         * The ID of the project in which SQS is enabled, (defaults to provider `projectId`)
         */
        projectId: string;
        /**
         * The name of the SQS queue.
         */
        queue: string;
        /**
         * Region where SQS is enabled (defaults to provider `region`)
         */
        region: string;
    }

}

export namespace databases {
    export interface AclAclRule {
        /**
         * A text describing this rule. Default description: `IP allowed`
         */
        description: string;
        /**
         * The IP range to whitelist in [CIDR notation](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#CIDR_notation)
         */
        ip: string;
    }

    export interface GetAclAclRule {
        /**
         * A simple text describing this rule
         */
        description: string;
        /**
         * The ip range to whitelist in [CIDR notation](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#CIDR_notation)
         */
        ip: string;
    }

    export interface GetInstanceLoadBalancer {
        /**
         * The endpoint ID
         */
        endpointId: string;
        /**
         * The hostname of your endpoint
         */
        hostname: string;
        /**
         * The IP of your load balancer service
         */
        ip: string;
        /**
         * The name of the RDB instance.
         */
        name: string;
        /**
         * The port of your load balancer service
         */
        port: number;
    }

    export interface GetInstanceLogsPolicy {
        /**
         * The max age (in days) of remote logs to keep on the Database Instance
         */
        maxAgeRetention: number;
        /**
         * The max disk size of remote logs to keep on the Database Instance.
         */
        totalDiskRetention: number;
    }

    export interface GetInstancePrivateIp {
        /**
         * The private IPv4 address
         */
        address: string;
        /**
         * The ID of the Database Instance.
         */
        id: string;
    }

    export interface GetInstancePrivateNetwork {
        /**
         * Whether or not the private network endpoint should be configured with IPAM
         */
        enableIpam: boolean;
        /**
         * The endpoint ID
         */
        endpointId: string;
        /**
         * The hostname of your endpoint
         */
        hostname: string;
        /**
         * The IP of your Instance within the private service
         */
        ip: string;
        /**
         * The IP with the given mask within the private subnet
         */
        ipNet: string;
        /**
         * The name of the RDB instance.
         */
        name: string;
        /**
         * The private network ID
         */
        pnId: string;
        /**
         * The port of your private service
         */
        port: number;
        /**
         * The zone you want to attach the resource to
         */
        zone: string;
    }

    export interface GetInstanceReadReplica {
        /**
         * IP of the replica
         */
        ip: string;
        /**
         * The name of the RDB instance.
         */
        name: string;
        /**
         * Port of the replica
         */
        port: number;
    }

    export interface InstanceLoadBalancer {
        /**
         * The ID of the endpoint.
         */
        endpointId: string;
        /**
         * Hostname of the endpoint.
         */
        hostname: string;
        /**
         * IPv4 address on the network.
         */
        ip: string;
        /**
         * The name of the Database Instance.
         */
        name: string;
        /**
         * Port in the Private Network.
         */
        port: number;
    }

    export interface InstanceLogsPolicy {
        /**
         * The max age (in days) of remote logs to keep on the Database Instance
         */
        maxAgeRetention: number;
        /**
         * The max disk size of remote logs to keep on the Database Instance.
         */
        totalDiskRetention: number;
    }

    export interface InstancePrivateIp {
        /**
         * The private IPv4 address.
         */
        address: string;
        /**
         * The ID of the IPv4 address resource.
         */
        id: string;
    }

    export interface InstancePrivateNetwork {
        /**
         * Whether or not the private network endpoint should be configured with IPAM
         */
        enableIpam: boolean;
        /**
         * The ID of the endpoint.
         */
        endpointId: string;
        /**
         * Hostname of the endpoint.
         */
        hostname: string;
        /**
         * IPv4 address on the network.
         */
        ip: string;
        /**
         * The IP with the given mask within the private subnet
         */
        ipNet: string;
        /**
         * The name of the Database Instance.
         */
        name: string;
        /**
         * The private network ID
         */
        pnId: string;
        /**
         * Port in the Private Network.
         */
        port: number;
        /**
         * The zone you want to attach the resource to
         */
        zone?: string;
    }

    export interface InstanceReadReplica {
        /**
         * IPv4 address on the network.
         */
        ip: string;
        /**
         * The name of the Database Instance.
         */
        name: string;
        /**
         * Port in the Private Network.
         */
        port: number;
    }

    export interface ReadReplicaDirectAccess {
        /**
         * The ID of the endpoint of the Read Replica.
         */
        endpointId: string;
        /**
         * Hostname of the endpoint. Only one of IP and hostname may be set.
         */
        hostname: string;
        /**
         * IPv4 address of the endpoint (IP address). Only one of IP and hostname may be set.
         */
        ip: string;
        /**
         * Name of the endpoint.
         */
        name: string;
        /**
         * TCP port of the endpoint.
         */
        port: number;
    }

    export interface ReadReplicaPrivateNetwork {
        /**
         * If true, the IP network address within the private subnet is determined by the IP Address Management (IPAM) service.
         *
         * > **Important:** One of `serviceIp` or `enable_ipam=true` must be set.
         */
        enableIpam: boolean;
        /**
         * The ID of the endpoint of the Read Replica.
         */
        endpointId: string;
        /**
         * Hostname of the endpoint. Only one of IP and hostname may be set.
         */
        hostname: string;
        /**
         * IPv4 address of the endpoint (IP address). Only one of IP and hostname may be set.
         */
        ip: string;
        /**
         * Name of the endpoint.
         */
        name: string;
        /**
         * TCP port of the endpoint.
         */
        port: number;
        /**
         * UUID of the Private Netork to be connected to the Read Replica.
         */
        privateNetworkId: string;
        /**
         * The IP network address within the private subnet. This must be an IPv4 address with a CIDR notation. If not set, The IP network address within the private subnet is determined by the IP Address Management (IPAM) service.
         */
        serviceIp: string;
        /**
         * Private network zone
         */
        zone: string;
    }

}

export namespace domain {
    export interface GetRecordGeoIp {
        /**
         * The list of matches
         */
        matches: outputs.domain.GetRecordGeoIpMatch[];
    }

    export interface GetRecordGeoIpMatch {
        /**
         * List of continents (eg: EU for Europe, NA for North America, AS for Asia...). List of all continents code: https://api.scaleway.com/domain-private/v2beta1/continents
         */
        continents: string[];
        /**
         * List of countries (eg: FR for France, US for the United States, GB for Great Britain...). List of all countries code: https://api.scaleway.com/domain-private/v2beta1/countries
         */
        countries: string[];
        /**
         * The content of the record (e.g., an IPv4 address for an `A` record or a string for a `TXT` record). Cannot be used with `recordId`.
         */
        data: string;
    }

    export interface GetRecordHttpService {
        /**
         * IPs to check
         */
        ips: string[];
        /**
         * Text to search
         */
        mustContain: string;
        /**
         * Strategy to return an IP from the IPs list
         */
        strategy: string;
        /**
         * URL to match the mustContain text to validate an IP
         */
        url: string;
        /**
         * User-agent used when checking the URL
         */
        userAgent: string;
    }

    export interface GetRecordView {
        /**
         * The content of the record (e.g., an IPv4 address for an `A` record or a string for a `TXT` record). Cannot be used with `recordId`.
         */
        data: string;
        /**
         * The subnet of the view
         */
        subnet: string;
    }

    export interface GetRecordWeighted {
        /**
         * The weighted IP
         */
        ip: string;
        /**
         * The weight of the IP
         */
        weight: number;
    }

    export interface RecordGeoIp {
        /**
         * The list of matches
         */
        matches: outputs.domain.RecordGeoIpMatch[];
    }

    export interface RecordGeoIpMatch {
        /**
         * List of continents (eg: EU for Europe, NA for North America, AS for Asia...). List of all continents code: https://api.scaleway.com/domain-private/v2beta1/continents
         */
        continents?: string[];
        /**
         * List of countries (eg: FR for France, US for the United States, GB for Great Britain...). List of all countries code: https://api.scaleway.com/domain-private/v2beta1/countries
         */
        countries?: string[];
        /**
         * The content of the record (an IPv4 for an `A` record, a string for a `TXT` record, etc.).
         */
        data: string;
    }

    export interface RecordHttpService {
        /**
         * IPs to check
         */
        ips: string[];
        /**
         * Text to search
         */
        mustContain: string;
        /**
         * Strategy to return an IP from the IPs list
         */
        strategy: string;
        /**
         * URL to match the mustContain text to validate an IP
         */
        url: string;
        /**
         * User-agent used when checking the URL
         */
        userAgent?: string;
    }

    export interface RecordView {
        /**
         * The content of the record (an IPv4 for an `A` record, a string for a `TXT` record, etc.).
         */
        data: string;
        /**
         * The subnet of the view
         */
        subnet: string;
    }

    export interface RecordWeighted {
        /**
         * The weighted IP
         */
        ip: string;
        /**
         * The weight of the IP
         */
        weight: number;
    }

    export interface RegistrationAdministrativeContact {
        /**
         * Primary address line for the contact.
         */
        addressLine1: string;
        /**
         * Secondary address line for the contact (optional).
         */
        addressLine2?: string;
        /**
         * City of the contact's address.
         */
        city: string;
        /**
         * Company identification code (e.g., SIREN/SIRET in France) for the contact.
         */
        companyIdentificationCode: string;
        /**
         * Name of the company associated with the contact (if applicable).
         */
        companyName?: string;
        /**
         * Country code of the contact's address (ISO format).
         */
        country: string;
        /**
         * Primary email address of the contact.
         */
        email: string;
        /**
         * Alternative email address for the contact.
         */
        emailAlt?: string;
        /**
         * Details specific to European domain extensions.
         */
        extensionEu: outputs.domain.RegistrationAdministrativeContactExtensionEu;
        /**
         * Details specific to French domain extensions.
         */
        extensionFr: outputs.domain.RegistrationAdministrativeContactExtensionFr;
        /**
         * Extension details specific to Dutch domain registrations.
         */
        extensionNls: string[];
        /**
         * Fax number for the contact (if available).
         */
        faxNumber?: string;
        /**
         * First name of the contact.
         */
        firstname: string;
        /**
         * Preferred language of the contact (e.g., 'en_US', 'fr_FR').
         */
        lang: string;
        /**
         * Last name of the contact.
         */
        lastname: string;
        /**
         * Legal form of the contact (e.g., 'individual' or 'organization').
         */
        legalForm: string;
        /**
         * Primary phone number of the contact.
         */
        phoneNumber: string;
        /**
         * Indicates if the contact is used for resale purposes.
         */
        resale?: boolean;
        /**
         * State or region of the contact.
         */
        state?: string;
        /**
         * VAT identification code of the contact, if applicable.
         */
        vatIdentificationCode: string;
        /**
         * Indicates whether the contact has opted into WHOIS publishing.
         */
        whoisOptIn?: boolean;
        /**
         * Postal code of the contact's address.
         */
        zip: string;
    }

    export interface RegistrationAdministrativeContactExtensionEu {
        /**
         * Indicates the European citizenship of the contact.
         */
        europeanCitizenship?: string;
    }

    export interface RegistrationAdministrativeContactExtensionFr {
        /**
         * Association-specific information for the domain (French extension).
         */
        associationInfo?: outputs.domain.RegistrationAdministrativeContactExtensionFrAssociationInfo;
        /**
         * AFNIC authorization information for the contact (French extension).
         */
        codeAuthAfnicInfo?: outputs.domain.RegistrationAdministrativeContactExtensionFrCodeAuthAfnicInfo;
        /**
         * DUNS information for the domain owner (specific to French domains).
         */
        dunsInfo?: outputs.domain.RegistrationAdministrativeContactExtensionFrDunsInfo;
        /**
         * Information about the individual registration for French domains.
         */
        individualInfo?: outputs.domain.RegistrationAdministrativeContactExtensionFrIndividualInfo;
        /**
         * Mode of the French extension (e.g., 'individual', 'duns', 'association', etc.).
         */
        mode?: string;
        /**
         * Trademark-related information for the domain (French extension).
         */
        trademarkInfo?: outputs.domain.RegistrationAdministrativeContactExtensionFrTrademarkInfo;
    }

    export interface RegistrationAdministrativeContactExtensionFrAssociationInfo {
        /**
         * Publication date in the Official Journal (RFC3339 format) for association information.
         */
        publicationJo?: string;
        /**
         * Page number of the publication in the Official Journal for association information.
         */
        publicationJoPage?: number;
    }

    export interface RegistrationAdministrativeContactExtensionFrCodeAuthAfnicInfo {
        /**
         * AFNIC authorization code for the contact (specific to French domains).
         */
        codeAuthAfnic?: string;
    }

    export interface RegistrationAdministrativeContactExtensionFrDunsInfo {
        /**
         * DUNS ID associated with the domain owner (for French domains).
         */
        dunsId?: string;
        /**
         * Local identifier of the domain owner (for French domains).
         */
        localId?: string;
    }

    export interface RegistrationAdministrativeContactExtensionFrIndividualInfo {
        /**
         * Whether the individual contact has opted into WHOIS publishing.
         */
        whoisOptIn?: boolean;
    }

    export interface RegistrationAdministrativeContactExtensionFrTrademarkInfo {
        /**
         * Trademark information from INPI (French extension).
         */
        trademarkInpi?: string;
    }

    export interface RegistrationDsRecord {
        /**
         * The algorithm used for dnssec (e.g., rsasha256, ecdsap256sha256).
         */
        algorithm: string;
        /**
         * Details about the digest.
         */
        digests: outputs.domain.RegistrationDsRecordDigest[];
        /**
         * The identifier for the dnssec key.
         */
        keyId: number;
        /**
         * Public key associated with the dnssec record.
         */
        publicKeys: outputs.domain.RegistrationDsRecordPublicKey[];
    }

    export interface RegistrationDsRecordDigest {
        /**
         * The digest value.
         */
        digest: string;
        /**
         * The public key associated with the digest.
         */
        publicKeys: outputs.domain.RegistrationDsRecordDigestPublicKey[];
        /**
         * The digest type for the DS record (e.g., sha_1, sha_256, gost_r_34_11_94, sha_384).
         */
        type: string;
    }

    export interface RegistrationDsRecordDigestPublicKey {
        /**
         * The public key value.
         */
        key: string;
    }

    export interface RegistrationDsRecordPublicKey {
        /**
         * The public key value.
         */
        key: string;
    }

    export interface RegistrationOwnerContact {
        /**
         * Primary address line for the contact.
         */
        addressLine1: string;
        /**
         * Secondary address line for the contact (optional).
         */
        addressLine2?: string;
        /**
         * City of the contact's address.
         */
        city: string;
        /**
         * Company identification code (e.g., SIREN/SIRET in France) for the contact.
         */
        companyIdentificationCode: string;
        /**
         * Name of the company associated with the contact (if applicable).
         */
        companyName?: string;
        /**
         * Country code of the contact's address (ISO format).
         */
        country: string;
        /**
         * Primary email address of the contact.
         */
        email: string;
        /**
         * Alternative email address for the contact.
         */
        emailAlt?: string;
        /**
         * Details specific to European domain extensions.
         */
        extensionEu: outputs.domain.RegistrationOwnerContactExtensionEu;
        /**
         * Details specific to French domain extensions.
         */
        extensionFr: outputs.domain.RegistrationOwnerContactExtensionFr;
        /**
         * Extension details specific to Dutch domain registrations.
         */
        extensionNls: string[];
        /**
         * Fax number for the contact (if available).
         */
        faxNumber?: string;
        /**
         * First name of the contact.
         */
        firstname: string;
        /**
         * Preferred language of the contact (e.g., 'en_US', 'fr_FR').
         */
        lang: string;
        /**
         * Last name of the contact.
         */
        lastname: string;
        /**
         * Legal form of the contact (e.g., 'individual' or 'organization').
         */
        legalForm: string;
        /**
         * Primary phone number of the contact.
         */
        phoneNumber: string;
        /**
         * Indicates if the contact is used for resale purposes.
         */
        resale?: boolean;
        /**
         * State or region of the contact.
         */
        state?: string;
        /**
         * VAT identification code of the contact, if applicable.
         */
        vatIdentificationCode: string;
        /**
         * Indicates whether the contact has opted into WHOIS publishing.
         */
        whoisOptIn?: boolean;
        /**
         * Postal code of the contact's address.
         */
        zip: string;
    }

    export interface RegistrationOwnerContactExtensionEu {
        /**
         * Indicates the European citizenship of the contact.
         */
        europeanCitizenship?: string;
    }

    export interface RegistrationOwnerContactExtensionFr {
        /**
         * Association-specific information for the domain (French extension).
         */
        associationInfo?: outputs.domain.RegistrationOwnerContactExtensionFrAssociationInfo;
        /**
         * AFNIC authorization information for the contact (French extension).
         */
        codeAuthAfnicInfo?: outputs.domain.RegistrationOwnerContactExtensionFrCodeAuthAfnicInfo;
        /**
         * DUNS information for the domain owner (specific to French domains).
         */
        dunsInfo?: outputs.domain.RegistrationOwnerContactExtensionFrDunsInfo;
        /**
         * Information about the individual registration for French domains.
         */
        individualInfo?: outputs.domain.RegistrationOwnerContactExtensionFrIndividualInfo;
        /**
         * Mode of the French extension (e.g., 'individual', 'duns', 'association', etc.).
         */
        mode?: string;
        /**
         * Trademark-related information for the domain (French extension).
         */
        trademarkInfo?: outputs.domain.RegistrationOwnerContactExtensionFrTrademarkInfo;
    }

    export interface RegistrationOwnerContactExtensionFrAssociationInfo {
        /**
         * Publication date in the Official Journal (RFC3339 format) for association information.
         */
        publicationJo?: string;
        /**
         * Page number of the publication in the Official Journal for association information.
         */
        publicationJoPage?: number;
    }

    export interface RegistrationOwnerContactExtensionFrCodeAuthAfnicInfo {
        /**
         * AFNIC authorization code for the contact (specific to French domains).
         */
        codeAuthAfnic?: string;
    }

    export interface RegistrationOwnerContactExtensionFrDunsInfo {
        /**
         * DUNS ID associated with the domain owner (for French domains).
         */
        dunsId?: string;
        /**
         * Local identifier of the domain owner (for French domains).
         */
        localId?: string;
    }

    export interface RegistrationOwnerContactExtensionFrIndividualInfo {
        /**
         * Whether the individual contact has opted into WHOIS publishing.
         */
        whoisOptIn?: boolean;
    }

    export interface RegistrationOwnerContactExtensionFrTrademarkInfo {
        /**
         * Trademark information from INPI (French extension).
         */
        trademarkInpi?: string;
    }

    export interface RegistrationTechnicalContact {
        /**
         * Primary address line for the contact.
         */
        addressLine1: string;
        /**
         * Secondary address line for the contact (optional).
         */
        addressLine2?: string;
        /**
         * City of the contact's address.
         */
        city: string;
        /**
         * Company identification code (e.g., SIREN/SIRET in France) for the contact.
         */
        companyIdentificationCode: string;
        /**
         * Name of the company associated with the contact (if applicable).
         */
        companyName?: string;
        /**
         * Country code of the contact's address (ISO format).
         */
        country: string;
        /**
         * Primary email address of the contact.
         */
        email: string;
        /**
         * Alternative email address for the contact.
         */
        emailAlt?: string;
        /**
         * Details specific to European domain extensions.
         */
        extensionEu: outputs.domain.RegistrationTechnicalContactExtensionEu;
        /**
         * Details specific to French domain extensions.
         */
        extensionFr: outputs.domain.RegistrationTechnicalContactExtensionFr;
        /**
         * Extension details specific to Dutch domain registrations.
         */
        extensionNls: string[];
        /**
         * Fax number for the contact (if available).
         */
        faxNumber?: string;
        /**
         * First name of the contact.
         */
        firstname: string;
        /**
         * Preferred language of the contact (e.g., 'en_US', 'fr_FR').
         */
        lang: string;
        /**
         * Last name of the contact.
         */
        lastname: string;
        /**
         * Legal form of the contact (e.g., 'individual' or 'organization').
         */
        legalForm: string;
        /**
         * Primary phone number of the contact.
         */
        phoneNumber: string;
        /**
         * Indicates if the contact is used for resale purposes.
         */
        resale?: boolean;
        /**
         * State or region of the contact.
         */
        state?: string;
        /**
         * VAT identification code of the contact, if applicable.
         */
        vatIdentificationCode: string;
        /**
         * Indicates whether the contact has opted into WHOIS publishing.
         */
        whoisOptIn?: boolean;
        /**
         * Postal code of the contact's address.
         */
        zip: string;
    }

    export interface RegistrationTechnicalContactExtensionEu {
        /**
         * Indicates the European citizenship of the contact.
         */
        europeanCitizenship?: string;
    }

    export interface RegistrationTechnicalContactExtensionFr {
        /**
         * Association-specific information for the domain (French extension).
         */
        associationInfo?: outputs.domain.RegistrationTechnicalContactExtensionFrAssociationInfo;
        /**
         * AFNIC authorization information for the contact (French extension).
         */
        codeAuthAfnicInfo?: outputs.domain.RegistrationTechnicalContactExtensionFrCodeAuthAfnicInfo;
        /**
         * DUNS information for the domain owner (specific to French domains).
         */
        dunsInfo?: outputs.domain.RegistrationTechnicalContactExtensionFrDunsInfo;
        /**
         * Information about the individual registration for French domains.
         */
        individualInfo?: outputs.domain.RegistrationTechnicalContactExtensionFrIndividualInfo;
        /**
         * Mode of the French extension (e.g., 'individual', 'duns', 'association', etc.).
         */
        mode?: string;
        /**
         * Trademark-related information for the domain (French extension).
         */
        trademarkInfo?: outputs.domain.RegistrationTechnicalContactExtensionFrTrademarkInfo;
    }

    export interface RegistrationTechnicalContactExtensionFrAssociationInfo {
        /**
         * Publication date in the Official Journal (RFC3339 format) for association information.
         */
        publicationJo?: string;
        /**
         * Page number of the publication in the Official Journal for association information.
         */
        publicationJoPage?: number;
    }

    export interface RegistrationTechnicalContactExtensionFrCodeAuthAfnicInfo {
        /**
         * AFNIC authorization code for the contact (specific to French domains).
         */
        codeAuthAfnic?: string;
    }

    export interface RegistrationTechnicalContactExtensionFrDunsInfo {
        /**
         * DUNS ID associated with the domain owner (for French domains).
         */
        dunsId?: string;
        /**
         * Local identifier of the domain owner (for French domains).
         */
        localId?: string;
    }

    export interface RegistrationTechnicalContactExtensionFrIndividualInfo {
        /**
         * Whether the individual contact has opted into WHOIS publishing.
         */
        whoisOptIn?: boolean;
    }

    export interface RegistrationTechnicalContactExtensionFrTrademarkInfo {
        /**
         * Trademark information from INPI (French extension).
         */
        trademarkInpi?: string;
    }

}

export namespace elasticmetal {
    export interface GetIpsIp {
        /**
         * The date on which the flexible IP was created (RFC 3339 format).
         */
        createdAt: string;
        /**
         * The description of the flexible IP.
         */
        description: string;
        /**
         * The MAC address ID.
         */
        id: string;
        /**
         * IP address of the flexible IP
         */
        ipAddress: string;
        /**
         * The MAC address of the Virtual MAC.
         */
        macAddresses: outputs.elasticmetal.GetIpsIpMacAddress[];
        /**
         * (Defaults to provider `organizationId`) The ID of the organization the IP is in.
         */
        organizationId: string;
        /**
         * (Defaults to provider `projectId`) The ID of the project the IP is in.
         */
        projectId: string;
        /**
         * The reverse domain associated with this IP.
         */
        reverse: string;
        /**
         * The status of virtual MAC.
         */
        status: string;
        /**
         * List of tags used as filter. IPs with these exact tags are listed.
         */
        tags: string[];
        /**
         * The date on which the flexible IP was last updated (RFC 3339 format).
         */
        updatedAt: string;
        /**
         * `zone`) The zone in which IPs exist.
         */
        zone: string;
    }

    export interface GetIpsIpMacAddress {
        /**
         * The date on which the flexible IP was created (RFC 3339 format).
         */
        createdAt: string;
        /**
         * The MAC address ID.
         */
        id: string;
        /**
         * The MAC address of the Virtual MAC.
         */
        macAddress: string;
        /**
         * The type of virtual MAC.
         */
        macType: string;
        /**
         * The status of virtual MAC.
         */
        status: string;
        /**
         * The date on which the flexible IP was last updated (RFC 3339 format).
         */
        updatedAt: string;
        /**
         * `zone`) The zone in which IPs exist.
         */
        zone?: string;
    }

    export interface GetOfferCpu {
        /**
         * Number of core on this CPU.
         */
        coreCount: number;
        /**
         * Frequency of the memory in MHz.
         */
        frequency: number;
        /**
         * The offer name. Only one of `name` and `offerId` should be specified.
         */
        name: string;
        /**
         * Number of thread on this CPU.
         */
        threadCount: number;
    }

    export interface GetOfferDisk {
        /**
         * Capacity of the memory in GB.
         */
        capacity: number;
        /**
         * Type of memory.
         */
        type: string;
    }

    export interface GetOfferMemory {
        /**
         * Capacity of the memory in GB.
         */
        capacity: number;
        /**
         * Frequency of the memory in MHz.
         */
        frequency: number;
        /**
         * True if error-correcting code is available on this memory.
         */
        isEcc: boolean;
        /**
         * Type of memory.
         */
        type: string;
    }

    export interface GetServerIp {
        /**
         * The IPv6 address
         */
        address: string;
        /**
         * The ID of the server.
         */
        id: string;
        /**
         * The Reverse of the IPv6
         */
        reverse: string;
        /**
         * The version of the IPv6
         */
        version: string;
    }

    export interface GetServerIpv4 {
        /**
         * The IPv6 address
         */
        address: string;
        /**
         * The ID of the server.
         */
        id: string;
        /**
         * The Reverse of the IPv6
         */
        reverse: string;
        /**
         * The version of the IPv6
         */
        version: string;
    }

    export interface GetServerIpv6 {
        /**
         * The IPv6 address
         */
        address: string;
        /**
         * The ID of the server.
         */
        id: string;
        /**
         * The Reverse of the IPv6
         */
        reverse: string;
        /**
         * The version of the IPv6
         */
        version: string;
    }

    export interface GetServerOption {
        /**
         * Auto expire the option after this date
         */
        expiresAt: string;
        /**
         * The ID of the server.
         */
        id: string;
        /**
         * The server name. Only one of `name` and `serverId` should be specified.
         */
        name: string;
    }

    export interface GetServerPrivateIp {
        /**
         * The private IP address
         */
        address: string;
        /**
         * The ID of the server.
         */
        id: string;
    }

    export interface GetServerPrivateNetwork {
        /**
         * The date and time of the creation of the private network
         */
        createdAt: string;
        /**
         * The ID of the server.
         */
        id: string;
        /**
         * List of IPAM IP IDs to attach to the server
         */
        ipamIpIds: string[];
        /**
         * The ID of the Server-to-Private Network mapping
         */
        mappingId: string;
        /**
         * The private network status
         */
        status: string;
        /**
         * The date and time of the last update of the private network
         */
        updatedAt: string;
        /**
         * The VLAN ID associated to the private network
         */
        vlan: number;
    }

    export interface ServerIp {
        /**
         * The address of the IPv6.
         */
        address: string;
        /**
         * The ID of the IPv6.
         */
        id: string;
        /**
         * The reverse of the IPv6.
         */
        reverse: string;
        /**
         * The type of the IPv6.
         */
        version: string;
    }

    export interface ServerIpv4 {
        /**
         * The address of the IPv6.
         */
        address: string;
        /**
         * The ID of the IPv6.
         */
        id: string;
        /**
         * The reverse of the IPv6.
         */
        reverse: string;
        /**
         * The type of the IPv6.
         */
        version: string;
    }

    export interface ServerIpv6 {
        /**
         * The address of the IPv6.
         */
        address: string;
        /**
         * The ID of the IPv6.
         */
        id: string;
        /**
         * The reverse of the IPv6.
         */
        reverse: string;
        /**
         * The type of the IPv6.
         */
        version: string;
    }

    export interface ServerOption {
        /**
         * The auto expiration date for compatible options
         */
        expiresAt: string;
        /**
         * The id of the option to enable. Use [this endpoint](https://www.scaleway.com/en/developers/api/elastic-metal/#path-options-list-options) to find the available options IDs.
         */
        id: string;
        /**
         * The name of the server.
         */
        name: string;
    }

    export interface ServerPrivateIp {
        /**
         * The address of the IPv6.
         */
        address: string;
        /**
         * The ID of the IPv6.
         */
        id: string;
    }

    export interface ServerPrivateNetwork {
        /**
         * The date and time of the creation of the private network.
         */
        createdAt: string;
        /**
         * The id of the private network to attach.
         */
        id: string;
        /**
         * List of IPAM IP IDs to assign to the server in the requested private network.
         */
        ipamIpIds: string[];
        /**
         * The ID of the Server-to-Private Network mapping.
         */
        mappingId: string;
        /**
         * The private network status.
         */
        status: string;
        /**
         * The date and time of the last update of the private network.
         */
        updatedAt: string;
        /**
         * The VLAN ID associated to the private network.
         */
        vlan: number;
    }

}

export namespace functions {
    export interface TriggerNats {
        /**
         * unique identifier of the Messaging and Queuing NATS account.
         */
        accountId?: string;
        /**
         * THe ID of the project that contains the Messaging and Queuing NATS account (defaults to provider `projectId`)
         */
        projectId: string;
        /**
         * Region where the Messaging and Queuing NATS account is enabled (defaults to provider `region`)
         */
        region: string;
        /**
         * The subject to listen to.
         */
        subject: string;
    }

    export interface TriggerSqs {
        /**
         * ID of the Messaging and Queuing namespace. This argument is deprecated.
         *
         * @deprecated The 'namespace_id' field is deprecated and will be removed in the next major version. It is no longer necessary to specify it
         */
        namespaceId?: string;
        /**
         * The ID of the project in which SQS is enabled, (defaults to provider `projectId`)
         */
        projectId: string;
        /**
         * The name of the SQS queue.
         */
        queue: string;
        /**
         * Region where SQS is enabled (defaults to provider `region`)
         */
        region: string;
    }

}

export namespace hosting {
    export interface GetHostingCpanelUrl {
        /**
         * URL to connect to dashboard interface
         */
        dashboard: string;
        /**
         * URL to connect to Webmail interface
         */
        webmail: string;
    }

    export interface GetHostingNameServer {
        /**
         * Hostname of the server
         */
        hostname: string;
        /**
         * Whether or not the webhosting is the default one
         */
        isDefault: boolean;
        /**
         * Status of the nameserver
         */
        status: string;
    }

    export interface GetHostingOption {
        /**
         * ID of the active option
         */
        id: string;
        /**
         * Name of the option
         */
        name: string;
    }

    export interface GetHostingRecord {
        /**
         * Name of the DNS record
         */
        name: string;
        /**
         * Priority of DNS records associated with the webhosting.
         */
        priority: number;
        /**
         * Status of the hosting record
         */
        status: string;
        /**
         * Time to live in seconds of the record
         */
        ttl: number;
        /**
         * Type of the DNS record
         */
        type: string;
        /**
         * Value of the DNS record
         */
        value: string;
    }

    export interface GetOfferOffer {
        /**
         * Indicates if the offer is available.
         */
        available: boolean;
        /**
         * The billing operation identifier for the option.
         */
        billingOperationPath: string;
        /**
         * The name of the control panel (e.g., Cpanel or Plesk).
         */
        controlPanelName: string;
        /**
         * Indicates if the offer is deprecated or no longer supported.
         */
        endOfLife: boolean;
        /**
         * The unique identifier of the option.
         */
        id: string;
        /**
         * The offer name. Only one of `name` and `offerId` should be specified.
         */
        name: string;
        /**
         * A list of available options for the offer:
         */
        options: outputs.hosting.GetOfferOfferOption[];
        /**
         * The offer price.
         */
        price: string;
        /**
         * Warning information regarding quota limitations for the option.
         */
        quotaWarning: string;
    }

    export interface GetOfferOfferOption {
        /**
         * The billing operation identifier for the option.
         */
        billingOperationPath: string;
        /**
         * The current value set for the option.
         */
        currentValue: number;
        /**
         * The unique identifier of the option.
         */
        id: string;
        /**
         * The maximum allowed value for the option.
         */
        maxValue: number;
        /**
         * The minimum value for the option.
         */
        minValue: number;
        /**
         * The offer name. Only one of `name` and `offerId` should be specified.
         */
        name: string;
        /**
         * The offer price.
         */
        price: string;
        /**
         * Warning information regarding quota limitations for the option.
         */
        quotaWarning: string;
    }

    export interface GetOfferProduct {
        /**
         * The quota of databases.
         */
        databasesQuota: number;
        /**
         * The quota of email accounts.
         */
        emailAccountsQuota: number;
        /**
         * The quota of email storage.
         */
        emailStorageQuota: number;
        /**
         * The quota of hosting storage.
         */
        hostingStorageQuota: number;
        /**
         * The offer name. Only one of `name` and `offerId` should be specified.
         */
        name: string;
        /**
         * The product option.
         */
        option: boolean;
        /**
         * The capacity of the memory in GB.
         */
        ram: number;
        /**
         * If support is included.
         */
        supportIncluded: boolean;
        /**
         * The number of cores.
         */
        vCpu: number;
    }

    export interface HostingCpanelUrl {
        /**
         * The URL of the Dashboard.
         */
        dashboard: string;
        /**
         * The URL of the Webmail interface.
         */
        webmail: string;
    }

    export interface HostingNameServer {
        /**
         * Hostname of the server
         */
        hostname: string;
        /**
         * Whether or not the webhosting is the default one
         */
        isDefault: boolean;
        /**
         * The hosting status.
         */
        status: string;
    }

    export interface HostingOption {
        /**
         * The option ID.
         */
        id: string;
        /**
         * The option name.
         */
        name: string;
    }

    export interface HostingRecord {
        /**
         * The option name.
         */
        name: string;
        /**
         * Priority of DNS records associated with the webhosting.
         */
        priority: number;
        /**
         * The hosting status.
         */
        status: string;
        /**
         * Time to live in seconds of the record
         */
        ttl: number;
        /**
         * Type of the DNS record
         */
        type: string;
        /**
         * Value of the DNS record
         */
        value: string;
    }

}

export namespace iam {
    export interface PolicyRule {
        /**
         * The condition of the rule.
         *
         * **_TIP:_** You can use the Scaleway CLI to list the permissions details. e.g:
         *
         * ```shell
         * scw iam permission-set list
         * ```
         */
        condition?: string;
        /**
         * ID of organization scoped to the rule, this can be used to create a rule for all projects in an organization.
         */
        organizationId?: string;
        /**
         * Names of permission sets bind to the rule.
         */
        permissionSetNames: string[];
        /**
         * List of project IDs scoped to the rule.
         *
         * > **Important** One `organizationId` or `projectIds` must be set per rule.
         */
        projectIds?: string[];
    }

}

export namespace inference {
    export interface DeploymentPrivateEndpoint {
        /**
         * Disable the authentication on the endpoint.
         */
        disableAuth?: boolean;
        /**
         * (Optional) The id of the public endpoint.
         */
        id: string;
        /**
         * The ID of the private network to use.
         */
        privateNetworkId?: string;
        /**
         * (Optional) The URL of the endpoint.
         */
        url: string;
    }

    export interface DeploymentPrivateIp {
        /**
         * The private IPv4 address.
         */
        address: string;
        /**
         * (Optional) The id of the public endpoint.
         */
        id: string;
    }

    export interface DeploymentPublicEndpoint {
        /**
         * Disable the authentication on the endpoint.
         */
        disableAuth?: boolean;
        /**
         * (Optional) The id of the public endpoint.
         */
        id: string;
        /**
         * Enable or disable public endpoint.
         */
        isEnabled?: boolean;
        /**
         * (Optional) The URL of the endpoint.
         */
        url: string;
    }

    export interface GetModelNodesSupport {
        /**
         * The type of node supported.
         */
        nodeTypeName: string;
        /**
         * A list of supported quantization options, including:
         */
        quantizations: outputs.inference.GetModelNodesSupportQuantization[];
    }

    export interface GetModelNodesSupportQuantization {
        /**
         * Whether this quantization is allowed.
         */
        allowed: boolean;
        /**
         * Maximum context length supported by this quantization.
         */
        maxContextSize: number;
        /**
         * Number of bits used for quantization (e.g., 8, 16).
         */
        quantizationBits: number;
    }

    export interface ModelNodesSupport {
        /**
         * The type of node supported.
         */
        nodeTypeName: string;
        /**
         * A list of supported quantization options, including:
         */
        quantizations: outputs.inference.ModelNodesSupportQuantization[];
    }

    export interface ModelNodesSupportQuantization {
        /**
         * Whether this quantization is allowed.
         */
        allowed: boolean;
        /**
         * Maximum context length supported by this quantization.
         */
        maxContextSize: number;
        /**
         * Number of bits used for quantization (e.g., 8, 16).
         */
        quantizationBits: number;
    }

}

export namespace instance {
    export interface GetPrivateNicPrivateIp {
        /**
         * The private IP address
         */
        address: string;
        /**
         * The ID of the IP address resource
         */
        id: string;
    }

    export interface GetSecurityGroupInboundRule {
        /**
         * The action to take when rule match. Possible values are: `accept` or `drop`.
         */
        action: string;
        /**
         * The ip this rule apply to.
         */
        ip: string;
        /**
         * The ip range (e.g `192.168.1.0/24`) this rule apply to.
         */
        ipRange: string;
        /**
         * The port this rule apply to. If no port is specified, rule will apply to all port.
         */
        port: number;
        /**
         * The port range (e.g `22-23`) this rule applies to.
         * If no `port` nor `portRange` are specified, rule will apply to all port.
         * Only one of `port` and `portRange` should be specified.
         */
        portRange: string;
        /**
         * The protocol this rule apply to. Possible values are: `TCP`, `UDP`, `ICMP` or `ANY`.
         */
        protocol: string;
    }

    export interface GetSecurityGroupOutboundRule {
        /**
         * The action to take when rule match. Possible values are: `accept` or `drop`.
         */
        action: string;
        /**
         * The ip this rule apply to.
         */
        ip: string;
        /**
         * The ip range (e.g `192.168.1.0/24`) this rule apply to.
         */
        ipRange: string;
        /**
         * The port this rule apply to. If no port is specified, rule will apply to all port.
         */
        port: number;
        /**
         * The port range (e.g `22-23`) this rule applies to.
         * If no `port` nor `portRange` are specified, rule will apply to all port.
         * Only one of `port` and `portRange` should be specified.
         */
        portRange: string;
        /**
         * The protocol this rule apply to. Possible values are: `TCP`, `UDP`, `ICMP` or `ANY`.
         */
        protocol: string;
    }

    export interface GetServerPrivateIp {
        /**
         * The address of the IP
         */
        address: string;
        /**
         * The ID of the IP
         */
        id: string;
    }

    export interface GetServerPrivateNetwork {
        /**
         * MAC address of the NIC
         */
        macAddress: string;
        /**
         * The Private Network ID
         */
        pnId: string;
        /**
         * The ID of the NIC
         */
        pnicId: string;
        /**
         * The private NIC state
         */
        status: string;
        /**
         * `zone`) The zone in which the server exists.
         */
        zone: string;
    }

    export interface GetServerPublicIp {
        /**
         * The address of the IP
         */
        address: string;
        /**
         * Whether the IP is dynamic
         */
        dynamic: boolean;
        /**
         * IP address family (inet or inet6)
         */
        family: string;
        /**
         * Gateway's IP address
         */
        gateway: string;
        /**
         * The ID of the IP
         */
        id: string;
        /**
         * CIDR netmask
         */
        netmask: string;
        /**
         * Provisioning mode of the IP address
         */
        provisioningMode: string;
    }

    export interface GetServerRootVolume {
        /**
         * Set the volume where the boot the server
         */
        boot: boolean;
        /**
         * Forces deletion of the root volume on instance termination.
         */
        deleteOnTermination: boolean;
        /**
         * The server name. Only one of `name` and `serverId` should be specified.
         */
        name: string;
        /**
         * SBS Volume IOPS, only with volumeType as sbs_volume
         */
        sbsIops: number;
        /**
         * Size of the root volume in gigabytes.
         */
        sizeInGb: number;
        /**
         * The volume ID of the root volume of the server.
         */
        volumeId: string;
        /**
         * Volume type of the root volume
         */
        volumeType: string;
    }

    export interface GetServerTypeCapability {
        /**
         * The boot types allowed for the server type.
         */
        bootTypes: string[];
        /**
         * The maximum number of file systems that can be attached on the server type.
         */
        maxFileSystems: number;
    }

    export interface GetServerTypeNetwork {
        /**
         * The block bandwidth of the server type (in bytes/second).
         */
        blockBandwidth: number;
        /**
         * The internal bandwidth of the server type (in bytes/second).
         */
        internalBandwidth: number;
        /**
         * The public bandwidth of the server type (in bytes/second).
         */
        publicBandwidth: number;
    }

    export interface GetServerTypeVolume {
        /**
         * Whether block storage is allowed on the server type.
         */
        blockStorage: boolean;
        /**
         * The maximum size in bytes per local volume allowed on the server type.
         */
        maxSizePerLocalVolume: number;
        /**
         * The maximum total size in bytes of volumes allowed on the server type.
         */
        maxSizeTotal: number;
        /**
         * The minimum size in bytes per local volume allowed on the server type.
         */
        minSizePerLocalVolume: number;
        /**
         * The minimum total size in bytes of volumes allowed on the server type.
         */
        minSizeTotal: number;
        /**
         * The maximum size in bytes of the scratch volume allowed on the server type.
         */
        scratchStorageMaxSize: number;
    }

    export interface GetServersServer {
        /**
         * The boot Type of the server. Possible values are: `local`, `bootscript` or `rescue`.
         */
        bootType: string;
        /**
         * UUID of the bootscript
         *
         * @deprecated bootscript are not supported
         */
        bootscriptId: string;
        /**
         * If true a dynamic IP will be attached to the server.
         */
        enableDynamicIp: boolean;
        /**
         * Determines if IPv6 is enabled for the server.
         */
        enableIpv6: boolean;
        /**
         * The ID of the IP
         */
        id: string;
        /**
         * The UUID or the label of the base image used by the server.
         */
        image: string;
        /**
         * The default ipv6 address routed to the server. ( Only set when enableIpv6 is set to true )
         */
        ipv6Address: string;
        /**
         * The ipv6 gateway address. ( Only set when enableIpv6 is set to true )
         */
        ipv6Gateway: string;
        /**
         * The prefix length of the ipv6 subnet routed to the server. ( Only set when enableIpv6 is set to true )
         */
        ipv6PrefixLength: number;
        /**
         * The server name used as filter. Servers with a name like it are listed.
         */
        name: string;
        /**
         * The organization ID the server is associated with.
         */
        organizationId: string;
        /**
         * The [placement group](https://developers.scaleway.com/en/products/instance/api/#placement-groups-d8f653) the server is attached to.
         */
        placementGroupId: string;
        /**
         * Whether the placement group policy respected or not
         */
        placementGroupPolicyRespected: boolean;
        /**
         * The Scaleway internal IP address of the server.
         */
        privateIp: string;
        /**
         * The list of private IPv4 and IPv6 addresses associated with the server.
         */
        privateIps: outputs.instance.GetServersServerPrivateIp[];
        /**
         * The ID of the project the server is associated with.
         */
        projectId: string;
        /**
         * The public IP address of the server.
         *
         * @deprecated Use publicIps instead
         */
        publicIp: string;
        /**
         * The list of public IPs of the server
         */
        publicIps: outputs.instance.GetServersServerPublicIp[];
        /**
         * The [security group](https://developers.scaleway.com/en/products/instance/api/#security-groups-8d7f89) the server is attached to.
         */
        securityGroupId: string;
        /**
         * The state of the server. Possible values are: `started`, `stopped` or `standby`.
         */
        state: string;
        /**
         * List of tags used as filter. Servers with these exact tags are listed.
         */
        tags: string[];
        /**
         * The commercial type of the server.
         */
        type: string;
        /**
         * `zone`) The zone in which servers exist.
         */
        zone?: string;
    }

    export interface GetServersServerPrivateIp {
        /**
         * The address of the IP
         */
        address: string;
        /**
         * The ID of the IP
         */
        id: string;
    }

    export interface GetServersServerPublicIp {
        /**
         * The address of the IP
         */
        address: string;
        /**
         * The ID of the IP
         */
        id: string;
    }

    export interface GetSnapshotImport {
        /**
         * Bucket containing qcow
         */
        bucket: string;
        /**
         * Key of the qcow file in the specified bucket
         */
        key: string;
    }

    export interface ImageAdditionalVolume {
        /**
         * ID of the server containing the volume.
         */
        id: string;
        /**
         * The name of the image. If not provided it will be randomly generated.
         */
        name: string;
        /**
         * Description of the server containing the volume (in case the image is a backup from a server).
         */
        server: {[key: string]: string};
        /**
         * The size of the volume.
         */
        size: number;
        /**
         * A list of tags to apply to the image.
         */
        tags: string[];
        /**
         * The type of volume, possible values are `lSsd` and `sbsSnapshot`.
         */
        volumeType: string;
    }

    export interface ImageRootVolume {
        /**
         * ID of the server containing the volume.
         */
        id: string;
        /**
         * The name of the image. If not provided it will be randomly generated.
         */
        name: string;
        /**
         * The size of the volume.
         */
        size: number;
        /**
         * The type of volume, possible values are `lSsd` and `sbsSnapshot`.
         */
        volumeType: string;
    }

    export interface PrivateNicPrivateIp {
        /**
         * The private IP address.
         */
        address: string;
        /**
         * The ID of the IP address resource.
         */
        id: string;
    }

    export interface SecurityGroupInboundRule {
        /**
         * The action to take when rule match. Possible values are: `accept` or `drop`.
         */
        action: string;
        /**
         * The ip this rule apply to. If no `ip` nor `ipRange` are specified, rule will apply to all ip. Only one of `ip` and `ipRange` should be specified.
         *
         * @deprecated Ip address is deprecated. Please use ipRange instead
         */
        ip?: string;
        /**
         * The ip range (e.g `192.168.1.0/24`) this rule applies to. If no `ip` nor `ipRange` are specified, rule will apply to all ip. Only one of `ip` and `ipRange` should be specified.
         */
        ipRange?: string;
        /**
         * The port this rule applies to. If no `port` nor `portRange` are specified, the rule will apply to all port. Only one of `port` and `portRange` should be specified.
         */
        port?: number;
        /**
         * Computed port range for this rule (e.g: 1-1024, 22-22)
         */
        portRange?: string;
        /**
         * The protocol this rule apply to. Possible values are: `TCP`, `UDP`, `ICMP` or `ANY`.
         */
        protocol?: string;
    }

    export interface SecurityGroupOutboundRule {
        /**
         * Action when rule match request (drop or accept)
         */
        action: string;
        /**
         * Ip address for this rule (e.g: 1.1.1.1). Only one of ip or ipRange should be provided
         *
         * @deprecated Ip address is deprecated. Please use ipRange instead
         */
        ip?: string;
        /**
         * Ip range for this rule (e.g: 192.168.1.0/24). Only one of ip or ipRange should be provided
         */
        ipRange?: string;
        /**
         * Network port for this rule
         */
        port?: number;
        /**
         * Computed port range for this rule (e.g: 1-1024, 22-22)
         */
        portRange?: string;
        /**
         * Protocol for this rule (TCP, UDP, ICMP or ANY)
         */
        protocol?: string;
    }

    export interface SecurityGroupRulesInboundRule {
        /**
         * The action to take when rule match. Possible values are: `accept` or `drop`.
         */
        action: string;
        /**
         * The ip this rule apply to. If no `ip` nor `ipRange` are specified, rule will apply to all ip. Only one of `ip` and `ipRange` should be specified.
         *
         * @deprecated Ip address is deprecated. Please use ipRange instead
         */
        ip?: string;
        /**
         * The ip range (e.g `192.168.1.0/24`) this rule applies to. If no `ip` nor `ipRange` are specified, rule will apply to all ip. Only one of `ip` and `ipRange` should be specified.
         */
        ipRange?: string;
        /**
         * The port this rule apply to. If no port is specified, rule will apply to all port.
         */
        port?: number;
        /**
         * Computed port range for this rule (e.g: 1-1024, 22-22)
         */
        portRange?: string;
        /**
         * The protocol this rule apply to. Possible values are: `TCP`, `UDP`, `ICMP` or `ANY`.
         */
        protocol?: string;
    }

    export interface SecurityGroupRulesOutboundRule {
        /**
         * Action when rule match request (drop or accept)
         */
        action: string;
        /**
         * Ip address for this rule (e.g: 1.1.1.1). Only one of ip or ipRange should be provided
         *
         * @deprecated Ip address is deprecated. Please use ipRange instead
         */
        ip?: string;
        /**
         * Ip range for this rule (e.g: 192.168.1.0/24). Only one of ip or ipRange should be provided
         */
        ipRange?: string;
        /**
         * Network port for this rule
         */
        port?: number;
        /**
         * Computed port range for this rule (e.g: 1-1024, 22-22)
         */
        portRange?: string;
        /**
         * Protocol for this rule (TCP, UDP, ICMP or ANY)
         */
        protocol?: string;
    }

    export interface ServerPrivateIp {
        /**
         * The private IP address.
         */
        address: string;
        /**
         * The ID of the IP address resource.
         */
        id: string;
    }

    export interface ServerPrivateNetwork {
        /**
         * MAC address of the NIC
         */
        macAddress: string;
        /**
         * The Private Network ID
         */
        pnId: string;
        /**
         * The ID of the NIC
         */
        pnicId: string;
        /**
         * The private NIC state
         */
        status: string;
        /**
         * `zone`) The zone in which the server should be created.
         */
        zone?: string;
    }

    export interface ServerPublicIp {
        /**
         * The address of the IP.
         */
        address: string;
        /**
         * Whether the IP is dynamic.
         */
        dynamic: boolean;
        /**
         * The IP address' family.
         */
        family: string;
        /**
         * The IP of the Gateway associated with the IP.
         */
        gateway: string;
        /**
         * The ID of the IP.
         */
        id: string;
        /**
         * The CIDR netmask of the IP.
         */
        netmask: string;
        /**
         * The provisioning mode of the IP
         */
        provisioningMode: string;
    }

    export interface ServerRootVolume {
        /**
         * Set the volume where the boot the server
         */
        boot?: boolean;
        /**
         * Forces deletion of the root volume on instance termination.
         */
        deleteOnTermination?: boolean;
        /**
         * The name of the server.
         */
        name: string;
        /**
         * Choose IOPS of your sbs volume, has to be used with `sbsVolume` for root volume type.
         *
         * > **Important:** Updates to `root_volume.size_in_gb` will be ignored after the creation of the server.
         */
        sbsIops: number;
        /**
         * Size of the root volume in gigabytes.
         * To find the right size use [this endpoint](https://www.scaleway.com/en/developers/api/instance/#path-instances-list-all-instances) and
         * check the `volumes_constraint.{min|max}_size` (in bytes) for your `commercialType`.
         * Depending on `volumeType`, updates to this field may recreate a new resource.
         */
        sizeInGb: number;
        /**
         * The volume ID of the root volume of the server, allows you to create server with an existing volume. If empty, will be computed to a created volume ID.
         */
        volumeId: string;
        /**
         * Volume type of root volume, can be `lSsd` or `sbsVolume`, default value depends on server type
         */
        volumeType: string;
    }

    export interface SnapshotImport {
        /**
         * Bucket name containing [qcow2](https://en.wikipedia.org/wiki/Qcow) to import
         */
        bucket: string;
        /**
         * Key of the object to import
         */
        key: string;
    }

}

export namespace iot {
    export interface DeviceCertificate {
        /**
         * X509 PEM encoded certificate of the device
         */
        crt: string;
        /**
         * The private key of the device, in case it is generated by Scaleway.
         */
        key: string;
    }

    export interface DeviceMessageFilters {
        /**
         * Rules used to restrict topics the device can publish to.
         */
        publish?: outputs.iot.DeviceMessageFiltersPublish;
        /**
         * Rules used to restrict topics the device can subscribe to.
         */
        subscribe?: outputs.iot.DeviceMessageFiltersSubscribe;
    }

    export interface DeviceMessageFiltersPublish {
        /**
         * Filtering policy (eg `accept` or `reject`)
         */
        policy?: string;
        /**
         * List of topics to match (eg `foo/bar/+/baz/#`)
         */
        topics?: string[];
    }

    export interface DeviceMessageFiltersSubscribe {
        /**
         * Same as publish rules.
         */
        policy?: string;
        /**
         * Same as publish rules.
         *
         * - `certificate.crt` - (Optional) The certificate of the device, either generated by Scaleway or provided.
         *
         * > **Important:** Updates to `certificate.crt` will disconnect connected devices and the previous certificate will be deleted and won't be recoverable.
         */
        topics?: string[];
    }

    export interface GetDeviceCertificate {
        /**
         * X509 PEM encoded certificate of the device
         */
        crt: string;
        /**
         * X509 PEM encoded key of the device
         */
        key: string;
    }

    export interface GetDeviceMessageFilter {
        /**
         * Rule to restrict topics the device can publish to
         */
        publishes: outputs.iot.GetDeviceMessageFilterPublish[];
        /**
         * Rule to restrict topics the device can subscribe to
         */
        subscribes: outputs.iot.GetDeviceMessageFilterSubscribe[];
    }

    export interface GetDeviceMessageFilterPublish {
        /**
         * Publish message filter policy
         */
        policy: string;
        /**
         * List of topics in the set
         */
        topics: string[];
    }

    export interface GetDeviceMessageFilterSubscribe {
        /**
         * Subscribe message filter policy
         */
        policy: string;
        /**
         * List of topics in the set
         */
        topics: string[];
    }

    export interface RouteDatabase {
        /**
         * The database name (e.g. `measurements`).
         */
        dbname: string;
        /**
         * The database hostname. Can be an IP or a FQDN.
         */
        host: string;
        /**
         * The database password.
         */
        password: string;
        /**
         * The database port (e.g. `5432`)
         */
        port: number;
        /**
         * The SQL query that will be executed when receiving a message ($TOPIC and $PAYLOAD variables are available, see documentation, e.g. `INSERT INTO mytable(date, topic, value) VALUES (NOW(), $TOPIC, $PAYLOAD)`).
         */
        query: string;
        /**
         * The database username.
         */
        username: string;
    }

    export interface RouteRest {
        /**
         * a map of the extra headers to send with the HTTP call (e.g. `X-Header = Value`).
         */
        headers: {[key: string]: string};
        /**
         * The URI of the Rest endpoint (e.g. `https://internal.mycompany.com/ingest/mqttdata`).
         */
        uri: string;
        /**
         * The HTTP Verb used to call Rest URI (e.g. `post`).
         */
        verb: string;
    }

    export interface RouteS3 {
        /**
         * The name of the S3 route's destination bucket (e.g. `my-object-storage`).
         */
        bucketName: string;
        /**
         * The region of the S3 route's destination bucket (e.g. `fr-par`).
         */
        bucketRegion: string;
        /**
         * The string to prefix object names with (e.g. `mykeyprefix-`).
         */
        objectPrefix?: string;
        /**
         * How the S3 route's objects will be created (e.g. `perTopic`). See [documentation](https://www.scaleway.com/en/docs/iot-hub/how-to/create-route/) for behaviour details.
         */
        strategy: string;
    }

}

export namespace ipam {
    export interface GetIpResource {
        /**
         * The ID of the resource that the IP is attached to.
         */
        id?: string;
        /**
         * The name of the resource the IP is attached to.
         */
        name?: string;
        /**
         * The type of the resource the IP is attached to. [Documentation](https://pkg.go.dev/github.com/scaleway/scaleway-sdk-go@master/api/ipam/v1#pkg-constants) with type list.
         */
        type: string;
    }

    export interface GetIpsIp {
        /**
         * The Scaleway internal IP address of the resource.
         */
        address: string;
        /**
         * The date and time of the creation of the IP.
         */
        createdAt: string;
        /**
         * The ID of the resource.
         */
        id: string;
        /**
         * The ID of the Project to filter for.
         */
        projectId: string;
        /**
         * The region to filter for.
         */
        region: string;
        /**
         * Filter for a resource attached to the IP, using resource ID, type or name.
         */
        resources: outputs.ipam.GetIpsIpResource[];
        /**
         * The IP tags to filter for.
         */
        tags: string[];
        /**
         * The date and time of the last update of the IP.
         */
        updatedAt: string;
        /**
         * The zone of the IP.
         */
        zone: string;
    }

    export interface GetIpsIpResource {
        /**
         * The ID of the attached resource.
         */
        id: string;
        /**
         * The linked MAC address to filter for.
         */
        macAddress: string;
        /**
         * The name of the attached resource.
         */
        name: string;
        /**
         * The type of the attached resource. [Documentation](https://pkg.go.dev/github.com/scaleway/scaleway-sdk-go@master/api/ipam/v1#pkg-constants) with type list.
         */
        type: string;
    }

    export interface GetIpsResource {
        /**
         * The ID of the attached resource.
         */
        id?: string;
        /**
         * The name of the attached resource.
         */
        name?: string;
        /**
         * The type of the attached resource. [Documentation](https://pkg.go.dev/github.com/scaleway/scaleway-sdk-go@master/api/ipam/v1#pkg-constants) with type list.
         */
        type: string;
    }

    export interface IpCustomResource {
        /**
         * The MAC address of the resource the IP is attached to.
         */
        macAddress: string;
        /**
         * The name of the resource the IP is attached to.
         */
        name?: string;
    }

    export interface IpResource {
        /**
         * The ID of the resource that the IP is attached to.
         */
        id: string;
        /**
         * The MAC address of the resource the IP is attached to.
         */
        macAddress: string;
        /**
         * The name of the resource the IP is attached to.
         */
        name: string;
        /**
         * The type of resource the IP is attached to.
         */
        type: string;
    }

    export interface IpReverse {
        /**
         * The IP corresponding to the hostname
         */
        address: string;
        /**
         * The reverse domain name.
         */
        hostname: string;
    }

    export interface IpSource {
        /**
         * The Private Network of the IP (if the IP is a private IP).
         */
        privateNetworkId: string;
        /**
         * The Private Network subnet of the IP (if the IP is a private IP).
         */
        subnetId: string;
        /**
         * The zone of the IP (if the IP is public and zoned, rather than private and/or regional)
         */
        zonal: string;
    }

}

export namespace job {
    export interface DefinitionCron {
        /**
         * Cron format string.
         */
        schedule: string;
        /**
         * The timezone, must be a canonical TZ identifier as found in this [list](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones).
         */
        timezone: string;
    }

    export interface DefinitionSecretReference {
        /**
         * An environment variable containing the secret value. Must be specified if `file` is not specified.
         */
        environment?: string;
        /**
         * The absolute file path where the secret will be mounted. Must be specified if `environment` is not specified.
         */
        file?: string;
        /**
         * The secret unique identifier, it could be formatted as region/UUID or UUID. In case the region is passed, it must be the same as the job definition. You could reference the same secret multiple times in the same job definition.
         */
        secretId: string;
        /**
         * The secret reference UUID that is automatically generated by the provider.
         */
        secretReferenceId: string;
        /**
         * The secret version.
         */
        secretVersion?: string;
    }

}

export namespace kubernetes {
    export interface AclAclRule {
        /**
         * A text describing this rule.
         */
        description?: string;
        /**
         * The ID of the ACL resource. It is the same as the ID of the cluster.
         */
        id: string;
        /**
         * The IP range to whitelist in [CIDR notation](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#CIDR_notation)
         *
         * > **Important:** If the `ip` field is set, `scalewayRanges` cannot be set to true in the same rule.
         */
        ip?: string;
        /**
         * Allow access to cluster from all Scaleway ranges as defined in [Scaleway Network Information - IP ranges used by Scaleway](https://www.scaleway.com/en/docs/console/account/reference-content/scaleway-network-information/#ip-ranges-used-by-scaleway).
         * Only one rule with this field set to true can be added.
         *
         * > **Important:** If the `scalewayRanges` field is set to true, the `ip` field cannot be set on the same rule.
         */
        scalewayRanges?: boolean;
    }

    export interface ClusterAutoUpgrade {
        /**
         * Set to `true` to enable Kubernetes patch version auto upgrades.
         * > **Important:** When enabling auto upgrades, the `version` field take a minor version like x.y (ie 1.18).
         */
        enable: boolean;
        /**
         * The day of the auto upgrade maintenance window (`monday` to `sunday`, or `any`).
         */
        maintenanceWindowDay: string;
        /**
         * The start hour (UTC) of the 2-hour auto upgrade maintenance window (0 to 23).
         */
        maintenanceWindowStartHour: number;
    }

    export interface ClusterAutoscalerConfig {
        /**
         * Detect similar node groups and balance the number of nodes between them.
         */
        balanceSimilarNodeGroups?: boolean;
        /**
         * Disables the scale down feature of the autoscaler.
         */
        disableScaleDown?: boolean;
        /**
         * Type of resource estimator to be used in scale up.
         */
        estimator?: string;
        /**
         * Type of node group expander to be used in scale up.
         */
        expander?: string;
        /**
         * Pods with priority below cutoff will be expendable. They can be killed without any consideration during scale down and they don't cause scale up. Pods with null priority (PodPriority disabled) are non expendable.
         */
        expendablePodsPriorityCutoff?: number;
        /**
         * Ignore DaemonSet pods when calculating resource utilization for scaling down.
         */
        ignoreDaemonsetsUtilization?: boolean;
        /**
         * Maximum number of seconds the cluster autoscaler waits for pod termination when trying to scale down a node
         */
        maxGracefulTerminationSec?: number;
        /**
         * How long after scale up that scale down evaluation resumes.
         */
        scaleDownDelayAfterAdd?: string;
        /**
         * How long a node should be unneeded before it is eligible for scale down.
         */
        scaleDownUnneededTime?: string;
        /**
         * Node utilization level, defined as sum of requested resources divided by capacity, below which a node can be considered for scale down
         */
        scaleDownUtilizationThreshold?: number;
    }

    export interface ClusterKubeconfig {
        /**
         * The CA certificate of the Kubernetes API server.
         */
        clusterCaCertificate: string;
        /**
         * The raw kubeconfig file.
         */
        configFile: string;
        /**
         * The URL of the Kubernetes API server.
         */
        host: string;
        /**
         * The token to connect to the Kubernetes API server.
         */
        token: string;
    }

    export interface ClusterOpenIdConnectConfig {
        /**
         * A client id that all tokens must be issued for
         */
        clientId: string;
        /**
         * JWT claim to use as the user's group
         */
        groupsClaims?: string[];
        /**
         * Prefix prepended to group claims
         */
        groupsPrefix?: string;
        /**
         * URL of the provider which allows the API server to discover public signing keys
         */
        issuerUrl: string;
        /**
         * Multiple key=value pairs that describes a required claim in the ID Token
         */
        requiredClaims?: string[];
        /**
         * JWT claim to use as the user name
         */
        usernameClaim?: string;
        /**
         * Prefix prepended to username
         */
        usernamePrefix?: string;
    }

    export interface GetClusterAutoUpgrade {
        /**
         * True if Kubernetes patch version auto upgrades is enabled.
         */
        enable: boolean;
        /**
         * The day of the auto upgrade maintenance window (`monday` to `sunday`, or `any`).
         */
        maintenanceWindowDay: string;
        /**
         * The start hour (UTC) of the 2-hour auto upgrade maintenance window (0 to 23).
         */
        maintenanceWindowStartHour: number;
    }

    export interface GetClusterAutoscalerConfig {
        /**
         * True if detecting similar node groups and balance the number of nodes between them is enabled.
         */
        balanceSimilarNodeGroups: boolean;
        /**
         * True if the scale down feature of the autoscaler is disabled.
         */
        disableScaleDown: boolean;
        /**
         * The type of resource estimator used in scale up.
         */
        estimator: string;
        /**
         * The type of node group expander be used in scale up.
         */
        expander: string;
        /**
         * Pods with priority below cutoff will be expendable. They can be killed without any consideration during scale down and they don't cause scale up. Pods with null priority (PodPriority disabled) are non expendable.
         */
        expendablePodsPriorityCutoff: number;
        /**
         * True if ignoring DaemonSet pods when calculating resource utilization for scaling down is enabled.
         */
        ignoreDaemonsetsUtilization: boolean;
        /**
         * Maximum number of seconds the cluster autoscaler waits for pod termination when trying to scale down a node
         */
        maxGracefulTerminationSec: number;
        /**
         * The duration after scale up that scale down evaluation resumes.
         */
        scaleDownDelayAfterAdd: string;
        /**
         * The duration a node should be unneeded before it is eligible for scale down.
         */
        scaleDownUnneededTime: string;
        /**
         * Node utilization level, defined as sum of requested resources divided by capacity, below which a node can be considered for scale down
         */
        scaleDownUtilizationThreshold: number;
    }

    export interface GetClusterKubeconfig {
        /**
         * The CA certificate of the Kubernetes API server.
         */
        clusterCaCertificate: string;
        /**
         * The raw kubeconfig file.
         */
        configFile: string;
        /**
         * The URL of the Kubernetes API server.
         */
        host: string;
        /**
         * The token to connect to the Kubernetes API server.
         */
        token: string;
    }

    export interface GetClusterOpenIdConnectConfig {
        /**
         * A client id that all tokens must be issued for
         */
        clientId: string;
        /**
         * JWT claim to use as the user's group
         */
        groupsClaims: string[];
        /**
         * Prefix prepended to group claims
         */
        groupsPrefix: string;
        /**
         * URL of the provider which allows the API server to discover public signing keys
         */
        issuerUrl: string;
        /**
         * Multiple key=value pairs that describes a required claim in the ID Token
         */
        requiredClaims: string[];
        /**
         * JWT claim to use as the user name
         */
        usernameClaim: string;
        /**
         * Prefix prepended to username
         */
        usernamePrefix: string;
    }

    export interface GetPoolNode {
        /**
         * The ID of the pool.
         */
        id: string;
        /**
         * The pool name. Only one of `name` and `poolId` should be specified. `clusterId` should be specified with `name`.
         */
        name: string;
        /**
         * List of private IPv4 and IPv6 addresses associated with the node
         */
        privateIps: outputs.kubernetes.GetPoolNodePrivateIp[];
        /**
         * The public IPv4.
         */
        publicIp: string;
        /**
         * The public IPv6.
         */
        publicIpV6: string;
        /**
         * The status of the node.
         */
        status: string;
    }

    export interface GetPoolNodePrivateIp {
        /**
         * The private IP address
         */
        address: string;
        /**
         * The ID of the pool.
         */
        id: string;
    }

    export interface GetPoolUpgradePolicy {
        /**
         * The maximum number of nodes to be created during the upgrade
         */
        maxSurge: number;
        /**
         * The maximum number of nodes that can be not ready at the same time
         */
        maxUnavailable: number;
    }

    export interface PoolNode {
        /**
         * The ID of the IP address resource.
         */
        id: string;
        /**
         * The name for the pool.
         *
         * > **Important:** Updates to this field will recreate a new resource.
         */
        name: string;
        /**
         * The list of private IPv4 and IPv6 addresses associated with the node.
         */
        privateIps: outputs.kubernetes.PoolNodePrivateIp[];
        /**
         * The public IPv4. (Deprecated, Please use the official Kubernetes provider and the kubernetesNodes data source)
         *
         * @deprecated Please use the official Kubernetes provider and the kubernetesNodes data source
         */
        publicIp: string;
        /**
         * The public IPv6. (Deprecated, Please use the official Kubernetes provider and the kubernetesNodes data source)
         *
         * @deprecated Please use the official Kubernetes provider and the kubernetesNodes data source
         */
        publicIpV6: string;
        /**
         * The status of the node.
         */
        status: string;
    }

    export interface PoolNodePrivateIp {
        /**
         * The private IP address.
         */
        address: string;
        /**
         * The ID of the IP address resource.
         */
        id: string;
    }

    export interface PoolUpgradePolicy {
        /**
         * The maximum number of nodes to be created during the upgrade
         */
        maxSurge?: number;
        /**
         * The maximum number of nodes that can be not ready at the same time
         */
        maxUnavailable?: number;
    }

}

export namespace loadbalancers {
    export interface AclAction {
        /**
         * Redirect parameters when using an ACL with `redirect` action.
         */
        redirects?: outputs.loadbalancers.AclActionRedirect[];
        /**
         * The action type. Possible values are: `allow` or `deny` or `redirect`.
         */
        type: string;
    }

    export interface AclActionRedirect {
        /**
         * The HTTP redirect code to use. Valid values are `301`, `302`, `303`, `307` and `308`.
         */
        code?: number;
        /**
         * An URL can be used in case of a location redirect (e.g. `https://scaleway.com` will redirect to this same URL). A scheme name (e.g. `https`, `http`, `ftp`, `git`) will replace the request's original scheme.
         */
        target?: string;
        /**
         * The redirect type. Possible values are: `location` or `scheme`.
         */
        type?: string;
    }

    export interface AclMatch {
        /**
         * The HTTP filter to match. This filter is supported only if your backend protocol has an HTTP forward protocol.
         * It extracts the request's URL path, which starts at the first slash and ends before the question mark (without the host part).
         * Possible values are: `aclHttpFilterNone`, `pathBegin`, `pathEnd`, `httpHeaderMatch` or `regex`.
         */
        httpFilter?: string;
        /**
         * If you have `httpFilter` at `httpHeaderMatch`, you can use this field to filter on the HTTP header's value.
         */
        httpFilterOption?: string;
        /**
         * A list of possible values to match for the given HTTP filter.
         * Keep in mind that in the case of `httpHeaderMatch` the HTTP header field name is case insensitive.
         */
        httpFilterValues?: string[];
        /**
         * If set to `true`, the condition will be of type "unless".
         */
        invert?: boolean;
        /**
         * A list of IPs, or CIDR v4/v6 addresses of the session client, to match. Only one of `ipSubnet` and `ipsEdgeServices` should be specified.
         */
        ipSubnets?: string[];
        /**
         * Defines whether Edge Services IPs should be matched. Only one of `ipSubnet` and `ipsEdgeServices` should be specified.
         */
        ipsEdgeServices?: boolean;
    }

    export interface BackendHealthCheckHttp {
        /**
         * The expected HTTP status code
         */
        code?: number;
        /**
         * The HTTP host header to use for HC requests
         */
        hostHeader?: string;
        /**
         * The HTTP method to use for HC requests
         */
        method?: string;
        /**
         * The HTTP endpoint URL to call for HC requests
         */
        uri: string;
    }

    export interface BackendHealthCheckHttps {
        /**
         * The expected HTTP status code
         */
        code?: number;
        /**
         * The HTTP host header to use for HC requests
         */
        hostHeader?: string;
        /**
         * The HTTP method to use for HC requests
         */
        method?: string;
        /**
         * The SNI to use for HC requests over SSL
         */
        sni?: string;
        /**
         * The HTTPS endpoint URL to call for HC requests
         */
        uri: string;
    }

    export interface BackendHealthCheckTcp {
    }

    export interface CertificateCustomCertificate {
        /**
         * The full PEM-formatted certificate chain
         */
        certificateChain: string;
    }

    export interface CertificateLetsencrypt {
        /**
         * Main domain of the certificate
         */
        commonName: string;
        /**
         * The alternative domain names of the certificate
         */
        subjectAlternativeNames?: string[];
    }

    export interface FrontendAcl {
        /**
         * Action to undertake when an ACL filter matches.
         */
        action: outputs.loadbalancers.FrontendAclAction;
        /**
         * The date and time the frontend was created.
         */
        createdAt: string;
        /**
         * Description of the ACL
         */
        description?: string;
        /**
         * The ACL match rule. At least `ipSubnet` or `ipsEdgeServices` or `httpFilter` and `httpFilterValue` are required.
         */
        match: outputs.loadbalancers.FrontendAclMatch;
        /**
         * The ACL name. If not provided it will be randomly generated.
         */
        name: string;
        /**
         * The date and time the frontend resource was updated.
         */
        updatedAt: string;
    }

    export interface FrontendAclAction {
        /**
         * Redirect parameters when using an ACL with `redirect` action.
         */
        redirects?: outputs.loadbalancers.FrontendAclActionRedirect[];
        /**
         * The action type. Possible values are: `allow` or `deny` or `redirect`.
         */
        type: string;
    }

    export interface FrontendAclActionRedirect {
        /**
         * The HTTP redirect code to use. Valid values are `301`, `302`, `303`, `307` and `308`.
         */
        code?: number;
        /**
         * A URL can be used in case of a location redirect (e.g. `https://scaleway.com` will redirect to this same URL). A scheme name (e.g. `https`, `http`, `ftp`, `git`) will replace the request's original scheme.
         */
        target?: string;
        /**
         * The redirect type. Possible values are: `location` or `scheme`.
         */
        type?: string;
    }

    export interface FrontendAclMatch {
        /**
         * The HTTP filter to match. This filter is supported only if your backend protocol has an HTTP forward protocol.
         * It extracts the request's URL path, which starts at the first slash and ends before the question mark (without the host part).
         * Possible values are: `aclHttpFilterNone`, `pathBegin`, `pathEnd`, `httpHeaderMatch` or `regex`.
         */
        httpFilter?: string;
        /**
         * If you have `httpFilter` at `httpHeaderMatch`, you can use this field to filter on the HTTP header's value.
         */
        httpFilterOption?: string;
        /**
         * A list of possible values to match for the given HTTP filter.
         * Keep in mind that in the case of `httpHeaderMatch` the HTTP header field name is case insensitive.
         */
        httpFilterValues?: string[];
        /**
         * If set to `true`, the condition will be of type "unless".
         */
        invert?: boolean;
        /**
         * A list of IPs, or CIDR v4/v6 addresses of the session client, to match. Only one of `ipSubnet` and `ipsEdgeServices` should be specified.
         */
        ipSubnets?: string[];
        /**
         * Defines whether Edge Services IPs should be matched. Only one of `ipSubnet` and `ipsEdgeServices` should be specified.
         */
        ipsEdgeServices?: boolean;
    }

    export interface GetAclsAcl {
        /**
         * The action to be undertaken when an ACL filter matches.
         */
        actions: outputs.loadbalancers.GetAclsAclAction[];
        /**
         * The date on which the ACL was created (RFC 3339 format).
         */
        createdAt: string;
        /**
         * The description of the ACL resource.
         */
        description: string;
        /**
         * The frontend ID this ACL is attached to. ACLs with a matching frontend ID are listed.
         * > **Important:** LB frontend IDs are zoned, which means they are of the form `{zone}/{id}`, e.g. `fr-par-1/11111111-1111-1111-1111-111111111111`
         */
        frontendId: string;
        /**
         * The associated ACL ID.
         * > **Important:** LB ACLs' IDs are zoned, which means they are of the form `{zone}/{id}`, e.g. `fr-par-1/11111111-1111-1111-1111-111111111111`
         */
        id: string;
        /**
         * The priority of this ACL in the ordered list.
         */
        index: number;
        /**
         * The ACL match rule.
         */
        matches: outputs.loadbalancers.GetAclsAclMatch[];
        /**
         * The ACL name to filter for. ACLs with a matching name are listed.
         */
        name: string;
        /**
         * The date on which the ACL was last updated (RFC 3339 format).
         */
        updateAt: string;
    }

    export interface GetAclsAclAction {
        /**
         * Redirect parameters when using an ACL with `redirect` action.
         */
        redirects: outputs.loadbalancers.GetAclsAclActionRedirect[];
        /**
         * The redirect type.
         */
        type: string;
    }

    export interface GetAclsAclActionRedirect {
        /**
         * The HTTP redirect code to use.
         */
        code: number;
        /**
         * The URL used in case of a location redirect, or the scheme name that replaces the request's original scheme.
         */
        target: string;
        /**
         * The redirect type.
         */
        type: string;
    }

    export interface GetAclsAclMatch {
        /**
         * The HTTP filter to match.
         */
        httpFilter: string;
        /**
         * A list of possible values for the HTTP filter based on the HTTP header.
         */
        httpFilterOption: string;
        /**
         * The possible values to match for a given HTTP filter.
         */
        httpFilterValues: string[];
        /**
         * The condition will be of type "unless" if invert is set to `true`
         */
        invert: boolean;
        /**
         * A list of IPs, or CIDR v4/v6 addresses of the session client, to match.
         */
        ipSubnets: string[];
        /**
         * Defines whether Edge Services IPs should be matched.
         */
        ipsEdgeServices: boolean;
    }

    export interface GetBackendHealthCheckHttp {
        /**
         * The expected HTTP status code
         */
        code: number;
        /**
         * The HTTP host header to use for HC requests
         */
        hostHeader: string;
        /**
         * The HTTP method to use for HC requests
         */
        method: string;
        /**
         * The SNI to use for HC requests over SSL
         */
        sni: string;
        /**
         * The HTTPS endpoint URL to call for HC requests
         */
        uri: string;
    }

    export interface GetBackendHealthCheckTcp {
    }

    export interface GetBackendsBackend {
        /**
         * The date on which the backend was created (RFC 3339 format).
         */
        createdAt: string;
        /**
         * Scaleway S3 bucket website to be served if all backend servers are down.
         */
        failoverHost: string;
        /**
         * User sessions will be forwarded to this backend server port.
         */
        forwardPort: number;
        /**
         * Load balancing algorithm.
         */
        forwardPortAlgorithm: string;
        /**
         * Backend protocol.
         */
        forwardProtocol: string;
        /**
         * Interval between two health check requests.
         */
        healthCheckDelay: string;
        /**
         * This block enables HTTP health checks.
         */
        healthCheckHttp: outputs.loadbalancers.GetBackendsBackendHealthCheckHttp[];
        /**
         * This block enables HTTPS health checks.
         */
        healthCheckHttps: outputs.loadbalancers.GetBackendsBackendHealthCheckHttp[];
        /**
         * Number of allowed failed health check requests before the backend server is marked as down.
         */
        healthCheckMaxRetries: number;
        /**
         * Port the health check requests will be sent to.
         */
        healthCheckPort: number;
        /**
         * This block enables TCP health checks.
         */
        healthCheckTcps: outputs.loadbalancers.GetBackendsBackendHealthCheckTcp[];
        /**
         * Timeout before a health check request is considered failed.
         */
        healthCheckTimeout: string;
        /**
         * The associated backend ID.
         */
        id: string;
        /**
         * Specifies whether the Load Balancer should check the backend serverâ€™s certificate before initiating a connection.
         */
        ignoreSslServerVerify: boolean;
        /**
         * The Load Balancer ID this backend is attached to. Backends with a matching ID are listed.
         */
        lbId: string;
        /**
         * The backend name to filter for. Backends with a matching name are listed.
         */
        name: string;
        /**
         * Modify what occurs when a backend server is marked down.
         */
        onMarkedDownAction: string;
        /**
         * The type of PROXY protocol.
         */
        proxyProtocol: string;
        /**
         * List of backend server IP addresses.
         */
        serverIps: string[];
        /**
         * Enables SSL between Load Balancer and backend servers.
         */
        sslBridging: boolean;
        /**
         * Enables cookie-based session persistence.
         */
        stickySessions: string;
        /**
         * Cookie name for sticky sessions.
         */
        stickySessionsCookieName: string;
        /**
         * Maximum initial server connection establishment time.
         */
        timeoutConnect: string;
        /**
         * Maximum server connection inactivity time.
         */
        timeoutServer: string;
        /**
         * Maximum tunnel inactivity time.
         */
        timeoutTunnel: string;
        /**
         * The date on which the backend was last updated (RFC 3339 format).
         */
        updateAt: string;
    }

    export interface GetBackendsBackendHealthCheckHttp {
        /**
         * The expected HTTP status code.
         */
        code: number;
        /**
         * The HTTP host header to use for health check requests.
         */
        hostHeader: string;
        /**
         * The HTTP method to use for health check requests.
         */
        method: string;
        /**
         * The SNI to use for HC requests over SSL.
         */
        sni: string;
        /**
         * The path of health check requests.
         */
        uri: string;
    }

    export interface GetBackendsBackendHealthCheckTcp {
    }

    export interface GetCertificateCustomCertificate {
        /**
         * The full PEM-formatted certificate chain
         */
        certificateChain: string;
    }

    export interface GetCertificateLetsencrypt {
        /**
         * The main domain name of the certificate
         */
        commonName: string;
        /**
         * The alternative domain names of the certificate
         */
        subjectAlternativeNames: string[];
    }

    export interface GetFrontendAcl {
        /**
         * Action to undertake when an ACL filter matches
         */
        actions: outputs.loadbalancers.GetFrontendAclAction[];
        /**
         * IsDate and time of ACL's creation (RFC 3339 format)
         */
        createdAt: string;
        /**
         * Description of the ACL
         */
        description: string;
        /**
         * The ACL match rule
         */
        matches: outputs.loadbalancers.GetFrontendAclMatch[];
        /**
         * The name of the frontend.
         * - When using the `name` you should specify the `lb-id`
         */
        name: string;
        /**
         * IsDate and time of ACL's update (RFC 3339 format)
         */
        updatedAt: string;
    }

    export interface GetFrontendAclAction {
        /**
         * Redirect parameters when using an ACL with `redirect` action
         */
        redirects: outputs.loadbalancers.GetFrontendAclActionRedirect[];
        /**
         * The action type
         */
        type: string;
    }

    export interface GetFrontendAclActionRedirect {
        /**
         * The HTTP redirect code to use
         */
        code: number;
        /**
         * An URL can be used in case of a location redirect
         */
        target: string;
        /**
         * The redirect type
         */
        type: string;
    }

    export interface GetFrontendAclMatch {
        /**
         * The HTTP filter to match
         */
        httpFilter: string;
        /**
         * You can use this field with httpHeaderMatch acl type to set the header name to filter
         */
        httpFilterOption: string;
        /**
         * A list of possible values to match for the given HTTP filter
         */
        httpFilterValues: string[];
        /**
         * If set to true, the condition will be of type "unless"
         */
        invert: boolean;
        /**
         * A list of IPs or CIDR v4/v6 addresses of the client of the session to match
         */
        ipSubnets: string[];
        /**
         * Defines whether Edge Services IPs should be matched
         */
        ipsEdgeServices: boolean;
    }

    export interface GetFrontendsFrontend {
        /**
         * The Load Balancer backend ID this frontend is attached to.
         * > **Important:** Load Balancer backend IDs are zoned, which means they are of the form `{zone}/{id}`, e.g. `fr-par-1/11111111-1111-1111-1111-111111111111`
         */
        backendId: string;
        /**
         * List of certificate IDs that are used by the frontend.
         */
        certificateIds: string[];
        /**
         * The rate limit for new connections established on this frontend. Use 0 value to disable, else value is connections per second.
         */
        connectionRateLimit: number;
        /**
         * The date on which the frontend was created (RFC 3339 format).
         */
        createdAt: string;
        /**
         * Defines whether to enable access logs on the frontend.
         */
        enableAccessLogs: boolean;
        /**
         * Whether HTTP/3 protocol is activated.
         */
        enableHttp3: boolean;
        /**
         * The ID of the associated frontend.
         * > **Important:** LB frontend IDs are zoned, which means they are of the form `{zone}/{id}`, e.g. `fr-par-1/11111111-1111-1111-1111-111111111111`
         */
        id: string;
        /**
         * TCP port the frontend listens to.
         */
        inboundPort: number;
        /**
         * The Load Balancer ID this frontend is attached to. Frontends with a matching ID are listed.
         */
        lbId: string;
        /**
         * The frontend name to filter for. Frontends with a matching name are listed.
         */
        name: string;
        /**
         * Maximum inactivity time on the client side.
         */
        timeoutClient: string;
        /**
         * The date on which the frontend was last updated (RFC 3339 format).
         */
        updateAt: string;
    }

    export interface GetIpsIp {
        /**
         * The ID of the associated IP.
         */
        id: string;
        /**
         * The IP address
         */
        ipAddress: string;
        /**
         * The ID of the associated Load BalancerD, if any
         */
        lbId: string;
        /**
         * The ID of the Organization the Load Balancer is associated with.
         */
        organizationId: string;
        /**
         * The ID of the Project the Load Balancer is associated with.
         */
        projectId: string;
        /**
         * The reverse domain associated with this IP.
         */
        reverse: string;
        /**
         * List of tags used as filter. IPs with these exact tags are listed.
         */
        tags: string[];
        /**
         * `zone`) The zone in which the IPs exist.
         */
        zone?: string;
    }

    export interface GetLoadBalancerPrivateIp {
        /**
         * The private IP address
         */
        address: string;
        /**
         * The ID of the Load Balancer.
         */
        id: string;
    }

    export interface GetLoadBalancerPrivateNetwork {
        /**
         * Set to true if you want to let DHCP assign IP addresses
         */
        dhcpConfig: boolean;
        /**
         * IPAM ID of a pre-reserved IP address to assign to the Load Balancer on this Private Network
         */
        ipamIds: string[];
        /**
         * The Private Network ID
         */
        privateNetworkId: string;
        /**
         * Define an IP address in the subnet of your private network that will be assigned to your load balancer instance
         */
        staticConfigs: string[];
        /**
         * The status of private network connection
         */
        status: string;
        /**
         * (Defaults to provider `zone`) The zone in which the Load Balancer exists.
         */
        zone: string;
    }

    export interface GetLoadBalancersLb {
        /**
         * Number of backends the Load Balancer has.
         */
        backendCount: number;
        /**
         * Date on which the Load Balancer was created.
         */
        createdAt: string;
        /**
         * The description of the Load Balancer.
         */
        description: string;
        /**
         * Number of frontends the Load Balancer has.
         */
        frontendCount: number;
        /**
         * The ID of the Load Balancer.
         */
        id: string;
        /**
         * List of underlying Instances.
         */
        instances: outputs.loadbalancers.GetLoadBalancersLbInstance[];
        /**
         * List of IPs attached to the Load Balancer.
         */
        ips: outputs.loadbalancers.GetLoadBalancersLbIp[];
        /**
         * The Load Balancer name to filter for. Load Balancers with a matching name are listed.
         */
        name: string;
        /**
         * The ID of the Organization the Load Balancer is associated with.
         */
        organizationId: string;
        /**
         * Number of Private Networks attached to the Load balancer.
         */
        privateNetworkCount: number;
        /**
         * The ID of the Project the Load Balancer is associated with.
         */
        projectId: string;
        /**
         * Number of routes the Load balancer has.
         */
        routeCount: number;
        /**
         * Determines the minimal SSL version which needs to be supported on the client side.
         */
        sslCompatibilityLevel: string;
        /**
         * The state of the Load Balancer Instance. Possible values are: `unknown`, `ready`, `pending`, `stopped`, `error`, `locked` and `migrating`.
         */
        status: string;
        /**
         * The subscriber information.
         */
        subscriber: string;
        /**
         * List of tags to filter for. Load Balancers with these exact tags are listed.
         */
        tags: string[];
        /**
         * The offer type of the Load Balancer.
         */
        type: string;
        /**
         * Date on which the Load Balancer was updated.
         */
        updatedAt: string;
        /**
         * `zone`) The zone in which the Load Balancers exist.
         */
        zone?: string;
    }

    export interface GetLoadBalancersLbInstance {
        /**
         * Date on which the Load Balancer was created.
         */
        createdAt: string;
        /**
         * The ID of the Load Balancer.
         */
        id: string;
        /**
         * IP address of the instance
         */
        ipAddress: string;
        /**
         * The state of the Load Balancer Instance. Possible values are: `unknown`, `ready`, `pending`, `stopped`, `error`, `locked` and `migrating`.
         */
        status: string;
        /**
         * Date on which the Load Balancer was updated.
         */
        updatedAt: string;
        /**
         * `zone`) The zone in which the Load Balancers exist.
         */
        zone?: string;
    }

    export interface GetLoadBalancersLbIp {
        /**
         * The ID of the Load Balancer.
         */
        id: string;
        /**
         * IP address
         */
        ipAddress: string;
        /**
         * UUID of the load balancer attached to the IP
         */
        lbId: string;
        /**
         * The ID of the Organization the Load Balancer is associated with.
         */
        organizationId: string;
        /**
         * The ID of the Project the Load Balancer is associated with.
         */
        projectId: string;
        /**
         * Reverse DNS attached to the IP
         */
        reverse: string;
        /**
         * `zone`) The zone in which the Load Balancers exist.
         */
        zone?: string;
    }

    export interface GetRoutesRoute {
        /**
         * The backend ID to redirect to
         */
        backendId: string;
        /**
         * The date on which the route was created (RFC 3339 format).
         */
        createdAt: string;
        /**
         * The frontend ID (the origin of the redirection), to filter for. Routes with a matching frontend ID are listed.
         */
        frontendId: string;
        /**
         * The associated route ID.
         */
        id: string;
        /**
         * Specifies the host of the server to which the request is being sent.
         */
        matchHostHeader: string;
        /**
         * Server Name Indication TLS extension field from an incoming connection made via an SSL/TLS transport layer.
         */
        matchSni: string;
        /**
         * If true, all subdomains will match.
         */
        matchSubdomains: boolean;
        /**
         * The date on which the route was last updated (RFC 3339 format).
         */
        updateAt: string;
    }

    export interface LoadBalancerPrivateIp {
        /**
         * The private IP address.
         */
        address: string;
        /**
         * The ID of the IP address resource.
         */
        id: string;
    }

    export interface LoadBalancerPrivateNetwork {
        /**
         * Set to true if you want to let DHCP assign IP addresses
         *
         * @deprecated dhcp_config field is deprecated, please use `privateNetworkId` or `ipamIds` instead
         */
        dhcpConfig: boolean;
        /**
         * IPAM ID of a pre-reserved IP address to assign to the Load Balancer on this Private Network.
         */
        ipamIds: string;
        /**
         * The ID of the Private Network to attach to.
         * - > **Important:** Updates to `privateNetwork` will recreate the attachment.
         */
        privateNetworkId: string;
        /**
         * Define an IP address in the subnet of your private network that will be assigned to your load balancer instance
         *
         * @deprecated static_config field is deprecated, please use `privateNetworkId` or `ipamIds` instead
         */
        staticConfigs: string[];
        /**
         * The status of the private network connection.
         */
        status: string;
        /**
         * `zone`) The zone of the Load Balancer.
         */
        zone: string;
    }

}

export namespace mnq {
    export interface SnsCredentialsPermissions {
        /**
         * . Defines whether the user can manage the associated resource(s).
         */
        canManage: boolean;
        /**
         * . Defines whether the user can publish messages to the service.
         */
        canPublish: boolean;
        /**
         * . Defines whether the user can receive messages from the service.
         */
        canReceive: boolean;
    }

    export interface SqsCredentialsPermissions {
        /**
         * . Defines whether the user can manage the associated resource(s).
         */
        canManage: boolean;
        /**
         * . Defines whether the user can publish messages to the service.
         */
        canPublish: boolean;
        /**
         * . Defines whether the user can receive messages from the service.
         */
        canReceive: boolean;
    }

    export interface SqsQueueDeadLetterQueue {
        /**
         * The ID of the queue with format `{region/{project-id}/{queue-name}`
         */
        id: string;
        /**
         * The number of times a message is delivered to the source queue before being sent to the dead-letter queue. Must be between 1 and 1,000.
         */
        maxReceiveCount: number;
    }

}

export namespace mongodb {
    export interface GetInstancePrivateIp {
        /**
         * The private IPv4 address
         */
        address: string;
        /**
         * The ID of the MongoDBÂ® Instance.
         */
        id: string;
    }

    export interface GetInstancePrivateNetwork {
        /**
         * List of DNS records for your endpoint
         */
        dnsRecords: string[];
        /**
         * The ID of the MongoDBÂ® Instance.
         */
        id: string;
        /**
         * List of IP addresses for your endpoint
         */
        ips: string[];
        /**
         * The private network ID
         */
        pnId: string;
        /**
         * TCP port of the endpoint
         */
        port: number;
    }

    export interface GetInstancePublicNetwork {
        /**
         * The DNS record of your endpoint
         */
        dnsRecord: string;
        /**
         * The ID of the MongoDBÂ® Instance.
         */
        id: string;
        /**
         * TCP port of the endpoint
         */
        port: number;
    }

    export interface InstancePrivateIp {
        /**
         * The private IPv4 address.
         */
        address: string;
        /**
         * The ID of the endpoint.
         */
        id: string;
    }

    export interface InstancePrivateNetwork {
        /**
         * List of DNS records for your endpoint.
         */
        dnsRecords: string[];
        /**
         * The ID of the endpoint.
         */
        id: string;
        /**
         * List of IP addresses for your endpoint.
         */
        ips: string[];
        /**
         * The ID of the Private Network.
         */
        pnId: string;
        /**
         * TCP port of the endpoint.
         */
        port: number;
    }

    export interface InstancePublicNetwork {
        /**
         * The DNS record of your endpoint
         */
        dnsRecord: string;
        /**
         * The ID of the endpoint.
         */
        id: string;
        /**
         * TCP port of the endpoint.
         */
        port: number;
    }

    export interface UserRole {
        /**
         * Apply the role to all databases. Cannot be used with `databaseName`.
         */
        anyDatabase?: boolean;
        /**
         * The database name for the role. Cannot be used with `anyDatabase`.
         */
        databaseName?: string;
        /**
         * The role name. Valid values are `read`, `readWrite`, `dbAdmin`, `sync`.
         */
        role: string;
    }

}

export namespace network {
    export interface AclRule {
        /**
         * The policy to apply to the packet.
         */
        action?: string;
        /**
         * The rule description.
         */
        description?: string;
        /**
         * The destination IP range to which this rule applies (CIDR notation with subnet mask).
         */
        destination?: string;
        /**
         * The ending port of the destination port range to which this rule applies (inclusive).
         */
        dstPortHigh?: number;
        /**
         * The starting port of the destination port range to which this rule applies (inclusive).
         */
        dstPortLow?: number;
        /**
         * The protocol to which this rule applies. Default value: ANY.
         */
        protocol?: string;
        /**
         * The Source IP range to which this rule applies (CIDR notation with subnet mask).
         */
        source?: string;
        /**
         * The ending port of the source port range to which this rule applies (inclusive).
         */
        srcPortHigh?: number;
        /**
         * The starting port of the source port range to which this rule applies (inclusive).
         */
        srcPortLow?: number;
    }

    export interface GatewayNetworkIpamConfig {
        /**
         * Use this IPAM-booked IP ID as the Gateway's IP in this Private Network.
         */
        ipamIpId: string;
        /**
         * Defines whether to enable the default route on the GatewayNetwork.
         */
        pushDefaultRoute?: boolean;
    }

    export interface GatewayNetworkPrivateIp {
        /**
         * The private IPv4 address.
         */
        address: string;
        /**
         * The ID of the IPv4 address resource.
         */
        id: string;
    }

    export interface GetGatewayNetworkIpamConfig {
        /**
         * Use this IPAM-booked IP ID as the Gateway's IP in this Private Network
         */
        ipamIpId: string;
        /**
         * Defines whether the default route is enabled on that Gateway Network
         */
        pushDefaultRoute: boolean;
    }

    export interface GetGatewayNetworkPrivateIp {
        /**
         * The private IPv4 address.
         */
        address: string;
        /**
         * The ID of the IPv4 address resource.
         */
        id: string;
    }

    export interface GetPrivateNetworkIpv4Subnet {
        /**
         * The network address of the subnet in dotted decimal notation, e.g., '192.168.0.0' for a '192.168.0.0/24' subnet
         */
        address: string;
        /**
         * The date and time of the creation of the subnet
         */
        createdAt: string;
        /**
         * The ID of the Private Network.
         */
        id: string;
        /**
         * The length of the network prefix, e.g., 24 for a 255.255.255.0 mask
         */
        prefixLength: number;
        /**
         * The subnet CIDR
         */
        subnet: string;
        /**
         * The subnet mask expressed in dotted decimal notation, e.g., '255.255.255.0' for a /24 subnet
         */
        subnetMask: string;
        /**
         * The date and time of the last update of the subnet
         */
        updatedAt: string;
    }

    export interface GetPrivateNetworkIpv6Subnet {
        /**
         * The network address of the subnet in dotted decimal notation, e.g., '192.168.0.0' for a '192.168.0.0/24' subnet
         */
        address: string;
        /**
         * The date and time of the creation of the subnet
         */
        createdAt: string;
        /**
         * The ID of the Private Network.
         */
        id: string;
        /**
         * The length of the network prefix, e.g., 24 for a 255.255.255.0 mask
         */
        prefixLength: number;
        /**
         * The subnet CIDR
         */
        subnet: string;
        /**
         * The subnet mask expressed in dotted decimal notation, e.g., '255.255.255.0' for a /24 subnet
         */
        subnetMask: string;
        /**
         * The date and time of the last update of the subnet
         */
        updatedAt: string;
    }

    export interface GetRoutesRoute {
        /**
         * The date on which the route was created (RFC 3339 format).
         */
        createdAt: string;
        /**
         * The description of the route.
         */
        description: string;
        /**
         * The destination IP or IP range of the route.
         */
        destination: string;
        /**
         * The ID of the route.
         * > **Important:** route IDs are regional, which means they are of the form `{region}/{id}`, e.g. `fr-par/11111111-1111-1111-1111-111111111111
         */
        id: string;
        /**
         * The IP of the route's next hop.
         */
        nexthopIp: string;
        /**
         * The name of the route's next hop.
         */
        nexthopName: string;
        /**
         * The next hop private network ID to filter for. routes with a similar next hop private network ID are listed.
         */
        nexthopPrivateNetworkId: string;
        /**
         * The next hop resource ID to filter for. routes with a similar next hop resource ID are listed.
         */
        nexthopResourceId: string;
        /**
         * The next hop resource type to filter for. routes with a similar next hop resource type are listed.
         */
        nexthopResourceType: string;
        /**
         * `region`). The region in which the routes exist.
         */
        region?: string;
        /**
         * List of tags to filter for. routes with these exact tags are listed.
         */
        tags: string[];
        /**
         * The VPC ID to filter for. routes with a similar VPC ID are listed.
         */
        vpcId: string;
    }

    export interface GetVpcsVpc {
        /**
         * Date and time of VPC's creation (RFC 3339 format).
         */
        createdAt: string;
        /**
         * The associated VPC ID.
         * > **Important:** VPC IDs are regional, which means they are of the form `{region}/{id}`, e.g. `fr-par/11111111-1111-1111-1111-111111111111
         */
        id: string;
        /**
         * Defines whether the VPC is the default one for its Project.
         */
        isDefault: boolean;
        /**
         * The VPC name to filter for. VPCs with a similar name are listed.
         */
        name: string;
        /**
         * The Organization ID the VPC is associated with.
         */
        organizationId: string;
        /**
         * The ID of the Project the VPC is associated with.
         */
        projectId: string;
        /**
         * `region`). The region in which the VPCs exist.
         */
        region?: string;
        /**
         * List of tags to filter for. VPCs with these exact tags are listed.
         */
        tags: string[];
        /**
         * Date on which the VPC was last updated (RFC 3339 format)
         */
        updateAt: string;
    }

    export interface PrivateNetworkIpv4Subnet {
        /**
         * The network address of the subnet in hexadecimal notation, e.g., '2001:db8::' for a '2001:db8::/64' subnet.
         */
        address: string;
        /**
         * The date and time of the creation of the subnet.
         */
        createdAt: string;
        /**
         * The subnet ID.
         */
        id: string;
        /**
         * The length of the network prefix, e.g., 64 for a 'ffff:ffff:ffff:ffff::' mask.
         */
        prefixLength: number;
        /**
         * The subnet CIDR.
         */
        subnet: string;
        /**
         * The subnet mask expressed in dotted decimal notation, e.g., '255.255.255.0' for a /24 subnet
         */
        subnetMask: string;
        /**
         * The date and time of the last update of the subnet.
         */
        updatedAt: string;
    }

    export interface PrivateNetworkIpv6Subnet {
        /**
         * The network address of the subnet in hexadecimal notation, e.g., '2001:db8::' for a '2001:db8::/64' subnet.
         */
        address: string;
        /**
         * The date and time of the creation of the subnet.
         */
        createdAt: string;
        /**
         * The subnet ID.
         */
        id: string;
        /**
         * The length of the network prefix, e.g., 64 for a 'ffff:ffff:ffff:ffff::' mask.
         */
        prefixLength: number;
        /**
         * The subnet CIDR.
         */
        subnet: string;
        /**
         * The subnet mask expressed in dotted decimal notation, e.g., '255.255.255.0' for a /24 subnet
         */
        subnetMask: string;
        /**
         * The date and time of the last update of the subnet.
         */
        updatedAt: string;
    }

}

export namespace object {
    export interface BucketAclAccessControlPolicy {
        /**
         * Grant
         */
        grants?: outputs.object.BucketAclAccessControlPolicyGrant[];
        /**
         * Configuration block of the bucket project owner's display organization ID.
         */
        owner: outputs.object.BucketAclAccessControlPolicyOwner;
    }

    export interface BucketAclAccessControlPolicyGrant {
        /**
         * Configuration block for the project being granted permissions.
         */
        grantee?: outputs.object.BucketAclAccessControlPolicyGrantGrantee;
        /**
         * Logging permissions assigned to the grantee for the bucket.
         */
        permission: string;
    }

    export interface BucketAclAccessControlPolicyGrantGrantee {
        /**
         * Display name of the grantee to grant access to.
         */
        displayName: string;
        /**
         * The `region`, `bucket` and `acl` separated by (`/`).
         */
        id?: string;
        /**
         * Type of grantee. Valid values: `CanonicalUser`, `Group`
         */
        type?: string;
        /**
         * The uri of the grantee if you are granting permissions to a predefined group.
         */
        uri?: string;
    }

    export interface BucketAclAccessControlPolicyOwner {
        /**
         * The project ID of the grantee.
         */
        displayName: string;
        /**
         * The `region`, `bucket` and `acl` separated by (`/`).
         */
        id: string;
    }

    export interface BucketCorsRule {
        /**
         * Specifies which headers are allowed.
         */
        allowedHeaders?: string[];
        /**
         * Specifies which methods are allowed (`GET`, `PUT`, `POST`, `DELETE` or `HEAD`).
         */
        allowedMethods: string[];
        /**
         * Specifies which origins are allowed.
         */
        allowedOrigins: string[];
        /**
         * Specifies header exposure in the response.
         */
        exposeHeaders?: string[];
        /**
         * Specifies time in seconds that the browser can cache the response for a preflight request.
         */
        maxAgeSeconds?: number;
    }

    export interface BucketLifecycleRule {
        /**
         * Specifies the number of days after initiating a multipart upload when the multipart upload must be completed.
         *
         * > **Important:** Avoid using `prefix` for `AbortIncompleteMultipartUpload`, as any incomplete multipart upload will be billed
         */
        abortIncompleteMultipartUploadDays?: number;
        /**
         * The element value can be either Enabled or Disabled. If a rule is disabled, Scaleway Object Storage does not perform any of the actions defined in the rule.
         */
        enabled: boolean;
        /**
         * Specifies a period in the object's expire
         */
        expiration?: outputs.object.BucketLifecycleRuleExpiration;
        /**
         * Unique identifier for the rule. Must be less than or equal to 255 characters in length.
         */
        id: string;
        /**
         * Object key prefix identifying one or more objects to which the rule applies.
         */
        prefix?: string;
        /**
         * Specifies object tags key and value.
         */
        tags?: {[key: string]: string};
        /**
         * Define when objects transition to another storage class
         */
        transitions?: outputs.object.BucketLifecycleRuleTransition[];
    }

    export interface BucketLifecycleRuleExpiration {
        /**
         * Specifies the number of days after object creation when the specific rule action takes effect.
         */
        days: number;
    }

    export interface BucketLifecycleRuleTransition {
        /**
         * Specifies the number of days after object creation when the specific rule action takes effect.
         */
        days?: number;
        /**
         * Specifies the Scaleway [storage class](https://www.scaleway.com/en/docs/object-storage/concepts/#storage-class) `STANDARD`, `GLACIER`, `ONEZONE_IA`  to which you want the object to transition.
         *
         *
         * > **Important:**  If versioning is enabled, this rule only deletes the current version of an object.
         * > **Important:**  If versioning is enabled, this rule only deletes the current version of an object.
         *
         *
         * > **Important:**  `ONEZONE_IA` is only available in `fr-par` region. The storage class `GLACIER` is not available in `pl-waw` region.
         * > **Important:**  `ONEZONE_IA` is only available in `fr-par` region. The storage class `GLACIER` is not available in `pl-waw` region.
         */
        storageClass: string;
    }

    export interface BucketLockConfigurationRule {
        /**
         * The default retention for the lock.
         */
        defaultRetention: outputs.object.BucketLockConfigurationRuleDefaultRetention;
    }

    export interface BucketLockConfigurationRuleDefaultRetention {
        /**
         * The number of days you want to specify for the default retention period.
         */
        days?: number;
        /**
         * The default object lock retention mode you want to apply to new objects placed in the specified bucket. Valid values are `GOVERNANCE` or `COMPLIANCE`. Refer to the [dedicated documentation](https://www.scaleway.com/en/docs/object-storage/api-cli/object-lock/#retention-modes) for more information on retention modes.
         */
        mode: string;
        /**
         * The number of years you want to specify for the default retention period.
         */
        years?: number;
    }

    export interface BucketVersioning {
        /**
         * Enable versioning. Once you version-enable a bucket, it can never return to an unversioned state. You can, however, suspend versioning on that bucket.
         */
        enabled: boolean;
    }

    export interface BucketWebsiteConfigurationErrorDocument {
        /**
         * The object key name to use when a 4XX class error occurs.
         */
        key: string;
    }

    export interface BucketWebsiteConfigurationIndexDocument {
        /**
         * A suffix that is appended to a request targeting a specific directory on the website endpoint.
         *
         * > **Important:** The suffix must not be empty and must not include a slash character. The routing is not supported.
         */
        suffix: string;
    }

    export interface GetBucketCorsRule {
        /**
         * Allowed headers in the CORS rule
         */
        allowedHeaders: string[];
        /**
         * Allowed HTTP methods allowed in the CORS rule
         */
        allowedMethods: string[];
        /**
         * Allowed origins allowed in the CORS rule
         */
        allowedOrigins: string[];
        /**
         * Exposed headers in the CORS rule
         */
        exposeHeaders: string[];
        /**
         * Max age of the CORS rule
         */
        maxAgeSeconds: number;
    }

    export interface GetBucketLifecycleRule {
        /**
         * Specifies the number of days after initiating a multipart upload when the multipart upload must be completed
         */
        abortIncompleteMultipartUploadDays: number;
        /**
         * Specifies if the configuration rule is Enabled or Disabled
         */
        enabled: boolean;
        /**
         * Specifies a period in the object's expire
         */
        expirations: outputs.object.GetBucketLifecycleRuleExpiration[];
        /**
         * The unique identifier of the bucket.
         */
        id: string;
        /**
         * The prefix identifying one or more objects to which the rule applies
         */
        prefix: string;
        /**
         * The tags associated with the bucket lifecycle
         */
        tags: {[key: string]: string};
        /**
         * Define when objects transition to another storage class
         */
        transitions: outputs.object.GetBucketLifecycleRuleTransition[];
    }

    export interface GetBucketLifecycleRuleExpiration {
        /**
         * Specifies the number of days after object creation when the specific rule action takes effect
         */
        days: number;
    }

    export interface GetBucketLifecycleRuleTransition {
        /**
         * Specifies the number of days after object creation when the specific rule action takes effect
         */
        days: number;
        /**
         * Specifies the Scaleway Object Storage class to which you want the object to transition
         */
        storageClass: string;
    }

    export interface GetBucketVersioning {
        /**
         * Enable versioning. Once you version-enable a bucket, it can never return to an unversioned state
         */
        enabled: boolean;
    }

}

export namespace observability {
    export interface AlertManagerContactPoint {
        /**
         * Email addresses for the alert receivers
         */
        email?: string;
    }

    export interface CockpitEndpoint {
        /**
         * (Deprecated) URL for the [Alert manager](https://www.scaleway.com/en/docs/observability/cockpit/concepts/#alert-manager).
         */
        alertmanagerUrl: string;
        /**
         * (Deprecated) URL for Grafana.
         */
        grafanaUrl: string;
        /**
         * (Deprecated) URL for [logs](https://www.scaleway.com/en/docs/observability/cockpit/concepts/#logs) to retrieve in the [Data sources tab](https://console.scaleway.com/cockpit/dataSource) of the Scaleway console.
         */
        logsUrl: string;
        /**
         * (Deprecated) URL for [metrics](https://www.scaleway.com/en/docs/observability/cockpit/concepts/#metric) to retrieve in the [Data sources tab](https://console.scaleway.com/cockpit/dataSource) of the Scaleway console.
         */
        metricsUrl: string;
        /**
         * (Deprecated) URL for [traces](https://www.scaleway.com/en/docs/observability/cockpit/concepts/#traces) to retrieve in the [Data sources tab](https://console.scaleway.com/cockpit/dataSource) of the Scaleway console.
         */
        tracesUrl: string;
    }

    export interface CockpitPushUrl {
        /**
         * Push URL for logs (Grafana Loki)
         */
        pushLogsUrl: string;
        /**
         * Push URL for metrics (Grafana Mimir)
         */
        pushMetricsUrl: string;
    }

    export interface GetInstanceEndpoint {
        /**
         * (Deprecated) URL for the [Alert manager](https://www.scaleway.com/en/docs/observability/cockpit/concepts/#alert-manager).
         */
        alertmanagerUrl: string;
        /**
         * (Deprecated) URL for Grafana.
         */
        grafanaUrl: string;
        /**
         * (Deprecated) URL for [logs](https://www.scaleway.com/en/docs/observability/cockpit/concepts/#logs) to retrieve in the [Data sources tab](https://console.scaleway.com/cockpit/dataSource) of the Scaleway console.
         */
        logsUrl: string;
        /**
         * (Deprecated) URL for [metrics](https://www.scaleway.com/en/docs/observability/cockpit/concepts/#metric) to retrieve in the [Data sources tab](https://console.scaleway.com/cockpit/dataSource) of the Scaleway console.
         */
        metricsUrl: string;
        /**
         * The traces URL.
         */
        tracesUrl: string;
    }

    export interface GetInstancePushUrl {
        /**
         * Push URL for logs (Grafana Loki)
         */
        pushLogsUrl: string;
        /**
         * Push URL for metrics (Grafana Mimir)
         */
        pushMetricsUrl: string;
    }

    export interface GetSourcesSource {
        /**
         * The date and time of the creation of the cockpit datasource.
         */
        createdAt: string;
        /**
         * The ID of the data source.
         */
        id: string;
        /**
         * Filter sources by name.
         */
        name: string;
        /**
         * Filter sources by origin. Possible values are: `scaleway`, `external`, `custom`.
         */
        origin: string;
        /**
         * The project ID the cockpit sources are associated with.
         */
        projectId: string;
        /**
         * The URL endpoint used for pushing data to the cockpit data source.
         */
        pushUrl: string;
        /**
         * The region in which the cockpit sources are located.
         */
        region: string;
        /**
         * The number of days to retain data.
         */
        retentionDays: number;
        /**
         * Indicates whether the data source is synchronized with Grafana.
         */
        synchronizedWithGrafana: boolean;
        /**
         * Filter sources by type. Possible values are: `metrics`, `logs`, `traces`.
         */
        type: string;
        /**
         * The date and time of the last update of the cockpit datasource.
         */
        updatedAt: string;
        /**
         * The URL of the datasource.
         */
        url: string;
    }

    export interface TokenScopes {
        /**
         * Permission to query logs.
         */
        queryLogs?: boolean;
        /**
         * Permission to query metrics.
         */
        queryMetrics?: boolean;
        /**
         * Permission to query traces.
         */
        queryTraces?: boolean;
        /**
         * Permission to set up alerts.
         */
        setupAlerts?: boolean;
        /**
         * Permission to set up logs rules.
         */
        setupLogsRules?: boolean;
        /**
         * Permission to set up metrics rules.
         */
        setupMetricsRules?: boolean;
        /**
         * Permission to write logs.
         */
        writeLogs?: boolean;
        /**
         * Permission to write metrics.
         */
        writeMetrics?: boolean;
        /**
         * Permission to write traces.
         */
        writeTraces?: boolean;
    }

}

export namespace redis {
    export interface ClusterAcl {
        /**
         * A text describing this rule. Default description: `Allow IP`
         *
         * > The `acl` conflict with `privateNetwork`. Only one should be specified.
         */
        description: string;
        /**
         * The ID of the IPv4 address resource.
         */
        id: string;
        /**
         * The IP range to whitelist
         * in [CIDR notation](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#CIDR_notation)
         */
        ip: string;
    }

    export interface ClusterPrivateIp {
        /**
         * The private IPv4 address.
         */
        address: string;
        /**
         * The ID of the IPv4 address resource.
         */
        id: string;
    }

    export interface ClusterPrivateNetwork {
        /**
         * The ID of the endpoint.
         */
        endpointId: string;
        /**
         * The UUID of the Private Network resource.
         */
        id: string;
        /**
         * List of IPv4 addresses of the endpoint.
         */
        ips: string[];
        /**
         * TCP port of the endpoint.
         */
        port: number;
        /**
         * Endpoint IPv4 addresses in [CIDR notation](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#CIDR_notation). You must provide at least one IP per node.
         * Keep in mind that in cluster mode you cannot edit your Private Network after its creation so if you want to be able to
         * scale your cluster horizontally (adding nodes) later, you should provide more IPs than nodes.
         * If not set, the IP network address within the private subnet is determined by the IP Address Management (IPAM) service.
         * > **Important:** When IPAM is enabled, the IPs specified here will be ignored and should not be provided.
         *
         * > The `privateNetwork` conflicts with `acl`. Only one should be specified.
         *
         * > **Important:** The way to use Private Networks differs whether you are using Redisâ„¢ in Standalone or cluster mode.
         *
         * - Standalone mode (`clusterSize` = 1) : you can attach as many Private Networks as you want (each must be a separate
         * block). If you detach your only Private Network, your cluster won't be reachable until you define a new Private or
         * Public Network. You can modify your `privateNetwork` and its specs, you can have both a Private and Public Network side
         * by side.
         *
         * - Cluster mode (`clusterSize` > 2) : you can define a single Private Network as you create your cluster, you won't be
         * able to edit or detach it afterward, unless you create another cluster. This also means that, if you are using a static
         * configuration (`serviceIps`), you won't be able to scale your cluster horizontally (add more nodes) since it would
         * require updating the Private Network to add IPs.
         * Your `serviceIps` must be listed as follows:
         */
        serviceIps: string[];
        /**
         * `zone`) The zone in which the
         * Redisâ„¢ cluster should be created.
         */
        zone: string;
    }

    export interface ClusterPublicNetwork {
        /**
         * The ID of the IPv4 address resource.
         */
        id: string;
        /**
         * List of IPv4 addresses of the endpoint.
         */
        ips: string[];
        /**
         * TCP port of the endpoint.
         */
        port: number;
    }

    export interface GetClusterAcl {
        /**
         * Description of the rule.
         */
        description: string;
        /**
         * The ID of the Redis cluster.
         */
        id: string;
        /**
         * IPv4 network address of the rule (IP network in a CIDR format).
         */
        ip: string;
    }

    export interface GetClusterPrivateIp {
        /**
         * The private IPv4 address
         */
        address: string;
        /**
         * The ID of the Redis cluster.
         */
        id: string;
    }

    export interface GetClusterPrivateNetwork {
        /**
         * The ID of the endpoint.
         */
        endpointId: string;
        /**
         * The ID of the Redis cluster.
         */
        id: string;
        /**
         * List of IPv4 addresses of the endpoint.
         */
        ips: string[];
        /**
         * TCP port of the endpoint.
         */
        port: number;
        /**
         * List of IPv4 addresses of the private network with a CIDR notation
         */
        serviceIps: string[];
        /**
         * `region`) The zone in which the server exists.
         */
        zone: string;
    }

    export interface GetClusterPublicNetwork {
        /**
         * The ID of the Redis cluster.
         */
        id: string;
        /**
         * List of IPv4 addresses of the endpoint.
         */
        ips: string[];
        /**
         * TCP port of the endpoint.
         */
        port: number;
    }

}

export namespace secrets {
    export interface GetSecretEphemeralPolicy {
        /**
         * Action to perform when the version of a secret expires.
         */
        action: string;
        /**
         * True if the secret version expires after a single user access.
         */
        expiresOnceAccessed: boolean;
        /**
         * Time frame, from one second and up to one year, during which the secret's versions are valid. Has to be specified in Go Duration format
         */
        ttl: string;
    }

    export interface GetSecretVersion {
        /**
         * Date and time of secret version's creation (RFC 3339 format)
         */
        createdAt: string;
        /**
         * Description of the secret version
         */
        description: string;
        /**
         * Returns true if the version is the latest.
         */
        latest: boolean;
        /**
         * The revision of secret version
         */
        revision: string;
        /**
         * The ID of the secret.
         * Only one of `name` and `secretId` should be specified.
         */
        secretId: string;
        /**
         * Status of the secret version
         */
        status: string;
        /**
         * Date and time of secret version's creation (RFC 3339 format)
         */
        updatedAt: string;
    }

    export interface SecretEphemeralPolicy {
        /**
         * Action to perform when the version of a secret expires. Available values can be found in [SDK constants](https://pkg.go.dev/github.com/scaleway/scaleway-sdk-go@master/api/secret/v1beta1#pkg-constants).
         */
        action: string;
        /**
         * True if the secret version expires after a single user access.
         */
        expiresOnceAccessed?: boolean;
        /**
         * Time frame, from one second and up to one year, during which the secret's versions are valid. Has to be specified in [Go Duration format](https://pkg.go.dev/time#ParseDuration) (ex: "30m", "24h").
         */
        ttl?: string;
    }

    export interface SecretVersion {
        /**
         * Date and time of the secret's creation (in RFC 3339 format).
         */
        createdAt: string;
        /**
         * Description of the secret (e.g. `my-new-description`).
         */
        description?: string;
        /**
         * Returns true if the version is the latest.
         */
        latest?: boolean;
        /**
         * The revision of secret version
         */
        revision: string;
        /**
         * The secret ID associated with this version
         */
        secretId: string;
        /**
         * The status of the secret.
         */
        status: string;
        /**
         * Date and time of the secret's last update (in RFC 3339 format).
         */
        updatedAt: string;
    }

}

export namespace tem {
    export interface DomainReputation {
        /**
         * The previously-calculated domain's reputation score.
         */
        previousScore: number;
        /**
         * The time and date the previous reputation score was calculated.
         */
        previousScoredAt: string;
        /**
         * A range from 0 to 100 that determines your domain's reputation score.
         */
        score: number;
        /**
         * The time and date the score was calculated.
         */
        scoredAt: string;
        /**
         * The status of the domain's reputation.
         */
        status: string;
    }

    export interface GetDomainReputation {
        /**
         * The previously-calculated domain's reputation score
         */
        previousScore: number;
        /**
         * Time and date the previous reputation score was calculated
         */
        previousScoredAt: string;
        /**
         * A range from 0 to 100 that determines your domain's reputation score
         */
        score: number;
        /**
         * Time and date the score was calculated
         */
        scoredAt: string;
        /**
         * Status of the domain's reputation
         */
        status: string;
    }

}
