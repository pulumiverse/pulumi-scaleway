# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities

__all__ = [
    'AppleSiliconServerPrivateIpArgs',
    'AppleSiliconServerPrivateIpArgsDict',
    'AppleSiliconServerPrivateNetworkArgs',
    'AppleSiliconServerPrivateNetworkArgsDict',
    'BaremetalServerIpArgs',
    'BaremetalServerIpArgsDict',
    'BaremetalServerIpv4Args',
    'BaremetalServerIpv4ArgsDict',
    'BaremetalServerIpv6Args',
    'BaremetalServerIpv6ArgsDict',
    'BaremetalServerOptionArgs',
    'BaremetalServerOptionArgsDict',
    'BaremetalServerPrivateIpArgs',
    'BaremetalServerPrivateIpArgsDict',
    'BaremetalServerPrivateNetworkArgs',
    'BaremetalServerPrivateNetworkArgsDict',
    'BlockSnapshotExportArgs',
    'BlockSnapshotExportArgsDict',
    'BlockSnapshotImportArgs',
    'BlockSnapshotImportArgsDict',
    'CockpitAlertManagerContactPointArgs',
    'CockpitAlertManagerContactPointArgsDict',
    'CockpitEndpointArgs',
    'CockpitEndpointArgsDict',
    'CockpitPushUrlArgs',
    'CockpitPushUrlArgsDict',
    'CockpitTokenScopesArgs',
    'CockpitTokenScopesArgsDict',
    'ContainerHealthCheckArgs',
    'ContainerHealthCheckArgsDict',
    'ContainerHealthCheckHttpArgs',
    'ContainerHealthCheckHttpArgsDict',
    'ContainerScalingOptionArgs',
    'ContainerScalingOptionArgsDict',
    'ContainerTriggerNatsArgs',
    'ContainerTriggerNatsArgsDict',
    'ContainerTriggerSqsArgs',
    'ContainerTriggerSqsArgsDict',
    'DatabaseAclAclRuleArgs',
    'DatabaseAclAclRuleArgsDict',
    'DatabaseInstanceLoadBalancerArgs',
    'DatabaseInstanceLoadBalancerArgsDict',
    'DatabaseInstanceLogsPolicyArgs',
    'DatabaseInstanceLogsPolicyArgsDict',
    'DatabaseInstancePrivateIpArgs',
    'DatabaseInstancePrivateIpArgsDict',
    'DatabaseInstancePrivateNetworkArgs',
    'DatabaseInstancePrivateNetworkArgsDict',
    'DatabaseInstanceReadReplicaArgs',
    'DatabaseInstanceReadReplicaArgsDict',
    'DatabaseInstanceUpgradableVersionArgs',
    'DatabaseInstanceUpgradableVersionArgsDict',
    'DatabaseReadReplicaDirectAccessArgs',
    'DatabaseReadReplicaDirectAccessArgsDict',
    'DatabaseReadReplicaPrivateNetworkArgs',
    'DatabaseReadReplicaPrivateNetworkArgsDict',
    'DomainRecordGeoIpArgs',
    'DomainRecordGeoIpArgsDict',
    'DomainRecordGeoIpMatchArgs',
    'DomainRecordGeoIpMatchArgsDict',
    'DomainRecordHttpServiceArgs',
    'DomainRecordHttpServiceArgsDict',
    'DomainRecordViewArgs',
    'DomainRecordViewArgsDict',
    'DomainRecordWeightedArgs',
    'DomainRecordWeightedArgsDict',
    'EdgeServicesBackendStageLbBackendConfigArgs',
    'EdgeServicesBackendStageLbBackendConfigArgsDict',
    'EdgeServicesBackendStageLbBackendConfigLbConfigArgs',
    'EdgeServicesBackendStageLbBackendConfigLbConfigArgsDict',
    'EdgeServicesBackendStageS3BackendConfigArgs',
    'EdgeServicesBackendStageS3BackendConfigArgsDict',
    'EdgeServicesCacheStagePurgeRequestArgs',
    'EdgeServicesCacheStagePurgeRequestArgsDict',
    'EdgeServicesRouteStageRuleArgs',
    'EdgeServicesRouteStageRuleArgsDict',
    'EdgeServicesRouteStageRuleRuleHttpMatchArgs',
    'EdgeServicesRouteStageRuleRuleHttpMatchArgsDict',
    'EdgeServicesRouteStageRuleRuleHttpMatchPathFilterArgs',
    'EdgeServicesRouteStageRuleRuleHttpMatchPathFilterArgsDict',
    'EdgeServicesTlsStageSecretArgs',
    'EdgeServicesTlsStageSecretArgsDict',
    'FunctionTriggerNatsArgs',
    'FunctionTriggerNatsArgsDict',
    'FunctionTriggerSqsArgs',
    'FunctionTriggerSqsArgsDict',
    'IamPolicyRuleArgs',
    'IamPolicyRuleArgsDict',
    'InferenceDeploymentPrivateEndpointArgs',
    'InferenceDeploymentPrivateEndpointArgsDict',
    'InferenceDeploymentPrivateIpArgs',
    'InferenceDeploymentPrivateIpArgsDict',
    'InferenceDeploymentPublicEndpointArgs',
    'InferenceDeploymentPublicEndpointArgsDict',
    'InstanceImageAdditionalVolumeArgs',
    'InstanceImageAdditionalVolumeArgsDict',
    'InstanceImageRootVolumeArgs',
    'InstanceImageRootVolumeArgsDict',
    'InstancePrivateNicPrivateIpArgs',
    'InstancePrivateNicPrivateIpArgsDict',
    'InstanceSecurityGroupInboundRuleArgs',
    'InstanceSecurityGroupInboundRuleArgsDict',
    'InstanceSecurityGroupOutboundRuleArgs',
    'InstanceSecurityGroupOutboundRuleArgsDict',
    'InstanceSecurityGroupRulesInboundRuleArgs',
    'InstanceSecurityGroupRulesInboundRuleArgsDict',
    'InstanceSecurityGroupRulesOutboundRuleArgs',
    'InstanceSecurityGroupRulesOutboundRuleArgsDict',
    'InstanceServerFilesystemArgs',
    'InstanceServerFilesystemArgsDict',
    'InstanceServerPrivateIpArgs',
    'InstanceServerPrivateIpArgsDict',
    'InstanceServerPrivateNetworkArgs',
    'InstanceServerPrivateNetworkArgsDict',
    'InstanceServerPublicIpArgs',
    'InstanceServerPublicIpArgsDict',
    'InstanceServerRootVolumeArgs',
    'InstanceServerRootVolumeArgsDict',
    'InstanceSnapshotImportArgs',
    'InstanceSnapshotImportArgsDict',
    'IotDeviceCertificateArgs',
    'IotDeviceCertificateArgsDict',
    'IotDeviceMessageFiltersArgs',
    'IotDeviceMessageFiltersArgsDict',
    'IotDeviceMessageFiltersPublishArgs',
    'IotDeviceMessageFiltersPublishArgsDict',
    'IotDeviceMessageFiltersSubscribeArgs',
    'IotDeviceMessageFiltersSubscribeArgsDict',
    'IotRouteDatabaseArgs',
    'IotRouteDatabaseArgsDict',
    'IotRouteRestArgs',
    'IotRouteRestArgsDict',
    'IotRouteS3Args',
    'IotRouteS3ArgsDict',
    'IpamIpCustomResourceArgs',
    'IpamIpCustomResourceArgsDict',
    'IpamIpResourceArgs',
    'IpamIpResourceArgsDict',
    'IpamIpReverseArgs',
    'IpamIpReverseArgsDict',
    'IpamIpSourceArgs',
    'IpamIpSourceArgsDict',
    'JobDefinitionCronArgs',
    'JobDefinitionCronArgsDict',
    'JobDefinitionSecretReferenceArgs',
    'JobDefinitionSecretReferenceArgsDict',
    'KeyManagerKeyRotationPolicyArgs',
    'KeyManagerKeyRotationPolicyArgsDict',
    'KubernetesClusterAutoUpgradeArgs',
    'KubernetesClusterAutoUpgradeArgsDict',
    'KubernetesClusterAutoscalerConfigArgs',
    'KubernetesClusterAutoscalerConfigArgsDict',
    'KubernetesClusterKubeconfigArgs',
    'KubernetesClusterKubeconfigArgsDict',
    'KubernetesClusterOpenIdConnectConfigArgs',
    'KubernetesClusterOpenIdConnectConfigArgsDict',
    'KubernetesNodePoolNodeArgs',
    'KubernetesNodePoolNodeArgsDict',
    'KubernetesNodePoolNodePrivateIpArgs',
    'KubernetesNodePoolNodePrivateIpArgsDict',
    'KubernetesNodePoolUpgradePolicyArgs',
    'KubernetesNodePoolUpgradePolicyArgsDict',
    'LoadbalancerAclActionArgs',
    'LoadbalancerAclActionArgsDict',
    'LoadbalancerAclActionRedirectArgs',
    'LoadbalancerAclActionRedirectArgsDict',
    'LoadbalancerAclMatchArgs',
    'LoadbalancerAclMatchArgsDict',
    'LoadbalancerBackendHealthCheckHttpArgs',
    'LoadbalancerBackendHealthCheckHttpArgsDict',
    'LoadbalancerBackendHealthCheckHttpsArgs',
    'LoadbalancerBackendHealthCheckHttpsArgsDict',
    'LoadbalancerBackendHealthCheckTcpArgs',
    'LoadbalancerBackendHealthCheckTcpArgsDict',
    'LoadbalancerCertificateCustomCertificateArgs',
    'LoadbalancerCertificateCustomCertificateArgsDict',
    'LoadbalancerCertificateLetsencryptArgs',
    'LoadbalancerCertificateLetsencryptArgsDict',
    'LoadbalancerFrontendAclArgs',
    'LoadbalancerFrontendAclArgsDict',
    'LoadbalancerFrontendAclActionArgs',
    'LoadbalancerFrontendAclActionArgsDict',
    'LoadbalancerFrontendAclActionRedirectArgs',
    'LoadbalancerFrontendAclActionRedirectArgsDict',
    'LoadbalancerFrontendAclMatchArgs',
    'LoadbalancerFrontendAclMatchArgsDict',
    'LoadbalancerPrivateIpArgs',
    'LoadbalancerPrivateIpArgsDict',
    'LoadbalancerPrivateNetworkArgs',
    'LoadbalancerPrivateNetworkArgsDict',
    'MnqSnsCredentialsPermissionsArgs',
    'MnqSnsCredentialsPermissionsArgsDict',
    'MnqSqsCredentialsPermissionsArgs',
    'MnqSqsCredentialsPermissionsArgsDict',
    'MnqSqsQueueDeadLetterQueueArgs',
    'MnqSqsQueueDeadLetterQueueArgsDict',
    'MongoDbInstancePrivateIpArgs',
    'MongoDbInstancePrivateIpArgsDict',
    'MongoDbInstancePrivateNetworkArgs',
    'MongoDbInstancePrivateNetworkArgsDict',
    'MongoDbInstancePublicNetworkArgs',
    'MongoDbInstancePublicNetworkArgsDict',
    'ObjectBucketAclAccessControlPolicyArgs',
    'ObjectBucketAclAccessControlPolicyArgsDict',
    'ObjectBucketAclAccessControlPolicyGrantArgs',
    'ObjectBucketAclAccessControlPolicyGrantArgsDict',
    'ObjectBucketAclAccessControlPolicyGrantGranteeArgs',
    'ObjectBucketAclAccessControlPolicyGrantGranteeArgsDict',
    'ObjectBucketAclAccessControlPolicyOwnerArgs',
    'ObjectBucketAclAccessControlPolicyOwnerArgsDict',
    'ObjectBucketCorsRuleArgs',
    'ObjectBucketCorsRuleArgsDict',
    'ObjectBucketLifecycleRuleArgs',
    'ObjectBucketLifecycleRuleArgsDict',
    'ObjectBucketLifecycleRuleExpirationArgs',
    'ObjectBucketLifecycleRuleExpirationArgsDict',
    'ObjectBucketLifecycleRuleTransitionArgs',
    'ObjectBucketLifecycleRuleTransitionArgsDict',
    'ObjectBucketLockConfigurationRuleArgs',
    'ObjectBucketLockConfigurationRuleArgsDict',
    'ObjectBucketLockConfigurationRuleDefaultRetentionArgs',
    'ObjectBucketLockConfigurationRuleDefaultRetentionArgsDict',
    'ObjectBucketVersioningArgs',
    'ObjectBucketVersioningArgsDict',
    'ObjectBucketWebsiteConfigurationErrorDocumentArgs',
    'ObjectBucketWebsiteConfigurationErrorDocumentArgsDict',
    'ObjectBucketWebsiteConfigurationIndexDocumentArgs',
    'ObjectBucketWebsiteConfigurationIndexDocumentArgsDict',
    'RedisClusterAclArgs',
    'RedisClusterAclArgsDict',
    'RedisClusterPrivateIpArgs',
    'RedisClusterPrivateIpArgsDict',
    'RedisClusterPrivateNetworkArgs',
    'RedisClusterPrivateNetworkArgsDict',
    'RedisClusterPublicNetworkArgs',
    'RedisClusterPublicNetworkArgsDict',
    'SecretEphemeralPolicyArgs',
    'SecretEphemeralPolicyArgsDict',
    'SecretVersionArgs',
    'SecretVersionArgsDict',
    'TemDomainReputationArgs',
    'TemDomainReputationArgsDict',
    'VpcGatewayNetworkIpamConfigArgs',
    'VpcGatewayNetworkIpamConfigArgsDict',
    'VpcGatewayNetworkPrivateIpArgs',
    'VpcGatewayNetworkPrivateIpArgsDict',
    'VpcPrivateNetworkIpv4SubnetArgs',
    'VpcPrivateNetworkIpv4SubnetArgsDict',
    'VpcPrivateNetworkIpv6SubnetArgs',
    'VpcPrivateNetworkIpv6SubnetArgsDict',
    'WebhostingCpanelUrlArgs',
    'WebhostingCpanelUrlArgsDict',
    'WebhostingNameServerArgs',
    'WebhostingNameServerArgsDict',
    'WebhostingOptionArgs',
    'WebhostingOptionArgsDict',
    'WebhostingRecordArgs',
    'WebhostingRecordArgsDict',
    'GetIpamIpResourceArgs',
    'GetIpamIpResourceArgsDict',
    'GetIpamIpsResourceArgs',
    'GetIpamIpsResourceArgsDict',
]

MYPY = False

if not MYPY:
    class AppleSiliconServerPrivateIpArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[_builtins.str]]
        """
        The private IP address.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the IP address resource.
        """
elif False:
    AppleSiliconServerPrivateIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppleSiliconServerPrivateIpArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] address: The private IP address.
        :param pulumi.Input[_builtins.str] id: The ID of the IP address resource.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The private IP address.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the IP address resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class AppleSiliconServerPrivateNetworkArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The private network ID
        """
        created_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        The date and time the private network was created.
        """
        ipam_ip_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of IPAM IP IDs to attach to the server.
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        The current status of the private network.
        """
        updated_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        The date and time the private network was last updated.
        """
        vlan: NotRequired[pulumi.Input[_builtins.int]]
        """
        The VLAN ID associated with the private network.
        """
elif False:
    AppleSiliconServerPrivateNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppleSiliconServerPrivateNetworkArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 created_at: Optional[pulumi.Input[_builtins.str]] = None,
                 ipam_ip_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_at: Optional[pulumi.Input[_builtins.str]] = None,
                 vlan: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] id: The private network ID
        :param pulumi.Input[_builtins.str] created_at: The date and time the private network was created.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ipam_ip_ids: A list of IPAM IP IDs to attach to the server.
        :param pulumi.Input[_builtins.str] status: The current status of the private network.
        :param pulumi.Input[_builtins.str] updated_at: The date and time the private network was last updated.
        :param pulumi.Input[_builtins.int] vlan: The VLAN ID associated with the private network.
        """
        pulumi.set(__self__, "id", id)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if ipam_ip_ids is not None:
            pulumi.set(__self__, "ipam_ip_ids", ipam_ip_ids)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if vlan is not None:
            pulumi.set(__self__, "vlan", vlan)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The private network ID
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The date and time the private network was created.
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter(name="ipamIpIds")
    def ipam_ip_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of IPAM IP IDs to attach to the server.
        """
        return pulumi.get(self, "ipam_ip_ids")

    @ipam_ip_ids.setter
    def ipam_ip_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ipam_ip_ids", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The current status of the private network.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The date and time the private network was last updated.
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_at", value)

    @_builtins.property
    @pulumi.getter
    def vlan(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The VLAN ID associated with the private network.
        """
        return pulumi.get(self, "vlan")

    @vlan.setter
    def vlan(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "vlan", value)


if not MYPY:
    class BaremetalServerIpArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[_builtins.str]]
        """
        The address of the IPv6.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the IPv6.
        """
        reverse: NotRequired[pulumi.Input[_builtins.str]]
        """
        The reverse of the IPv6.
        """
        version: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of the IPv6.
        """
elif False:
    BaremetalServerIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BaremetalServerIpArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 reverse: Optional[pulumi.Input[_builtins.str]] = None,
                 version: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] address: The address of the IPv6.
        :param pulumi.Input[_builtins.str] id: The ID of the IPv6.
        :param pulumi.Input[_builtins.str] reverse: The reverse of the IPv6.
        :param pulumi.Input[_builtins.str] version: The type of the IPv6.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if reverse is not None:
            pulumi.set(__self__, "reverse", reverse)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The address of the IPv6.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the IPv6.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def reverse(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The reverse of the IPv6.
        """
        return pulumi.get(self, "reverse")

    @reverse.setter
    def reverse(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "reverse", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of the IPv6.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class BaremetalServerIpv4ArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[_builtins.str]]
        """
        The address of the IPv6.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the IPv6.
        """
        reverse: NotRequired[pulumi.Input[_builtins.str]]
        """
        The reverse of the IPv6.
        """
        version: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of the IPv6.
        """
elif False:
    BaremetalServerIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BaremetalServerIpv4Args:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 reverse: Optional[pulumi.Input[_builtins.str]] = None,
                 version: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] address: The address of the IPv6.
        :param pulumi.Input[_builtins.str] id: The ID of the IPv6.
        :param pulumi.Input[_builtins.str] reverse: The reverse of the IPv6.
        :param pulumi.Input[_builtins.str] version: The type of the IPv6.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if reverse is not None:
            pulumi.set(__self__, "reverse", reverse)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The address of the IPv6.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the IPv6.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def reverse(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The reverse of the IPv6.
        """
        return pulumi.get(self, "reverse")

    @reverse.setter
    def reverse(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "reverse", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of the IPv6.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class BaremetalServerIpv6ArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[_builtins.str]]
        """
        The address of the IPv6.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the IPv6.
        """
        reverse: NotRequired[pulumi.Input[_builtins.str]]
        """
        The reverse of the IPv6.
        """
        version: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of the IPv6.
        """
elif False:
    BaremetalServerIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BaremetalServerIpv6Args:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 reverse: Optional[pulumi.Input[_builtins.str]] = None,
                 version: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] address: The address of the IPv6.
        :param pulumi.Input[_builtins.str] id: The ID of the IPv6.
        :param pulumi.Input[_builtins.str] reverse: The reverse of the IPv6.
        :param pulumi.Input[_builtins.str] version: The type of the IPv6.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if reverse is not None:
            pulumi.set(__self__, "reverse", reverse)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The address of the IPv6.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the IPv6.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def reverse(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The reverse of the IPv6.
        """
        return pulumi.get(self, "reverse")

    @reverse.setter
    def reverse(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "reverse", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of the IPv6.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class BaremetalServerOptionArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The id of the option to enable. Use [this endpoint](https://www.scaleway.com/en/developers/api/elastic-metal/#path-options-list-options) to find the available options IDs.
        """
        expires_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        The auto expiration date for compatible options
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the server.
        """
elif False:
    BaremetalServerOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BaremetalServerOptionArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 expires_at: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: The id of the option to enable. Use [this endpoint](https://www.scaleway.com/en/developers/api/elastic-metal/#path-options-list-options) to find the available options IDs.
        :param pulumi.Input[_builtins.str] expires_at: The auto expiration date for compatible options
        :param pulumi.Input[_builtins.str] name: The name of the server.
        """
        pulumi.set(__self__, "id", id)
        if expires_at is not None:
            pulumi.set(__self__, "expires_at", expires_at)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The id of the option to enable. Use [this endpoint](https://www.scaleway.com/en/developers/api/elastic-metal/#path-options-list-options) to find the available options IDs.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The auto expiration date for compatible options
        """
        return pulumi.get(self, "expires_at")

    @expires_at.setter
    def expires_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expires_at", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the server.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class BaremetalServerPrivateIpArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[_builtins.str]]
        """
        The address of the IPv6.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the IPv6.
        """
elif False:
    BaremetalServerPrivateIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BaremetalServerPrivateIpArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] address: The address of the IPv6.
        :param pulumi.Input[_builtins.str] id: The ID of the IPv6.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The address of the IPv6.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the IPv6.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class BaremetalServerPrivateNetworkArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The id of the private network to attach.
        """
        created_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        The date and time of the creation of the private network.
        """
        ipam_ip_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of IPAM IP IDs to assign to the server in the requested private network.
        """
        mapping_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the Server-to-Private Network mapping.
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        The private network status.
        """
        updated_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        The date and time of the last update of the private network.
        """
        vlan: NotRequired[pulumi.Input[_builtins.int]]
        """
        The VLAN ID associated to the private network.
        """
elif False:
    BaremetalServerPrivateNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BaremetalServerPrivateNetworkArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 created_at: Optional[pulumi.Input[_builtins.str]] = None,
                 ipam_ip_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 mapping_id: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_at: Optional[pulumi.Input[_builtins.str]] = None,
                 vlan: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] id: The id of the private network to attach.
        :param pulumi.Input[_builtins.str] created_at: The date and time of the creation of the private network.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ipam_ip_ids: List of IPAM IP IDs to assign to the server in the requested private network.
        :param pulumi.Input[_builtins.str] mapping_id: The ID of the Server-to-Private Network mapping.
        :param pulumi.Input[_builtins.str] status: The private network status.
        :param pulumi.Input[_builtins.str] updated_at: The date and time of the last update of the private network.
        :param pulumi.Input[_builtins.int] vlan: The VLAN ID associated to the private network.
        """
        pulumi.set(__self__, "id", id)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if ipam_ip_ids is not None:
            pulumi.set(__self__, "ipam_ip_ids", ipam_ip_ids)
        if mapping_id is not None:
            pulumi.set(__self__, "mapping_id", mapping_id)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if vlan is not None:
            pulumi.set(__self__, "vlan", vlan)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The id of the private network to attach.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The date and time of the creation of the private network.
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter(name="ipamIpIds")
    def ipam_ip_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of IPAM IP IDs to assign to the server in the requested private network.
        """
        return pulumi.get(self, "ipam_ip_ids")

    @ipam_ip_ids.setter
    def ipam_ip_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ipam_ip_ids", value)

    @_builtins.property
    @pulumi.getter(name="mappingId")
    def mapping_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the Server-to-Private Network mapping.
        """
        return pulumi.get(self, "mapping_id")

    @mapping_id.setter
    def mapping_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mapping_id", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The private network status.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The date and time of the last update of the private network.
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_at", value)

    @_builtins.property
    @pulumi.getter
    def vlan(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The VLAN ID associated to the private network.
        """
        return pulumi.get(self, "vlan")

    @vlan.setter
    def vlan(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "vlan", value)


if not MYPY:
    class BlockSnapshotExportArgsDict(TypedDict):
        bucket: pulumi.Input[_builtins.str]
        """
        The name of the bucket where the QCOW file will be saved.
        """
        key: pulumi.Input[_builtins.str]
        """
        The desired key (path) for the QCOW file within the bucket.
        """
elif False:
    BlockSnapshotExportArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BlockSnapshotExportArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[_builtins.str],
                 key: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] bucket: The name of the bucket where the QCOW file will be saved.
        :param pulumi.Input[_builtins.str] key: The desired key (path) for the QCOW file within the bucket.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "key", key)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the bucket where the QCOW file will be saved.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The desired key (path) for the QCOW file within the bucket.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)


if not MYPY:
    class BlockSnapshotImportArgsDict(TypedDict):
        bucket: pulumi.Input[_builtins.str]
        """
        The name of the bucket containing the QCOW file.
        """
        key: pulumi.Input[_builtins.str]
        """
        The key of the QCOW file within the bucket.
        """
elif False:
    BlockSnapshotImportArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BlockSnapshotImportArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[_builtins.str],
                 key: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] bucket: The name of the bucket containing the QCOW file.
        :param pulumi.Input[_builtins.str] key: The key of the QCOW file within the bucket.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "key", key)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the bucket containing the QCOW file.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The key of the QCOW file within the bucket.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)


if not MYPY:
    class CockpitAlertManagerContactPointArgsDict(TypedDict):
        email: NotRequired[pulumi.Input[_builtins.str]]
        """
        Email addresses for the alert receivers
        """
elif False:
    CockpitAlertManagerContactPointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CockpitAlertManagerContactPointArgs:
    def __init__(__self__, *,
                 email: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] email: Email addresses for the alert receivers
        """
        if email is not None:
            pulumi.set(__self__, "email", email)

    @_builtins.property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Email addresses for the alert receivers
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "email", value)


if not MYPY:
    class CockpitEndpointArgsDict(TypedDict):
        alertmanager_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Deprecated) URL for the [Alert manager](https://www.scaleway.com/en/docs/observability/cockpit/concepts/#alert-manager).
        """
        grafana_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Deprecated) URL for Grafana.
        """
        logs_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Deprecated) URL for [logs](https://www.scaleway.com/en/docs/observability/cockpit/concepts/#logs) to retrieve in the [Data sources tab](https://console.scaleway.com/cockpit/dataSource) of the Scaleway console.
        """
        metrics_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Deprecated) URL for [metrics](https://www.scaleway.com/en/docs/observability/cockpit/concepts/#metric) to retrieve in the [Data sources tab](https://console.scaleway.com/cockpit/dataSource) of the Scaleway console.
        """
        traces_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Deprecated) URL for [traces](https://www.scaleway.com/en/docs/observability/cockpit/concepts/#traces) to retrieve in the [Data sources tab](https://console.scaleway.com/cockpit/dataSource) of the Scaleway console.
        """
elif False:
    CockpitEndpointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CockpitEndpointArgs:
    def __init__(__self__, *,
                 alertmanager_url: Optional[pulumi.Input[_builtins.str]] = None,
                 grafana_url: Optional[pulumi.Input[_builtins.str]] = None,
                 logs_url: Optional[pulumi.Input[_builtins.str]] = None,
                 metrics_url: Optional[pulumi.Input[_builtins.str]] = None,
                 traces_url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] alertmanager_url: (Deprecated) URL for the [Alert manager](https://www.scaleway.com/en/docs/observability/cockpit/concepts/#alert-manager).
        :param pulumi.Input[_builtins.str] grafana_url: (Deprecated) URL for Grafana.
        :param pulumi.Input[_builtins.str] logs_url: (Deprecated) URL for [logs](https://www.scaleway.com/en/docs/observability/cockpit/concepts/#logs) to retrieve in the [Data sources tab](https://console.scaleway.com/cockpit/dataSource) of the Scaleway console.
        :param pulumi.Input[_builtins.str] metrics_url: (Deprecated) URL for [metrics](https://www.scaleway.com/en/docs/observability/cockpit/concepts/#metric) to retrieve in the [Data sources tab](https://console.scaleway.com/cockpit/dataSource) of the Scaleway console.
        :param pulumi.Input[_builtins.str] traces_url: (Deprecated) URL for [traces](https://www.scaleway.com/en/docs/observability/cockpit/concepts/#traces) to retrieve in the [Data sources tab](https://console.scaleway.com/cockpit/dataSource) of the Scaleway console.
        """
        if alertmanager_url is not None:
            pulumi.set(__self__, "alertmanager_url", alertmanager_url)
        if grafana_url is not None:
            pulumi.set(__self__, "grafana_url", grafana_url)
        if logs_url is not None:
            pulumi.set(__self__, "logs_url", logs_url)
        if metrics_url is not None:
            pulumi.set(__self__, "metrics_url", metrics_url)
        if traces_url is not None:
            pulumi.set(__self__, "traces_url", traces_url)

    @_builtins.property
    @pulumi.getter(name="alertmanagerUrl")
    def alertmanager_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Deprecated) URL for the [Alert manager](https://www.scaleway.com/en/docs/observability/cockpit/concepts/#alert-manager).
        """
        return pulumi.get(self, "alertmanager_url")

    @alertmanager_url.setter
    def alertmanager_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "alertmanager_url", value)

    @_builtins.property
    @pulumi.getter(name="grafanaUrl")
    def grafana_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Deprecated) URL for Grafana.
        """
        return pulumi.get(self, "grafana_url")

    @grafana_url.setter
    def grafana_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "grafana_url", value)

    @_builtins.property
    @pulumi.getter(name="logsUrl")
    def logs_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Deprecated) URL for [logs](https://www.scaleway.com/en/docs/observability/cockpit/concepts/#logs) to retrieve in the [Data sources tab](https://console.scaleway.com/cockpit/dataSource) of the Scaleway console.
        """
        return pulumi.get(self, "logs_url")

    @logs_url.setter
    def logs_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "logs_url", value)

    @_builtins.property
    @pulumi.getter(name="metricsUrl")
    def metrics_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Deprecated) URL for [metrics](https://www.scaleway.com/en/docs/observability/cockpit/concepts/#metric) to retrieve in the [Data sources tab](https://console.scaleway.com/cockpit/dataSource) of the Scaleway console.
        """
        return pulumi.get(self, "metrics_url")

    @metrics_url.setter
    def metrics_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metrics_url", value)

    @_builtins.property
    @pulumi.getter(name="tracesUrl")
    def traces_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Deprecated) URL for [traces](https://www.scaleway.com/en/docs/observability/cockpit/concepts/#traces) to retrieve in the [Data sources tab](https://console.scaleway.com/cockpit/dataSource) of the Scaleway console.
        """
        return pulumi.get(self, "traces_url")

    @traces_url.setter
    def traces_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "traces_url", value)


if not MYPY:
    class CockpitPushUrlArgsDict(TypedDict):
        push_logs_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        Push URL for logs (Grafana Loki)
        """
        push_metrics_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        Push URL for metrics (Grafana Mimir)
        """
elif False:
    CockpitPushUrlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CockpitPushUrlArgs:
    def __init__(__self__, *,
                 push_logs_url: Optional[pulumi.Input[_builtins.str]] = None,
                 push_metrics_url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] push_logs_url: Push URL for logs (Grafana Loki)
        :param pulumi.Input[_builtins.str] push_metrics_url: Push URL for metrics (Grafana Mimir)
        """
        if push_logs_url is not None:
            pulumi.set(__self__, "push_logs_url", push_logs_url)
        if push_metrics_url is not None:
            pulumi.set(__self__, "push_metrics_url", push_metrics_url)

    @_builtins.property
    @pulumi.getter(name="pushLogsUrl")
    def push_logs_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Push URL for logs (Grafana Loki)
        """
        return pulumi.get(self, "push_logs_url")

    @push_logs_url.setter
    def push_logs_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "push_logs_url", value)

    @_builtins.property
    @pulumi.getter(name="pushMetricsUrl")
    def push_metrics_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Push URL for metrics (Grafana Mimir)
        """
        return pulumi.get(self, "push_metrics_url")

    @push_metrics_url.setter
    def push_metrics_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "push_metrics_url", value)


if not MYPY:
    class CockpitTokenScopesArgsDict(TypedDict):
        query_logs: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Permission to query logs.
        """
        query_metrics: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Permission to query metrics.
        """
        query_traces: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Permission to query traces.
        """
        setup_alerts: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Permission to set up alerts.
        """
        setup_logs_rules: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Permission to set up logs rules.
        """
        setup_metrics_rules: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Permission to set up metrics rules.
        """
        write_logs: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Permission to write logs.
        """
        write_metrics: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Permission to write metrics.
        """
        write_traces: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Permission to write traces.
        """
elif False:
    CockpitTokenScopesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CockpitTokenScopesArgs:
    def __init__(__self__, *,
                 query_logs: Optional[pulumi.Input[_builtins.bool]] = None,
                 query_metrics: Optional[pulumi.Input[_builtins.bool]] = None,
                 query_traces: Optional[pulumi.Input[_builtins.bool]] = None,
                 setup_alerts: Optional[pulumi.Input[_builtins.bool]] = None,
                 setup_logs_rules: Optional[pulumi.Input[_builtins.bool]] = None,
                 setup_metrics_rules: Optional[pulumi.Input[_builtins.bool]] = None,
                 write_logs: Optional[pulumi.Input[_builtins.bool]] = None,
                 write_metrics: Optional[pulumi.Input[_builtins.bool]] = None,
                 write_traces: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] query_logs: Permission to query logs.
        :param pulumi.Input[_builtins.bool] query_metrics: Permission to query metrics.
        :param pulumi.Input[_builtins.bool] query_traces: Permission to query traces.
        :param pulumi.Input[_builtins.bool] setup_alerts: Permission to set up alerts.
        :param pulumi.Input[_builtins.bool] setup_logs_rules: Permission to set up logs rules.
        :param pulumi.Input[_builtins.bool] setup_metrics_rules: Permission to set up metrics rules.
        :param pulumi.Input[_builtins.bool] write_logs: Permission to write logs.
        :param pulumi.Input[_builtins.bool] write_metrics: Permission to write metrics.
        :param pulumi.Input[_builtins.bool] write_traces: Permission to write traces.
        """
        if query_logs is not None:
            pulumi.set(__self__, "query_logs", query_logs)
        if query_metrics is not None:
            pulumi.set(__self__, "query_metrics", query_metrics)
        if query_traces is not None:
            pulumi.set(__self__, "query_traces", query_traces)
        if setup_alerts is not None:
            pulumi.set(__self__, "setup_alerts", setup_alerts)
        if setup_logs_rules is not None:
            pulumi.set(__self__, "setup_logs_rules", setup_logs_rules)
        if setup_metrics_rules is not None:
            pulumi.set(__self__, "setup_metrics_rules", setup_metrics_rules)
        if write_logs is not None:
            pulumi.set(__self__, "write_logs", write_logs)
        if write_metrics is not None:
            pulumi.set(__self__, "write_metrics", write_metrics)
        if write_traces is not None:
            pulumi.set(__self__, "write_traces", write_traces)

    @_builtins.property
    @pulumi.getter(name="queryLogs")
    def query_logs(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Permission to query logs.
        """
        return pulumi.get(self, "query_logs")

    @query_logs.setter
    def query_logs(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "query_logs", value)

    @_builtins.property
    @pulumi.getter(name="queryMetrics")
    def query_metrics(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Permission to query metrics.
        """
        return pulumi.get(self, "query_metrics")

    @query_metrics.setter
    def query_metrics(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "query_metrics", value)

    @_builtins.property
    @pulumi.getter(name="queryTraces")
    def query_traces(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Permission to query traces.
        """
        return pulumi.get(self, "query_traces")

    @query_traces.setter
    def query_traces(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "query_traces", value)

    @_builtins.property
    @pulumi.getter(name="setupAlerts")
    def setup_alerts(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Permission to set up alerts.
        """
        return pulumi.get(self, "setup_alerts")

    @setup_alerts.setter
    def setup_alerts(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "setup_alerts", value)

    @_builtins.property
    @pulumi.getter(name="setupLogsRules")
    def setup_logs_rules(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Permission to set up logs rules.
        """
        return pulumi.get(self, "setup_logs_rules")

    @setup_logs_rules.setter
    def setup_logs_rules(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "setup_logs_rules", value)

    @_builtins.property
    @pulumi.getter(name="setupMetricsRules")
    def setup_metrics_rules(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Permission to set up metrics rules.
        """
        return pulumi.get(self, "setup_metrics_rules")

    @setup_metrics_rules.setter
    def setup_metrics_rules(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "setup_metrics_rules", value)

    @_builtins.property
    @pulumi.getter(name="writeLogs")
    def write_logs(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Permission to write logs.
        """
        return pulumi.get(self, "write_logs")

    @write_logs.setter
    def write_logs(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "write_logs", value)

    @_builtins.property
    @pulumi.getter(name="writeMetrics")
    def write_metrics(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Permission to write metrics.
        """
        return pulumi.get(self, "write_metrics")

    @write_metrics.setter
    def write_metrics(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "write_metrics", value)

    @_builtins.property
    @pulumi.getter(name="writeTraces")
    def write_traces(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Permission to write traces.
        """
        return pulumi.get(self, "write_traces")

    @write_traces.setter
    def write_traces(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "write_traces", value)


if not MYPY:
    class ContainerHealthCheckArgsDict(TypedDict):
        failure_threshold: pulumi.Input[_builtins.int]
        """
        Number of consecutive health check failures before considering the container unhealthy.
        """
        https: pulumi.Input[Sequence[pulumi.Input['ContainerHealthCheckHttpArgsDict']]]
        """
        HTTP health check configuration.
        """
        interval: pulumi.Input[_builtins.str]
        """
        Period between health checks (in seconds).
        """
elif False:
    ContainerHealthCheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContainerHealthCheckArgs:
    def __init__(__self__, *,
                 failure_threshold: pulumi.Input[_builtins.int],
                 https: pulumi.Input[Sequence[pulumi.Input['ContainerHealthCheckHttpArgs']]],
                 interval: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.int] failure_threshold: Number of consecutive health check failures before considering the container unhealthy.
        :param pulumi.Input[Sequence[pulumi.Input['ContainerHealthCheckHttpArgs']]] https: HTTP health check configuration.
        :param pulumi.Input[_builtins.str] interval: Period between health checks (in seconds).
        """
        pulumi.set(__self__, "failure_threshold", failure_threshold)
        pulumi.set(__self__, "https", https)
        pulumi.set(__self__, "interval", interval)

    @_builtins.property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> pulumi.Input[_builtins.int]:
        """
        Number of consecutive health check failures before considering the container unhealthy.
        """
        return pulumi.get(self, "failure_threshold")

    @failure_threshold.setter
    def failure_threshold(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "failure_threshold", value)

    @_builtins.property
    @pulumi.getter
    def https(self) -> pulumi.Input[Sequence[pulumi.Input['ContainerHealthCheckHttpArgs']]]:
        """
        HTTP health check configuration.
        """
        return pulumi.get(self, "https")

    @https.setter
    def https(self, value: pulumi.Input[Sequence[pulumi.Input['ContainerHealthCheckHttpArgs']]]):
        pulumi.set(self, "https", value)

    @_builtins.property
    @pulumi.getter
    def interval(self) -> pulumi.Input[_builtins.str]:
        """
        Period between health checks (in seconds).
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "interval", value)


if not MYPY:
    class ContainerHealthCheckHttpArgsDict(TypedDict):
        path: pulumi.Input[_builtins.str]
        """
        Path to use for the HTTP health check.
        """
elif False:
    ContainerHealthCheckHttpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContainerHealthCheckHttpArgs:
    def __init__(__self__, *,
                 path: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] path: Path to use for the HTTP health check.
        """
        pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter
    def path(self) -> pulumi.Input[_builtins.str]:
        """
        Path to use for the HTTP health check.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "path", value)


if not MYPY:
    class ContainerScalingOptionArgsDict(TypedDict):
        concurrent_requests_threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        Scale depending on the number of concurrent requests being processed per container instance.
        """
        cpu_usage_threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        Scale depending on the CPU usage of a container instance.
        """
        memory_usage_threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        Scale depending on the memory usage of a container instance.
        """
elif False:
    ContainerScalingOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContainerScalingOptionArgs:
    def __init__(__self__, *,
                 concurrent_requests_threshold: Optional[pulumi.Input[_builtins.int]] = None,
                 cpu_usage_threshold: Optional[pulumi.Input[_builtins.int]] = None,
                 memory_usage_threshold: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] concurrent_requests_threshold: Scale depending on the number of concurrent requests being processed per container instance.
        :param pulumi.Input[_builtins.int] cpu_usage_threshold: Scale depending on the CPU usage of a container instance.
        :param pulumi.Input[_builtins.int] memory_usage_threshold: Scale depending on the memory usage of a container instance.
        """
        if concurrent_requests_threshold is not None:
            pulumi.set(__self__, "concurrent_requests_threshold", concurrent_requests_threshold)
        if cpu_usage_threshold is not None:
            pulumi.set(__self__, "cpu_usage_threshold", cpu_usage_threshold)
        if memory_usage_threshold is not None:
            pulumi.set(__self__, "memory_usage_threshold", memory_usage_threshold)

    @_builtins.property
    @pulumi.getter(name="concurrentRequestsThreshold")
    def concurrent_requests_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Scale depending on the number of concurrent requests being processed per container instance.
        """
        return pulumi.get(self, "concurrent_requests_threshold")

    @concurrent_requests_threshold.setter
    def concurrent_requests_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "concurrent_requests_threshold", value)

    @_builtins.property
    @pulumi.getter(name="cpuUsageThreshold")
    def cpu_usage_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Scale depending on the CPU usage of a container instance.
        """
        return pulumi.get(self, "cpu_usage_threshold")

    @cpu_usage_threshold.setter
    def cpu_usage_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "cpu_usage_threshold", value)

    @_builtins.property
    @pulumi.getter(name="memoryUsageThreshold")
    def memory_usage_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Scale depending on the memory usage of a container instance.
        """
        return pulumi.get(self, "memory_usage_threshold")

    @memory_usage_threshold.setter
    def memory_usage_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "memory_usage_threshold", value)


if not MYPY:
    class ContainerTriggerNatsArgsDict(TypedDict):
        subject: pulumi.Input[_builtins.str]
        """
        The subject to listen to.
        """
        account_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        unique identifier of the Messaging and Queuing NATS account.
        """
        project_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        THe ID of the project that contains the Messaging and Queuing NATS account (defaults to provider `project_id`)
        """
        region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Region where the Messaging and Queuing NATS account is enabled (defaults to provider `region`)
        """
elif False:
    ContainerTriggerNatsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContainerTriggerNatsArgs:
    def __init__(__self__, *,
                 subject: pulumi.Input[_builtins.str],
                 account_id: Optional[pulumi.Input[_builtins.str]] = None,
                 project_id: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] subject: The subject to listen to.
        :param pulumi.Input[_builtins.str] account_id: unique identifier of the Messaging and Queuing NATS account.
        :param pulumi.Input[_builtins.str] project_id: THe ID of the project that contains the Messaging and Queuing NATS account (defaults to provider `project_id`)
        :param pulumi.Input[_builtins.str] region: Region where the Messaging and Queuing NATS account is enabled (defaults to provider `region`)
        """
        pulumi.set(__self__, "subject", subject)
        if account_id is not None:
            pulumi.set(__self__, "account_id", account_id)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def subject(self) -> pulumi.Input[_builtins.str]:
        """
        The subject to listen to.
        """
        return pulumi.get(self, "subject")

    @subject.setter
    def subject(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "subject", value)

    @_builtins.property
    @pulumi.getter(name="accountId")
    def account_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        unique identifier of the Messaging and Queuing NATS account.
        """
        return pulumi.get(self, "account_id")

    @account_id.setter
    def account_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "account_id", value)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        THe ID of the project that contains the Messaging and Queuing NATS account (defaults to provider `project_id`)
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "project_id", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Region where the Messaging and Queuing NATS account is enabled (defaults to provider `region`)
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)


if not MYPY:
    class ContainerTriggerSqsArgsDict(TypedDict):
        queue: pulumi.Input[_builtins.str]
        """
        The name of the SQS queue.
        """
        namespace_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the Messaging and Queuing namespace. This argument is deprecated.
        """
        project_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the project in which SQS is enabled, (defaults to provider `project_id`)
        """
        region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Region where SQS is enabled (defaults to provider `region`)
        """
elif False:
    ContainerTriggerSqsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContainerTriggerSqsArgs:
    def __init__(__self__, *,
                 queue: pulumi.Input[_builtins.str],
                 namespace_id: Optional[pulumi.Input[_builtins.str]] = None,
                 project_id: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] queue: The name of the SQS queue.
        :param pulumi.Input[_builtins.str] namespace_id: ID of the Messaging and Queuing namespace. This argument is deprecated.
        :param pulumi.Input[_builtins.str] project_id: The ID of the project in which SQS is enabled, (defaults to provider `project_id`)
        :param pulumi.Input[_builtins.str] region: Region where SQS is enabled (defaults to provider `region`)
        """
        pulumi.set(__self__, "queue", queue)
        if namespace_id is not None:
            warnings.warn("""The 'namespace_id' field is deprecated and will be removed in the next major version. It is no longer necessary to specify it""", DeprecationWarning)
            pulumi.log.warn("""namespace_id is deprecated: The 'namespace_id' field is deprecated and will be removed in the next major version. It is no longer necessary to specify it""")
        if namespace_id is not None:
            pulumi.set(__self__, "namespace_id", namespace_id)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def queue(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the SQS queue.
        """
        return pulumi.get(self, "queue")

    @queue.setter
    def queue(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "queue", value)

    @_builtins.property
    @pulumi.getter(name="namespaceId")
    @_utilities.deprecated("""The 'namespace_id' field is deprecated and will be removed in the next major version. It is no longer necessary to specify it""")
    def namespace_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the Messaging and Queuing namespace. This argument is deprecated.
        """
        return pulumi.get(self, "namespace_id")

    @namespace_id.setter
    def namespace_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace_id", value)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the project in which SQS is enabled, (defaults to provider `project_id`)
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "project_id", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Region where SQS is enabled (defaults to provider `region`)
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)


if not MYPY:
    class DatabaseAclAclRuleArgsDict(TypedDict):
        ip: pulumi.Input[_builtins.str]
        """
        The IP range to whitelist in [CIDR notation](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#CIDR_notation)
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A text describing this rule. Default description: `IP allowed`
        """
elif False:
    DatabaseAclAclRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatabaseAclAclRuleArgs:
    def __init__(__self__, *,
                 ip: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ip: The IP range to whitelist in [CIDR notation](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#CIDR_notation)
        :param pulumi.Input[_builtins.str] description: A text describing this rule. Default description: `IP allowed`
        """
        pulumi.set(__self__, "ip", ip)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> pulumi.Input[_builtins.str]:
        """
        The IP range to whitelist in [CIDR notation](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#CIDR_notation)
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A text describing this rule. Default description: `IP allowed`
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class DatabaseInstanceLoadBalancerArgsDict(TypedDict):
        endpoint_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the endpoint.
        """
        hostname: NotRequired[pulumi.Input[_builtins.str]]
        """
        Hostname of the endpoint.
        """
        ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        IPv4 address on the network.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the Database Instance.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        Port in the Private Network.
        """
elif False:
    DatabaseInstanceLoadBalancerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatabaseInstanceLoadBalancerArgs:
    def __init__(__self__, *,
                 endpoint_id: Optional[pulumi.Input[_builtins.str]] = None,
                 hostname: Optional[pulumi.Input[_builtins.str]] = None,
                 ip: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] endpoint_id: The ID of the endpoint.
        :param pulumi.Input[_builtins.str] hostname: Hostname of the endpoint.
        :param pulumi.Input[_builtins.str] ip: IPv4 address on the network.
        :param pulumi.Input[_builtins.str] name: The name of the Database Instance.
        :param pulumi.Input[_builtins.int] port: Port in the Private Network.
        """
        if endpoint_id is not None:
            pulumi.set(__self__, "endpoint_id", endpoint_id)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the endpoint.
        """
        return pulumi.get(self, "endpoint_id")

    @endpoint_id.setter
    def endpoint_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "endpoint_id", value)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Hostname of the endpoint.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IPv4 address on the network.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the Database Instance.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Port in the Private Network.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class DatabaseInstanceLogsPolicyArgsDict(TypedDict):
        max_age_retention: NotRequired[pulumi.Input[_builtins.int]]
        """
        The max age (in days) of remote logs to keep on the Database Instance
        """
        total_disk_retention: NotRequired[pulumi.Input[_builtins.int]]
        """
        The max disk size of remote logs to keep on the Database Instance.
        """
elif False:
    DatabaseInstanceLogsPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatabaseInstanceLogsPolicyArgs:
    def __init__(__self__, *,
                 max_age_retention: Optional[pulumi.Input[_builtins.int]] = None,
                 total_disk_retention: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] max_age_retention: The max age (in days) of remote logs to keep on the Database Instance
        :param pulumi.Input[_builtins.int] total_disk_retention: The max disk size of remote logs to keep on the Database Instance.
        """
        if max_age_retention is not None:
            pulumi.set(__self__, "max_age_retention", max_age_retention)
        if total_disk_retention is not None:
            pulumi.set(__self__, "total_disk_retention", total_disk_retention)

    @_builtins.property
    @pulumi.getter(name="maxAgeRetention")
    def max_age_retention(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The max age (in days) of remote logs to keep on the Database Instance
        """
        return pulumi.get(self, "max_age_retention")

    @max_age_retention.setter
    def max_age_retention(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_age_retention", value)

    @_builtins.property
    @pulumi.getter(name="totalDiskRetention")
    def total_disk_retention(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The max disk size of remote logs to keep on the Database Instance.
        """
        return pulumi.get(self, "total_disk_retention")

    @total_disk_retention.setter
    def total_disk_retention(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "total_disk_retention", value)


if not MYPY:
    class DatabaseInstancePrivateIpArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[_builtins.str]]
        """
        The private IPv4 address.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Version ID to use in upgrade requests.
        """
elif False:
    DatabaseInstancePrivateIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatabaseInstancePrivateIpArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] address: The private IPv4 address.
        :param pulumi.Input[_builtins.str] id: Version ID to use in upgrade requests.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The private IPv4 address.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Version ID to use in upgrade requests.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class DatabaseInstancePrivateNetworkArgsDict(TypedDict):
        pn_id: pulumi.Input[_builtins.str]
        """
        The private network ID
        """
        enable_ipam: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether or not the private network endpoint should be configured with IPAM
        """
        endpoint_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the endpoint.
        """
        hostname: NotRequired[pulumi.Input[_builtins.str]]
        """
        Hostname of the endpoint.
        """
        ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        IPv4 address on the network.
        """
        ip_net: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IP with the given mask within the private subnet
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the Database Instance.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        Port in the Private Network.
        """
        zone: NotRequired[pulumi.Input[_builtins.str]]
        """
        The zone you want to attach the resource to
        """
elif False:
    DatabaseInstancePrivateNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatabaseInstancePrivateNetworkArgs:
    def __init__(__self__, *,
                 pn_id: pulumi.Input[_builtins.str],
                 enable_ipam: Optional[pulumi.Input[_builtins.bool]] = None,
                 endpoint_id: Optional[pulumi.Input[_builtins.str]] = None,
                 hostname: Optional[pulumi.Input[_builtins.str]] = None,
                 ip: Optional[pulumi.Input[_builtins.str]] = None,
                 ip_net: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 zone: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] pn_id: The private network ID
        :param pulumi.Input[_builtins.bool] enable_ipam: Whether or not the private network endpoint should be configured with IPAM
        :param pulumi.Input[_builtins.str] endpoint_id: The ID of the endpoint.
        :param pulumi.Input[_builtins.str] hostname: Hostname of the endpoint.
        :param pulumi.Input[_builtins.str] ip: IPv4 address on the network.
        :param pulumi.Input[_builtins.str] ip_net: The IP with the given mask within the private subnet
        :param pulumi.Input[_builtins.str] name: The name of the Database Instance.
        :param pulumi.Input[_builtins.int] port: Port in the Private Network.
        :param pulumi.Input[_builtins.str] zone: The zone you want to attach the resource to
        """
        pulumi.set(__self__, "pn_id", pn_id)
        if enable_ipam is not None:
            pulumi.set(__self__, "enable_ipam", enable_ipam)
        if endpoint_id is not None:
            pulumi.set(__self__, "endpoint_id", endpoint_id)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ip_net is not None:
            pulumi.set(__self__, "ip_net", ip_net)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if zone is not None:
            pulumi.set(__self__, "zone", zone)

    @_builtins.property
    @pulumi.getter(name="pnId")
    def pn_id(self) -> pulumi.Input[_builtins.str]:
        """
        The private network ID
        """
        return pulumi.get(self, "pn_id")

    @pn_id.setter
    def pn_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "pn_id", value)

    @_builtins.property
    @pulumi.getter(name="enableIpam")
    def enable_ipam(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether or not the private network endpoint should be configured with IPAM
        """
        return pulumi.get(self, "enable_ipam")

    @enable_ipam.setter
    def enable_ipam(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_ipam", value)

    @_builtins.property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the endpoint.
        """
        return pulumi.get(self, "endpoint_id")

    @endpoint_id.setter
    def endpoint_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "endpoint_id", value)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Hostname of the endpoint.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IPv4 address on the network.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter(name="ipNet")
    def ip_net(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IP with the given mask within the private subnet
        """
        return pulumi.get(self, "ip_net")

    @ip_net.setter
    def ip_net(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip_net", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the Database Instance.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Port in the Private Network.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def zone(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The zone you want to attach the resource to
        """
        return pulumi.get(self, "zone")

    @zone.setter
    def zone(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "zone", value)


if not MYPY:
    class DatabaseInstanceReadReplicaArgsDict(TypedDict):
        ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        IPv4 address on the network.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the Database Instance.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        Port in the Private Network.
        """
elif False:
    DatabaseInstanceReadReplicaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatabaseInstanceReadReplicaArgs:
    def __init__(__self__, *,
                 ip: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] ip: IPv4 address on the network.
        :param pulumi.Input[_builtins.str] name: The name of the Database Instance.
        :param pulumi.Input[_builtins.int] port: Port in the Private Network.
        """
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IPv4 address on the network.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the Database Instance.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Port in the Private Network.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class DatabaseInstanceUpgradableVersionArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Version ID to use in upgrade requests.
        """
        minor_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        Minor version string (e.g., `15.5.0`).
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the Database Instance.
        """
        version: NotRequired[pulumi.Input[_builtins.str]]
        """
        Version string (e.g., `15.5`).
        """
elif False:
    DatabaseInstanceUpgradableVersionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatabaseInstanceUpgradableVersionArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 minor_version: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 version: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: Version ID to use in upgrade requests.
        :param pulumi.Input[_builtins.str] minor_version: Minor version string (e.g., `15.5.0`).
        :param pulumi.Input[_builtins.str] name: The name of the Database Instance.
        :param pulumi.Input[_builtins.str] version: Version string (e.g., `15.5`).
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if minor_version is not None:
            pulumi.set(__self__, "minor_version", minor_version)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Version ID to use in upgrade requests.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="minorVersion")
    def minor_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Minor version string (e.g., `15.5.0`).
        """
        return pulumi.get(self, "minor_version")

    @minor_version.setter
    def minor_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "minor_version", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the Database Instance.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Version string (e.g., `15.5`).
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class DatabaseReadReplicaDirectAccessArgsDict(TypedDict):
        endpoint_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the endpoint of the Read Replica.
        """
        hostname: NotRequired[pulumi.Input[_builtins.str]]
        """
        Hostname of the endpoint. Only one of IP and hostname may be set.
        """
        ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        IPv4 address of the endpoint (IP address). Only one of IP and hostname may be set.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the endpoint.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        TCP port of the endpoint.
        """
elif False:
    DatabaseReadReplicaDirectAccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatabaseReadReplicaDirectAccessArgs:
    def __init__(__self__, *,
                 endpoint_id: Optional[pulumi.Input[_builtins.str]] = None,
                 hostname: Optional[pulumi.Input[_builtins.str]] = None,
                 ip: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] endpoint_id: The ID of the endpoint of the Read Replica.
        :param pulumi.Input[_builtins.str] hostname: Hostname of the endpoint. Only one of IP and hostname may be set.
        :param pulumi.Input[_builtins.str] ip: IPv4 address of the endpoint (IP address). Only one of IP and hostname may be set.
        :param pulumi.Input[_builtins.str] name: Name of the endpoint.
        :param pulumi.Input[_builtins.int] port: TCP port of the endpoint.
        """
        if endpoint_id is not None:
            pulumi.set(__self__, "endpoint_id", endpoint_id)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the endpoint of the Read Replica.
        """
        return pulumi.get(self, "endpoint_id")

    @endpoint_id.setter
    def endpoint_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "endpoint_id", value)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Hostname of the endpoint. Only one of IP and hostname may be set.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IPv4 address of the endpoint (IP address). Only one of IP and hostname may be set.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the endpoint.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        TCP port of the endpoint.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class DatabaseReadReplicaPrivateNetworkArgsDict(TypedDict):
        private_network_id: pulumi.Input[_builtins.str]
        """
        UUID of the Private Netork to be connected to the Read Replica.
        """
        enable_ipam: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, the IP network address within the private subnet is determined by the IP Address Management (IPAM) service.

        > **Important:** One of `service_ip` or `enable_ipam=true` must be set.
        """
        endpoint_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the endpoint of the Read Replica.
        """
        hostname: NotRequired[pulumi.Input[_builtins.str]]
        """
        Hostname of the endpoint. Only one of IP and hostname may be set.
        """
        ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        IPv4 address of the endpoint (IP address). Only one of IP and hostname may be set.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the endpoint.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        TCP port of the endpoint.
        """
        service_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IP network address within the private subnet. This must be an IPv4 address with a CIDR notation. If not set, The IP network address within the private subnet is determined by the IP Address Management (IPAM) service.
        """
        zone: NotRequired[pulumi.Input[_builtins.str]]
        """
        Private network zone
        """
elif False:
    DatabaseReadReplicaPrivateNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatabaseReadReplicaPrivateNetworkArgs:
    def __init__(__self__, *,
                 private_network_id: pulumi.Input[_builtins.str],
                 enable_ipam: Optional[pulumi.Input[_builtins.bool]] = None,
                 endpoint_id: Optional[pulumi.Input[_builtins.str]] = None,
                 hostname: Optional[pulumi.Input[_builtins.str]] = None,
                 ip: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 service_ip: Optional[pulumi.Input[_builtins.str]] = None,
                 zone: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] private_network_id: UUID of the Private Netork to be connected to the Read Replica.
        :param pulumi.Input[_builtins.bool] enable_ipam: If true, the IP network address within the private subnet is determined by the IP Address Management (IPAM) service.
               
               > **Important:** One of `service_ip` or `enable_ipam=true` must be set.
        :param pulumi.Input[_builtins.str] endpoint_id: The ID of the endpoint of the Read Replica.
        :param pulumi.Input[_builtins.str] hostname: Hostname of the endpoint. Only one of IP and hostname may be set.
        :param pulumi.Input[_builtins.str] ip: IPv4 address of the endpoint (IP address). Only one of IP and hostname may be set.
        :param pulumi.Input[_builtins.str] name: Name of the endpoint.
        :param pulumi.Input[_builtins.int] port: TCP port of the endpoint.
        :param pulumi.Input[_builtins.str] service_ip: The IP network address within the private subnet. This must be an IPv4 address with a CIDR notation. If not set, The IP network address within the private subnet is determined by the IP Address Management (IPAM) service.
        :param pulumi.Input[_builtins.str] zone: Private network zone
        """
        pulumi.set(__self__, "private_network_id", private_network_id)
        if enable_ipam is not None:
            pulumi.set(__self__, "enable_ipam", enable_ipam)
        if endpoint_id is not None:
            pulumi.set(__self__, "endpoint_id", endpoint_id)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if service_ip is not None:
            pulumi.set(__self__, "service_ip", service_ip)
        if zone is not None:
            pulumi.set(__self__, "zone", zone)

    @_builtins.property
    @pulumi.getter(name="privateNetworkId")
    def private_network_id(self) -> pulumi.Input[_builtins.str]:
        """
        UUID of the Private Netork to be connected to the Read Replica.
        """
        return pulumi.get(self, "private_network_id")

    @private_network_id.setter
    def private_network_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "private_network_id", value)

    @_builtins.property
    @pulumi.getter(name="enableIpam")
    def enable_ipam(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, the IP network address within the private subnet is determined by the IP Address Management (IPAM) service.

        > **Important:** One of `service_ip` or `enable_ipam=true` must be set.
        """
        return pulumi.get(self, "enable_ipam")

    @enable_ipam.setter
    def enable_ipam(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_ipam", value)

    @_builtins.property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the endpoint of the Read Replica.
        """
        return pulumi.get(self, "endpoint_id")

    @endpoint_id.setter
    def endpoint_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "endpoint_id", value)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Hostname of the endpoint. Only one of IP and hostname may be set.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IPv4 address of the endpoint (IP address). Only one of IP and hostname may be set.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the endpoint.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        TCP port of the endpoint.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="serviceIp")
    def service_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IP network address within the private subnet. This must be an IPv4 address with a CIDR notation. If not set, The IP network address within the private subnet is determined by the IP Address Management (IPAM) service.
        """
        return pulumi.get(self, "service_ip")

    @service_ip.setter
    def service_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service_ip", value)

    @_builtins.property
    @pulumi.getter
    def zone(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Private network zone
        """
        return pulumi.get(self, "zone")

    @zone.setter
    def zone(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "zone", value)


if not MYPY:
    class DomainRecordGeoIpArgsDict(TypedDict):
        matches: pulumi.Input[Sequence[pulumi.Input['DomainRecordGeoIpMatchArgsDict']]]
        """
        The list of matches
        """
elif False:
    DomainRecordGeoIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainRecordGeoIpArgs:
    def __init__(__self__, *,
                 matches: pulumi.Input[Sequence[pulumi.Input['DomainRecordGeoIpMatchArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DomainRecordGeoIpMatchArgs']]] matches: The list of matches
        """
        pulumi.set(__self__, "matches", matches)

    @_builtins.property
    @pulumi.getter
    def matches(self) -> pulumi.Input[Sequence[pulumi.Input['DomainRecordGeoIpMatchArgs']]]:
        """
        The list of matches
        """
        return pulumi.get(self, "matches")

    @matches.setter
    def matches(self, value: pulumi.Input[Sequence[pulumi.Input['DomainRecordGeoIpMatchArgs']]]):
        pulumi.set(self, "matches", value)


if not MYPY:
    class DomainRecordGeoIpMatchArgsDict(TypedDict):
        data: pulumi.Input[_builtins.str]
        """
        The content of the record (an IPv4 for an `A` record, a string for a `TXT` record, etc.).
        """
        continents: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of continents (eg: EU for Europe, NA for North America, AS for Asia...). List of all continents code: https://api.scaleway.com/domain-private/v2beta1/continents
        """
        countries: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of countries (eg: FR for France, US for the United States, GB for Great Britain...). List of all countries code: https://api.scaleway.com/domain-private/v2beta1/countries
        """
elif False:
    DomainRecordGeoIpMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainRecordGeoIpMatchArgs:
    def __init__(__self__, *,
                 data: pulumi.Input[_builtins.str],
                 continents: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 countries: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] data: The content of the record (an IPv4 for an `A` record, a string for a `TXT` record, etc.).
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] continents: List of continents (eg: EU for Europe, NA for North America, AS for Asia...). List of all continents code: https://api.scaleway.com/domain-private/v2beta1/continents
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] countries: List of countries (eg: FR for France, US for the United States, GB for Great Britain...). List of all countries code: https://api.scaleway.com/domain-private/v2beta1/countries
        """
        pulumi.set(__self__, "data", data)
        if continents is not None:
            pulumi.set(__self__, "continents", continents)
        if countries is not None:
            pulumi.set(__self__, "countries", countries)

    @_builtins.property
    @pulumi.getter
    def data(self) -> pulumi.Input[_builtins.str]:
        """
        The content of the record (an IPv4 for an `A` record, a string for a `TXT` record, etc.).
        """
        return pulumi.get(self, "data")

    @data.setter
    def data(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "data", value)

    @_builtins.property
    @pulumi.getter
    def continents(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of continents (eg: EU for Europe, NA for North America, AS for Asia...). List of all continents code: https://api.scaleway.com/domain-private/v2beta1/continents
        """
        return pulumi.get(self, "continents")

    @continents.setter
    def continents(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "continents", value)

    @_builtins.property
    @pulumi.getter
    def countries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of countries (eg: FR for France, US for the United States, GB for Great Britain...). List of all countries code: https://api.scaleway.com/domain-private/v2beta1/countries
        """
        return pulumi.get(self, "countries")

    @countries.setter
    def countries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "countries", value)


if not MYPY:
    class DomainRecordHttpServiceArgsDict(TypedDict):
        ips: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        IPs to check
        """
        must_contain: pulumi.Input[_builtins.str]
        """
        Text to search
        """
        strategy: pulumi.Input[_builtins.str]
        """
        Strategy to return an IP from the IPs list
        """
        url: pulumi.Input[_builtins.str]
        """
        URL to match the must_contain text to validate an IP
        """
        user_agent: NotRequired[pulumi.Input[_builtins.str]]
        """
        User-agent used when checking the URL
        """
elif False:
    DomainRecordHttpServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainRecordHttpServiceArgs:
    def __init__(__self__, *,
                 ips: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 must_contain: pulumi.Input[_builtins.str],
                 strategy: pulumi.Input[_builtins.str],
                 url: pulumi.Input[_builtins.str],
                 user_agent: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ips: IPs to check
        :param pulumi.Input[_builtins.str] must_contain: Text to search
        :param pulumi.Input[_builtins.str] strategy: Strategy to return an IP from the IPs list
        :param pulumi.Input[_builtins.str] url: URL to match the must_contain text to validate an IP
        :param pulumi.Input[_builtins.str] user_agent: User-agent used when checking the URL
        """
        pulumi.set(__self__, "ips", ips)
        pulumi.set(__self__, "must_contain", must_contain)
        pulumi.set(__self__, "strategy", strategy)
        pulumi.set(__self__, "url", url)
        if user_agent is not None:
            pulumi.set(__self__, "user_agent", user_agent)

    @_builtins.property
    @pulumi.getter
    def ips(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        IPs to check
        """
        return pulumi.get(self, "ips")

    @ips.setter
    def ips(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "ips", value)

    @_builtins.property
    @pulumi.getter(name="mustContain")
    def must_contain(self) -> pulumi.Input[_builtins.str]:
        """
        Text to search
        """
        return pulumi.get(self, "must_contain")

    @must_contain.setter
    def must_contain(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "must_contain", value)

    @_builtins.property
    @pulumi.getter
    def strategy(self) -> pulumi.Input[_builtins.str]:
        """
        Strategy to return an IP from the IPs list
        """
        return pulumi.get(self, "strategy")

    @strategy.setter
    def strategy(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "strategy", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        URL to match the must_contain text to validate an IP
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="userAgent")
    def user_agent(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        User-agent used when checking the URL
        """
        return pulumi.get(self, "user_agent")

    @user_agent.setter
    def user_agent(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user_agent", value)


if not MYPY:
    class DomainRecordViewArgsDict(TypedDict):
        data: pulumi.Input[_builtins.str]
        """
        The content of the record (an IPv4 for an `A` record, a string for a `TXT` record, etc.).
        """
        subnet: pulumi.Input[_builtins.str]
        """
        The subnet of the view
        """
elif False:
    DomainRecordViewArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainRecordViewArgs:
    def __init__(__self__, *,
                 data: pulumi.Input[_builtins.str],
                 subnet: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] data: The content of the record (an IPv4 for an `A` record, a string for a `TXT` record, etc.).
        :param pulumi.Input[_builtins.str] subnet: The subnet of the view
        """
        pulumi.set(__self__, "data", data)
        pulumi.set(__self__, "subnet", subnet)

    @_builtins.property
    @pulumi.getter
    def data(self) -> pulumi.Input[_builtins.str]:
        """
        The content of the record (an IPv4 for an `A` record, a string for a `TXT` record, etc.).
        """
        return pulumi.get(self, "data")

    @data.setter
    def data(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "data", value)

    @_builtins.property
    @pulumi.getter
    def subnet(self) -> pulumi.Input[_builtins.str]:
        """
        The subnet of the view
        """
        return pulumi.get(self, "subnet")

    @subnet.setter
    def subnet(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "subnet", value)


if not MYPY:
    class DomainRecordWeightedArgsDict(TypedDict):
        ip: pulumi.Input[_builtins.str]
        """
        The weighted IP
        """
        weight: pulumi.Input[_builtins.int]
        """
        The weight of the IP
        """
elif False:
    DomainRecordWeightedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainRecordWeightedArgs:
    def __init__(__self__, *,
                 ip: pulumi.Input[_builtins.str],
                 weight: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.str] ip: The weighted IP
        :param pulumi.Input[_builtins.int] weight: The weight of the IP
        """
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> pulumi.Input[_builtins.str]:
        """
        The weighted IP
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter
    def weight(self) -> pulumi.Input[_builtins.int]:
        """
        The weight of the IP
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class EdgeServicesBackendStageLbBackendConfigArgsDict(TypedDict):
        lb_config: NotRequired[pulumi.Input['EdgeServicesBackendStageLbBackendConfigLbConfigArgsDict']]
        """
        The Load Balancer config.
        """
elif False:
    EdgeServicesBackendStageLbBackendConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EdgeServicesBackendStageLbBackendConfigArgs:
    def __init__(__self__, *,
                 lb_config: Optional[pulumi.Input['EdgeServicesBackendStageLbBackendConfigLbConfigArgs']] = None):
        """
        :param pulumi.Input['EdgeServicesBackendStageLbBackendConfigLbConfigArgs'] lb_config: The Load Balancer config.
        """
        if lb_config is not None:
            pulumi.set(__self__, "lb_config", lb_config)

    @_builtins.property
    @pulumi.getter(name="lbConfig")
    def lb_config(self) -> Optional[pulumi.Input['EdgeServicesBackendStageLbBackendConfigLbConfigArgs']]:
        """
        The Load Balancer config.
        """
        return pulumi.get(self, "lb_config")

    @lb_config.setter
    def lb_config(self, value: Optional[pulumi.Input['EdgeServicesBackendStageLbBackendConfigLbConfigArgs']]):
        pulumi.set(self, "lb_config", value)


if not MYPY:
    class EdgeServicesBackendStageLbBackendConfigLbConfigArgsDict(TypedDict):
        domain_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Fully Qualified Domain Name (in the format subdomain.example.com) to use in HTTP requests sent towards your Load Balancer.
        """
        frontend_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the frontend.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the Load Balancer.
        """
        is_ssl: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Defines whether the Load Balancer's frontend handles SSL connections.
        """
        zone: NotRequired[pulumi.Input[_builtins.str]]
        """
        `zone`) The zone of the Load Balancer.
        """
elif False:
    EdgeServicesBackendStageLbBackendConfigLbConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EdgeServicesBackendStageLbBackendConfigLbConfigArgs:
    def __init__(__self__, *,
                 domain_name: Optional[pulumi.Input[_builtins.str]] = None,
                 frontend_id: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 is_ssl: Optional[pulumi.Input[_builtins.bool]] = None,
                 zone: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] domain_name: The Fully Qualified Domain Name (in the format subdomain.example.com) to use in HTTP requests sent towards your Load Balancer.
        :param pulumi.Input[_builtins.str] frontend_id: The ID of the frontend.
        :param pulumi.Input[_builtins.str] id: The ID of the Load Balancer.
        :param pulumi.Input[_builtins.bool] is_ssl: Defines whether the Load Balancer's frontend handles SSL connections.
        :param pulumi.Input[_builtins.str] zone: `zone`) The zone of the Load Balancer.
        """
        if domain_name is not None:
            pulumi.set(__self__, "domain_name", domain_name)
        if frontend_id is not None:
            pulumi.set(__self__, "frontend_id", frontend_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_ssl is not None:
            pulumi.set(__self__, "is_ssl", is_ssl)
        if zone is not None:
            pulumi.set(__self__, "zone", zone)

    @_builtins.property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Fully Qualified Domain Name (in the format subdomain.example.com) to use in HTTP requests sent towards your Load Balancer.
        """
        return pulumi.get(self, "domain_name")

    @domain_name.setter
    def domain_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "domain_name", value)

    @_builtins.property
    @pulumi.getter(name="frontendId")
    def frontend_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the frontend.
        """
        return pulumi.get(self, "frontend_id")

    @frontend_id.setter
    def frontend_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "frontend_id", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the Load Balancer.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="isSsl")
    def is_ssl(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Defines whether the Load Balancer's frontend handles SSL connections.
        """
        return pulumi.get(self, "is_ssl")

    @is_ssl.setter
    def is_ssl(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_ssl", value)

    @_builtins.property
    @pulumi.getter
    def zone(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        `zone`) The zone of the Load Balancer.
        """
        return pulumi.get(self, "zone")

    @zone.setter
    def zone(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "zone", value)


if not MYPY:
    class EdgeServicesBackendStageS3BackendConfigArgsDict(TypedDict):
        bucket_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the Bucket.
        """
        bucket_region: NotRequired[pulumi.Input[_builtins.str]]
        """
        The region of the Bucket.
        """
        is_website: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Defines whether the bucket website feature is enabled.
        """
elif False:
    EdgeServicesBackendStageS3BackendConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EdgeServicesBackendStageS3BackendConfigArgs:
    def __init__(__self__, *,
                 bucket_name: Optional[pulumi.Input[_builtins.str]] = None,
                 bucket_region: Optional[pulumi.Input[_builtins.str]] = None,
                 is_website: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] bucket_name: The name of the Bucket.
        :param pulumi.Input[_builtins.str] bucket_region: The region of the Bucket.
        :param pulumi.Input[_builtins.bool] is_website: Defines whether the bucket website feature is enabled.
        """
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if bucket_region is not None:
            pulumi.set(__self__, "bucket_region", bucket_region)
        if is_website is not None:
            pulumi.set(__self__, "is_website", is_website)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the Bucket.
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket_name", value)

    @_builtins.property
    @pulumi.getter(name="bucketRegion")
    def bucket_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The region of the Bucket.
        """
        return pulumi.get(self, "bucket_region")

    @bucket_region.setter
    def bucket_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket_region", value)

    @_builtins.property
    @pulumi.getter(name="isWebsite")
    def is_website(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Defines whether the bucket website feature is enabled.
        """
        return pulumi.get(self, "is_website")

    @is_website.setter
    def is_website(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_website", value)


if not MYPY:
    class EdgeServicesCacheStagePurgeRequestArgsDict(TypedDict):
        all: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Defines whether to purge all content.
        """
        assets: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The list of asserts to purge.
        """
        pipeline_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The pipeline ID in which the purge request will be created.
        """
elif False:
    EdgeServicesCacheStagePurgeRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EdgeServicesCacheStagePurgeRequestArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input[_builtins.bool]] = None,
                 assets: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 pipeline_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] all: Defines whether to purge all content.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] assets: The list of asserts to purge.
        :param pulumi.Input[_builtins.str] pipeline_id: The pipeline ID in which the purge request will be created.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if assets is not None:
            pulumi.set(__self__, "assets", assets)
        if pipeline_id is not None:
            pulumi.set(__self__, "pipeline_id", pipeline_id)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Defines whether to purge all content.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter
    def assets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The list of asserts to purge.
        """
        return pulumi.get(self, "assets")

    @assets.setter
    def assets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "assets", value)

    @_builtins.property
    @pulumi.getter(name="pipelineId")
    def pipeline_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The pipeline ID in which the purge request will be created.
        """
        return pulumi.get(self, "pipeline_id")

    @pipeline_id.setter
    def pipeline_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "pipeline_id", value)


if not MYPY:
    class EdgeServicesRouteStageRuleArgsDict(TypedDict):
        backend_stage_id: pulumi.Input[_builtins.str]
        """
        The ID of the backend stage that requests matching the rule should be forwarded to.
        """
        rule_http_match: NotRequired[pulumi.Input['EdgeServicesRouteStageRuleRuleHttpMatchArgsDict']]
        """
        The rule condition to be matched. Requests matching the condition defined here will be directly forwarded to the backend specified by the `backend_stage_id` field. Requests that do not match will be checked by the next rule's condition.
        """
elif False:
    EdgeServicesRouteStageRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EdgeServicesRouteStageRuleArgs:
    def __init__(__self__, *,
                 backend_stage_id: pulumi.Input[_builtins.str],
                 rule_http_match: Optional[pulumi.Input['EdgeServicesRouteStageRuleRuleHttpMatchArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] backend_stage_id: The ID of the backend stage that requests matching the rule should be forwarded to.
        :param pulumi.Input['EdgeServicesRouteStageRuleRuleHttpMatchArgs'] rule_http_match: The rule condition to be matched. Requests matching the condition defined here will be directly forwarded to the backend specified by the `backend_stage_id` field. Requests that do not match will be checked by the next rule's condition.
        """
        pulumi.set(__self__, "backend_stage_id", backend_stage_id)
        if rule_http_match is not None:
            pulumi.set(__self__, "rule_http_match", rule_http_match)

    @_builtins.property
    @pulumi.getter(name="backendStageId")
    def backend_stage_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the backend stage that requests matching the rule should be forwarded to.
        """
        return pulumi.get(self, "backend_stage_id")

    @backend_stage_id.setter
    def backend_stage_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "backend_stage_id", value)

    @_builtins.property
    @pulumi.getter(name="ruleHttpMatch")
    def rule_http_match(self) -> Optional[pulumi.Input['EdgeServicesRouteStageRuleRuleHttpMatchArgs']]:
        """
        The rule condition to be matched. Requests matching the condition defined here will be directly forwarded to the backend specified by the `backend_stage_id` field. Requests that do not match will be checked by the next rule's condition.
        """
        return pulumi.get(self, "rule_http_match")

    @rule_http_match.setter
    def rule_http_match(self, value: Optional[pulumi.Input['EdgeServicesRouteStageRuleRuleHttpMatchArgs']]):
        pulumi.set(self, "rule_http_match", value)


if not MYPY:
    class EdgeServicesRouteStageRuleRuleHttpMatchArgsDict(TypedDict):
        method_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        HTTP methods to filter for. A request using any of these methods will be considered to match the rule. Possible values are `get`, `post`, `put`, `patch`, `delete`, `head`, `options`. All methods will match if none is provided.
        """
        path_filter: NotRequired[pulumi.Input['EdgeServicesRouteStageRuleRuleHttpMatchPathFilterArgsDict']]
        """
        HTTP URL path to filter for. A request whose path matches the given filter will be considered to match the rule. All paths will match if none is provided.
        """
elif False:
    EdgeServicesRouteStageRuleRuleHttpMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EdgeServicesRouteStageRuleRuleHttpMatchArgs:
    def __init__(__self__, *,
                 method_filters: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 path_filter: Optional[pulumi.Input['EdgeServicesRouteStageRuleRuleHttpMatchPathFilterArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] method_filters: HTTP methods to filter for. A request using any of these methods will be considered to match the rule. Possible values are `get`, `post`, `put`, `patch`, `delete`, `head`, `options`. All methods will match if none is provided.
        :param pulumi.Input['EdgeServicesRouteStageRuleRuleHttpMatchPathFilterArgs'] path_filter: HTTP URL path to filter for. A request whose path matches the given filter will be considered to match the rule. All paths will match if none is provided.
        """
        if method_filters is not None:
            pulumi.set(__self__, "method_filters", method_filters)
        if path_filter is not None:
            pulumi.set(__self__, "path_filter", path_filter)

    @_builtins.property
    @pulumi.getter(name="methodFilters")
    def method_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        HTTP methods to filter for. A request using any of these methods will be considered to match the rule. Possible values are `get`, `post`, `put`, `patch`, `delete`, `head`, `options`. All methods will match if none is provided.
        """
        return pulumi.get(self, "method_filters")

    @method_filters.setter
    def method_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "method_filters", value)

    @_builtins.property
    @pulumi.getter(name="pathFilter")
    def path_filter(self) -> Optional[pulumi.Input['EdgeServicesRouteStageRuleRuleHttpMatchPathFilterArgs']]:
        """
        HTTP URL path to filter for. A request whose path matches the given filter will be considered to match the rule. All paths will match if none is provided.
        """
        return pulumi.get(self, "path_filter")

    @path_filter.setter
    def path_filter(self, value: Optional[pulumi.Input['EdgeServicesRouteStageRuleRuleHttpMatchPathFilterArgs']]):
        pulumi.set(self, "path_filter", value)


if not MYPY:
    class EdgeServicesRouteStageRuleRuleHttpMatchPathFilterArgsDict(TypedDict):
        path_filter_type: pulumi.Input[_builtins.str]
        """
        The type of filter to match for the HTTP URL path. For now, all path filters must be written in regex and use the `regex` type.
        """
        value: pulumi.Input[_builtins.str]
        """
        The value to be matched for the HTTP URL path.
        """
elif False:
    EdgeServicesRouteStageRuleRuleHttpMatchPathFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EdgeServicesRouteStageRuleRuleHttpMatchPathFilterArgs:
    def __init__(__self__, *,
                 path_filter_type: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] path_filter_type: The type of filter to match for the HTTP URL path. For now, all path filters must be written in regex and use the `regex` type.
        :param pulumi.Input[_builtins.str] value: The value to be matched for the HTTP URL path.
        """
        pulumi.set(__self__, "path_filter_type", path_filter_type)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="pathFilterType")
    def path_filter_type(self) -> pulumi.Input[_builtins.str]:
        """
        The type of filter to match for the HTTP URL path. For now, all path filters must be written in regex and use the `regex` type.
        """
        return pulumi.get(self, "path_filter_type")

    @path_filter_type.setter
    def path_filter_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "path_filter_type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        The value to be matched for the HTTP URL path.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class EdgeServicesTlsStageSecretArgsDict(TypedDict):
        region: NotRequired[pulumi.Input[_builtins.str]]
        """
        The region of the secret.
        """
        secret_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the Secret
        """
elif False:
    EdgeServicesTlsStageSecretArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EdgeServicesTlsStageSecretArgs:
    def __init__(__self__, *,
                 region: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] region: The region of the secret.
        :param pulumi.Input[_builtins.str] secret_id: The ID of the Secret
        """
        if region is not None:
            pulumi.set(__self__, "region", region)
        if secret_id is not None:
            pulumi.set(__self__, "secret_id", secret_id)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The region of the secret.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="secretId")
    def secret_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the Secret
        """
        return pulumi.get(self, "secret_id")

    @secret_id.setter
    def secret_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_id", value)


if not MYPY:
    class FunctionTriggerNatsArgsDict(TypedDict):
        subject: pulumi.Input[_builtins.str]
        """
        The subject to listen to.
        """
        account_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        unique identifier of the Messaging and Queuing NATS account.
        """
        project_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        THe ID of the project that contains the Messaging and Queuing NATS account (defaults to provider `project_id`)
        """
        region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Region where the Messaging and Queuing NATS account is enabled (defaults to provider `region`)
        """
elif False:
    FunctionTriggerNatsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionTriggerNatsArgs:
    def __init__(__self__, *,
                 subject: pulumi.Input[_builtins.str],
                 account_id: Optional[pulumi.Input[_builtins.str]] = None,
                 project_id: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] subject: The subject to listen to.
        :param pulumi.Input[_builtins.str] account_id: unique identifier of the Messaging and Queuing NATS account.
        :param pulumi.Input[_builtins.str] project_id: THe ID of the project that contains the Messaging and Queuing NATS account (defaults to provider `project_id`)
        :param pulumi.Input[_builtins.str] region: Region where the Messaging and Queuing NATS account is enabled (defaults to provider `region`)
        """
        pulumi.set(__self__, "subject", subject)
        if account_id is not None:
            pulumi.set(__self__, "account_id", account_id)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def subject(self) -> pulumi.Input[_builtins.str]:
        """
        The subject to listen to.
        """
        return pulumi.get(self, "subject")

    @subject.setter
    def subject(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "subject", value)

    @_builtins.property
    @pulumi.getter(name="accountId")
    def account_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        unique identifier of the Messaging and Queuing NATS account.
        """
        return pulumi.get(self, "account_id")

    @account_id.setter
    def account_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "account_id", value)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        THe ID of the project that contains the Messaging and Queuing NATS account (defaults to provider `project_id`)
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "project_id", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Region where the Messaging and Queuing NATS account is enabled (defaults to provider `region`)
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)


if not MYPY:
    class FunctionTriggerSqsArgsDict(TypedDict):
        queue: pulumi.Input[_builtins.str]
        """
        The name of the SQS queue.
        """
        namespace_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the Messaging and Queuing namespace. This argument is deprecated.
        """
        project_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the project in which SQS is enabled, (defaults to provider `project_id`)
        """
        region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Region where SQS is enabled (defaults to provider `region`)
        """
elif False:
    FunctionTriggerSqsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionTriggerSqsArgs:
    def __init__(__self__, *,
                 queue: pulumi.Input[_builtins.str],
                 namespace_id: Optional[pulumi.Input[_builtins.str]] = None,
                 project_id: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] queue: The name of the SQS queue.
        :param pulumi.Input[_builtins.str] namespace_id: ID of the Messaging and Queuing namespace. This argument is deprecated.
        :param pulumi.Input[_builtins.str] project_id: The ID of the project in which SQS is enabled, (defaults to provider `project_id`)
        :param pulumi.Input[_builtins.str] region: Region where SQS is enabled (defaults to provider `region`)
        """
        pulumi.set(__self__, "queue", queue)
        if namespace_id is not None:
            warnings.warn("""The 'namespace_id' field is deprecated and will be removed in the next major version. It is no longer necessary to specify it""", DeprecationWarning)
            pulumi.log.warn("""namespace_id is deprecated: The 'namespace_id' field is deprecated and will be removed in the next major version. It is no longer necessary to specify it""")
        if namespace_id is not None:
            pulumi.set(__self__, "namespace_id", namespace_id)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def queue(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the SQS queue.
        """
        return pulumi.get(self, "queue")

    @queue.setter
    def queue(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "queue", value)

    @_builtins.property
    @pulumi.getter(name="namespaceId")
    @_utilities.deprecated("""The 'namespace_id' field is deprecated and will be removed in the next major version. It is no longer necessary to specify it""")
    def namespace_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the Messaging and Queuing namespace. This argument is deprecated.
        """
        return pulumi.get(self, "namespace_id")

    @namespace_id.setter
    def namespace_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace_id", value)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the project in which SQS is enabled, (defaults to provider `project_id`)
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "project_id", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Region where SQS is enabled (defaults to provider `region`)
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)


if not MYPY:
    class IamPolicyRuleArgsDict(TypedDict):
        permission_set_names: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Names of permission sets bind to the rule.
        """
        condition: NotRequired[pulumi.Input[_builtins.str]]
        """
        The condition of the rule.

        **_TIP:_** You can use the Scaleway CLI to list the permissions details. e.g:

        ```shell
        scw iam permission-set list
        ```
        """
        organization_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of organization scoped to the rule, this can be used to create a rule for all projects in an organization.
        """
        project_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of project IDs scoped to the rule.

        > **Important** One `organization_id` or `project_ids` must be set per rule.
        """
elif False:
    IamPolicyRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IamPolicyRuleArgs:
    def __init__(__self__, *,
                 permission_set_names: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 condition: Optional[pulumi.Input[_builtins.str]] = None,
                 organization_id: Optional[pulumi.Input[_builtins.str]] = None,
                 project_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] permission_set_names: Names of permission sets bind to the rule.
        :param pulumi.Input[_builtins.str] condition: The condition of the rule.
               
               **_TIP:_** You can use the Scaleway CLI to list the permissions details. e.g:
               
               ```shell
               scw iam permission-set list
               ```
        :param pulumi.Input[_builtins.str] organization_id: ID of organization scoped to the rule, this can be used to create a rule for all projects in an organization.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] project_ids: List of project IDs scoped to the rule.
               
               > **Important** One `organization_id` or `project_ids` must be set per rule.
        """
        pulumi.set(__self__, "permission_set_names", permission_set_names)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if organization_id is not None:
            pulumi.set(__self__, "organization_id", organization_id)
        if project_ids is not None:
            pulumi.set(__self__, "project_ids", project_ids)

    @_builtins.property
    @pulumi.getter(name="permissionSetNames")
    def permission_set_names(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Names of permission sets bind to the rule.
        """
        return pulumi.get(self, "permission_set_names")

    @permission_set_names.setter
    def permission_set_names(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "permission_set_names", value)

    @_builtins.property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The condition of the rule.

        **_TIP:_** You can use the Scaleway CLI to list the permissions details. e.g:

        ```shell
        scw iam permission-set list
        ```
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "condition", value)

    @_builtins.property
    @pulumi.getter(name="organizationId")
    def organization_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of organization scoped to the rule, this can be used to create a rule for all projects in an organization.
        """
        return pulumi.get(self, "organization_id")

    @organization_id.setter
    def organization_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "organization_id", value)

    @_builtins.property
    @pulumi.getter(name="projectIds")
    def project_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of project IDs scoped to the rule.

        > **Important** One `organization_id` or `project_ids` must be set per rule.
        """
        return pulumi.get(self, "project_ids")

    @project_ids.setter
    def project_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "project_ids", value)


if not MYPY:
    class InferenceDeploymentPrivateEndpointArgsDict(TypedDict):
        disable_auth: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Disable the authentication on the endpoint.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Optional) The id of the public endpoint.
        """
        private_network_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the private network to use.
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Optional) The URL of the endpoint.
        """
elif False:
    InferenceDeploymentPrivateEndpointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InferenceDeploymentPrivateEndpointArgs:
    def __init__(__self__, *,
                 disable_auth: Optional[pulumi.Input[_builtins.bool]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 private_network_id: Optional[pulumi.Input[_builtins.str]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] disable_auth: Disable the authentication on the endpoint.
        :param pulumi.Input[_builtins.str] id: (Optional) The id of the public endpoint.
        :param pulumi.Input[_builtins.str] private_network_id: The ID of the private network to use.
        :param pulumi.Input[_builtins.str] url: (Optional) The URL of the endpoint.
        """
        if disable_auth is not None:
            pulumi.set(__self__, "disable_auth", disable_auth)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if private_network_id is not None:
            pulumi.set(__self__, "private_network_id", private_network_id)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter(name="disableAuth")
    def disable_auth(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Disable the authentication on the endpoint.
        """
        return pulumi.get(self, "disable_auth")

    @disable_auth.setter
    def disable_auth(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_auth", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Optional) The id of the public endpoint.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="privateNetworkId")
    def private_network_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the private network to use.
        """
        return pulumi.get(self, "private_network_id")

    @private_network_id.setter
    def private_network_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "private_network_id", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Optional) The URL of the endpoint.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class InferenceDeploymentPrivateIpArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[_builtins.str]]
        """
        The private IPv4 address.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Optional) The id of the public endpoint.
        """
elif False:
    InferenceDeploymentPrivateIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InferenceDeploymentPrivateIpArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] address: The private IPv4 address.
        :param pulumi.Input[_builtins.str] id: (Optional) The id of the public endpoint.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The private IPv4 address.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Optional) The id of the public endpoint.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class InferenceDeploymentPublicEndpointArgsDict(TypedDict):
        disable_auth: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Disable the authentication on the endpoint.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Optional) The id of the public endpoint.
        """
        is_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable or disable public endpoint.
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Optional) The URL of the endpoint.
        """
elif False:
    InferenceDeploymentPublicEndpointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InferenceDeploymentPublicEndpointArgs:
    def __init__(__self__, *,
                 disable_auth: Optional[pulumi.Input[_builtins.bool]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 is_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] disable_auth: Disable the authentication on the endpoint.
        :param pulumi.Input[_builtins.str] id: (Optional) The id of the public endpoint.
        :param pulumi.Input[_builtins.bool] is_enabled: Enable or disable public endpoint.
        :param pulumi.Input[_builtins.str] url: (Optional) The URL of the endpoint.
        """
        if disable_auth is not None:
            pulumi.set(__self__, "disable_auth", disable_auth)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter(name="disableAuth")
    def disable_auth(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Disable the authentication on the endpoint.
        """
        return pulumi.get(self, "disable_auth")

    @disable_auth.setter
    def disable_auth(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_auth", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Optional) The id of the public endpoint.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable or disable public endpoint.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Optional) The URL of the endpoint.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class InstanceImageAdditionalVolumeArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the server containing the volume.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the image. If not provided it will be randomly generated.
        """
        server: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Description of the server containing the volume (in case the image is a backup from a server).
        """
        size: NotRequired[pulumi.Input[_builtins.int]]
        """
        The size of the volume.
        """
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of tags to apply to the image.
        """
        volume_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of volume, possible values are `l_ssd` and `sbs_snapshot`.
        """
elif False:
    InstanceImageAdditionalVolumeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceImageAdditionalVolumeArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 server: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 size: Optional[pulumi.Input[_builtins.int]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 volume_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: ID of the server containing the volume.
        :param pulumi.Input[_builtins.str] name: The name of the image. If not provided it will be randomly generated.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] server: Description of the server containing the volume (in case the image is a backup from a server).
        :param pulumi.Input[_builtins.int] size: The size of the volume.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] tags: A list of tags to apply to the image.
        :param pulumi.Input[_builtins.str] volume_type: The type of volume, possible values are `l_ssd` and `sbs_snapshot`.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if server is not None:
            pulumi.set(__self__, "server", server)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the server containing the volume.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the image. If not provided it will be randomly generated.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def server(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Description of the server containing the volume (in case the image is a backup from a server).
        """
        return pulumi.get(self, "server")

    @server.setter
    def server(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "server", value)

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The size of the volume.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "size", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of tags to apply to the image.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of volume, possible values are `l_ssd` and `sbs_snapshot`.
        """
        return pulumi.get(self, "volume_type")

    @volume_type.setter
    def volume_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "volume_type", value)


if not MYPY:
    class InstanceImageRootVolumeArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the server containing the volume.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the image. If not provided it will be randomly generated.
        """
        size: NotRequired[pulumi.Input[_builtins.int]]
        """
        The size of the volume.
        """
        volume_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of volume, possible values are `l_ssd` and `sbs_snapshot`.
        """
elif False:
    InstanceImageRootVolumeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceImageRootVolumeArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 size: Optional[pulumi.Input[_builtins.int]] = None,
                 volume_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: ID of the server containing the volume.
        :param pulumi.Input[_builtins.str] name: The name of the image. If not provided it will be randomly generated.
        :param pulumi.Input[_builtins.int] size: The size of the volume.
        :param pulumi.Input[_builtins.str] volume_type: The type of volume, possible values are `l_ssd` and `sbs_snapshot`.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the server containing the volume.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the image. If not provided it will be randomly generated.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The size of the volume.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "size", value)

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of volume, possible values are `l_ssd` and `sbs_snapshot`.
        """
        return pulumi.get(self, "volume_type")

    @volume_type.setter
    def volume_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "volume_type", value)


if not MYPY:
    class InstancePrivateNicPrivateIpArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[_builtins.str]]
        """
        The private IP address.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the IP address resource.
        """
elif False:
    InstancePrivateNicPrivateIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstancePrivateNicPrivateIpArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] address: The private IP address.
        :param pulumi.Input[_builtins.str] id: The ID of the IP address resource.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The private IP address.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the IP address resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class InstanceSecurityGroupInboundRuleArgsDict(TypedDict):
        action: pulumi.Input[_builtins.str]
        """
        The action to take when rule match. Possible values are: `accept` or `drop`.
        """
        ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ip this rule apply to. If no `ip` nor `ip_range` are specified, rule will apply to all ip. Only one of `ip` and `ip_range` should be specified.
        """
        ip_range: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ip range (e.g `192.168.1.0/24`) this rule applies to. If no `ip` nor `ip_range` are specified, rule will apply to all ip. Only one of `ip` and `ip_range` should be specified.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port this rule applies to. If no `port` nor `port_range` are specified, the rule will apply to all port. Only one of `port` and `port_range` should be specified.
        """
        port_range: NotRequired[pulumi.Input[_builtins.str]]
        """
        Computed port range for this rule (e.g: 1-1024, 22-22)
        """
        protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        The protocol this rule apply to. Possible values are: `TCP`, `UDP`, `ICMP` or `ANY`.
        """
elif False:
    InstanceSecurityGroupInboundRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceSecurityGroupInboundRuleArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[_builtins.str],
                 ip: Optional[pulumi.Input[_builtins.str]] = None,
                 ip_range: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 port_range: Optional[pulumi.Input[_builtins.str]] = None,
                 protocol: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] action: The action to take when rule match. Possible values are: `accept` or `drop`.
        :param pulumi.Input[_builtins.str] ip: The ip this rule apply to. If no `ip` nor `ip_range` are specified, rule will apply to all ip. Only one of `ip` and `ip_range` should be specified.
        :param pulumi.Input[_builtins.str] ip_range: The ip range (e.g `192.168.1.0/24`) this rule applies to. If no `ip` nor `ip_range` are specified, rule will apply to all ip. Only one of `ip` and `ip_range` should be specified.
        :param pulumi.Input[_builtins.int] port: The port this rule applies to. If no `port` nor `port_range` are specified, the rule will apply to all port. Only one of `port` and `port_range` should be specified.
        :param pulumi.Input[_builtins.str] port_range: Computed port range for this rule (e.g: 1-1024, 22-22)
        :param pulumi.Input[_builtins.str] protocol: The protocol this rule apply to. Possible values are: `TCP`, `UDP`, `ICMP` or `ANY`.
        """
        pulumi.set(__self__, "action", action)
        if ip is not None:
            warnings.warn("""Ip address is deprecated. Please use ip_range instead""", DeprecationWarning)
            pulumi.log.warn("""ip is deprecated: Ip address is deprecated. Please use ip_range instead""")
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ip_range is not None:
            pulumi.set(__self__, "ip_range", ip_range)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_range is not None:
            pulumi.set(__self__, "port_range", port_range)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter
    def action(self) -> pulumi.Input[_builtins.str]:
        """
        The action to take when rule match. Possible values are: `accept` or `drop`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""Ip address is deprecated. Please use ip_range instead""")
    def ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ip this rule apply to. If no `ip` nor `ip_range` are specified, rule will apply to all ip. Only one of `ip` and `ip_range` should be specified.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter(name="ipRange")
    def ip_range(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ip range (e.g `192.168.1.0/24`) this rule applies to. If no `ip` nor `ip_range` are specified, rule will apply to all ip. Only one of `ip` and `ip_range` should be specified.
        """
        return pulumi.get(self, "ip_range")

    @ip_range.setter
    def ip_range(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip_range", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port this rule applies to. If no `port` nor `port_range` are specified, the rule will apply to all port. Only one of `port` and `port_range` should be specified.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="portRange")
    def port_range(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Computed port range for this rule (e.g: 1-1024, 22-22)
        """
        return pulumi.get(self, "port_range")

    @port_range.setter
    def port_range(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "port_range", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The protocol this rule apply to. Possible values are: `TCP`, `UDP`, `ICMP` or `ANY`.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol", value)


if not MYPY:
    class InstanceSecurityGroupOutboundRuleArgsDict(TypedDict):
        action: pulumi.Input[_builtins.str]
        """
        Action when rule match request (drop or accept)
        """
        ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        Ip address for this rule (e.g: 1.1.1.1). Only one of ip or ip_range should be provided
        """
        ip_range: NotRequired[pulumi.Input[_builtins.str]]
        """
        Ip range for this rule (e.g: 192.168.1.0/24). Only one of ip or ip_range should be provided
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        Network port for this rule
        """
        port_range: NotRequired[pulumi.Input[_builtins.str]]
        """
        Computed port range for this rule (e.g: 1-1024, 22-22)
        """
        protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        Protocol for this rule (TCP, UDP, ICMP or ANY)
        """
elif False:
    InstanceSecurityGroupOutboundRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceSecurityGroupOutboundRuleArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[_builtins.str],
                 ip: Optional[pulumi.Input[_builtins.str]] = None,
                 ip_range: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 port_range: Optional[pulumi.Input[_builtins.str]] = None,
                 protocol: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] action: Action when rule match request (drop or accept)
        :param pulumi.Input[_builtins.str] ip: Ip address for this rule (e.g: 1.1.1.1). Only one of ip or ip_range should be provided
        :param pulumi.Input[_builtins.str] ip_range: Ip range for this rule (e.g: 192.168.1.0/24). Only one of ip or ip_range should be provided
        :param pulumi.Input[_builtins.int] port: Network port for this rule
        :param pulumi.Input[_builtins.str] port_range: Computed port range for this rule (e.g: 1-1024, 22-22)
        :param pulumi.Input[_builtins.str] protocol: Protocol for this rule (TCP, UDP, ICMP or ANY)
        """
        pulumi.set(__self__, "action", action)
        if ip is not None:
            warnings.warn("""Ip address is deprecated. Please use ip_range instead""", DeprecationWarning)
            pulumi.log.warn("""ip is deprecated: Ip address is deprecated. Please use ip_range instead""")
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ip_range is not None:
            pulumi.set(__self__, "ip_range", ip_range)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_range is not None:
            pulumi.set(__self__, "port_range", port_range)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter
    def action(self) -> pulumi.Input[_builtins.str]:
        """
        Action when rule match request (drop or accept)
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""Ip address is deprecated. Please use ip_range instead""")
    def ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Ip address for this rule (e.g: 1.1.1.1). Only one of ip or ip_range should be provided
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter(name="ipRange")
    def ip_range(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Ip range for this rule (e.g: 192.168.1.0/24). Only one of ip or ip_range should be provided
        """
        return pulumi.get(self, "ip_range")

    @ip_range.setter
    def ip_range(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip_range", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Network port for this rule
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="portRange")
    def port_range(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Computed port range for this rule (e.g: 1-1024, 22-22)
        """
        return pulumi.get(self, "port_range")

    @port_range.setter
    def port_range(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "port_range", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Protocol for this rule (TCP, UDP, ICMP or ANY)
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol", value)


if not MYPY:
    class InstanceSecurityGroupRulesInboundRuleArgsDict(TypedDict):
        action: pulumi.Input[_builtins.str]
        """
        The action to take when rule match. Possible values are: `accept` or `drop`.
        """
        ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ip this rule apply to. If no `ip` nor `ip_range` are specified, rule will apply to all ip. Only one of `ip` and `ip_range` should be specified.
        """
        ip_range: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ip range (e.g `192.168.1.0/24`) this rule applies to. If no `ip` nor `ip_range` are specified, rule will apply to all ip. Only one of `ip` and `ip_range` should be specified.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port this rule apply to. If no port is specified, rule will apply to all port.
        """
        port_range: NotRequired[pulumi.Input[_builtins.str]]
        """
        Computed port range for this rule (e.g: 1-1024, 22-22)
        """
        protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        The protocol this rule apply to. Possible values are: `TCP`, `UDP`, `ICMP` or `ANY`.
        """
elif False:
    InstanceSecurityGroupRulesInboundRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceSecurityGroupRulesInboundRuleArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[_builtins.str],
                 ip: Optional[pulumi.Input[_builtins.str]] = None,
                 ip_range: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 port_range: Optional[pulumi.Input[_builtins.str]] = None,
                 protocol: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] action: The action to take when rule match. Possible values are: `accept` or `drop`.
        :param pulumi.Input[_builtins.str] ip: The ip this rule apply to. If no `ip` nor `ip_range` are specified, rule will apply to all ip. Only one of `ip` and `ip_range` should be specified.
        :param pulumi.Input[_builtins.str] ip_range: The ip range (e.g `192.168.1.0/24`) this rule applies to. If no `ip` nor `ip_range` are specified, rule will apply to all ip. Only one of `ip` and `ip_range` should be specified.
        :param pulumi.Input[_builtins.int] port: The port this rule apply to. If no port is specified, rule will apply to all port.
        :param pulumi.Input[_builtins.str] port_range: Computed port range for this rule (e.g: 1-1024, 22-22)
        :param pulumi.Input[_builtins.str] protocol: The protocol this rule apply to. Possible values are: `TCP`, `UDP`, `ICMP` or `ANY`.
        """
        pulumi.set(__self__, "action", action)
        if ip is not None:
            warnings.warn("""Ip address is deprecated. Please use ip_range instead""", DeprecationWarning)
            pulumi.log.warn("""ip is deprecated: Ip address is deprecated. Please use ip_range instead""")
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ip_range is not None:
            pulumi.set(__self__, "ip_range", ip_range)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_range is not None:
            pulumi.set(__self__, "port_range", port_range)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter
    def action(self) -> pulumi.Input[_builtins.str]:
        """
        The action to take when rule match. Possible values are: `accept` or `drop`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""Ip address is deprecated. Please use ip_range instead""")
    def ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ip this rule apply to. If no `ip` nor `ip_range` are specified, rule will apply to all ip. Only one of `ip` and `ip_range` should be specified.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter(name="ipRange")
    def ip_range(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ip range (e.g `192.168.1.0/24`) this rule applies to. If no `ip` nor `ip_range` are specified, rule will apply to all ip. Only one of `ip` and `ip_range` should be specified.
        """
        return pulumi.get(self, "ip_range")

    @ip_range.setter
    def ip_range(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip_range", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port this rule apply to. If no port is specified, rule will apply to all port.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="portRange")
    def port_range(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Computed port range for this rule (e.g: 1-1024, 22-22)
        """
        return pulumi.get(self, "port_range")

    @port_range.setter
    def port_range(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "port_range", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The protocol this rule apply to. Possible values are: `TCP`, `UDP`, `ICMP` or `ANY`.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol", value)


if not MYPY:
    class InstanceSecurityGroupRulesOutboundRuleArgsDict(TypedDict):
        action: pulumi.Input[_builtins.str]
        """
        Action when rule match request (drop or accept)
        """
        ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        Ip address for this rule (e.g: 1.1.1.1). Only one of ip or ip_range should be provided
        """
        ip_range: NotRequired[pulumi.Input[_builtins.str]]
        """
        Ip range for this rule (e.g: 192.168.1.0/24). Only one of ip or ip_range should be provided
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        Network port for this rule
        """
        port_range: NotRequired[pulumi.Input[_builtins.str]]
        """
        Computed port range for this rule (e.g: 1-1024, 22-22)
        """
        protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        Protocol for this rule (TCP, UDP, ICMP or ANY)
        """
elif False:
    InstanceSecurityGroupRulesOutboundRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceSecurityGroupRulesOutboundRuleArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[_builtins.str],
                 ip: Optional[pulumi.Input[_builtins.str]] = None,
                 ip_range: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 port_range: Optional[pulumi.Input[_builtins.str]] = None,
                 protocol: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] action: Action when rule match request (drop or accept)
        :param pulumi.Input[_builtins.str] ip: Ip address for this rule (e.g: 1.1.1.1). Only one of ip or ip_range should be provided
        :param pulumi.Input[_builtins.str] ip_range: Ip range for this rule (e.g: 192.168.1.0/24). Only one of ip or ip_range should be provided
        :param pulumi.Input[_builtins.int] port: Network port for this rule
        :param pulumi.Input[_builtins.str] port_range: Computed port range for this rule (e.g: 1-1024, 22-22)
        :param pulumi.Input[_builtins.str] protocol: Protocol for this rule (TCP, UDP, ICMP or ANY)
        """
        pulumi.set(__self__, "action", action)
        if ip is not None:
            warnings.warn("""Ip address is deprecated. Please use ip_range instead""", DeprecationWarning)
            pulumi.log.warn("""ip is deprecated: Ip address is deprecated. Please use ip_range instead""")
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ip_range is not None:
            pulumi.set(__self__, "ip_range", ip_range)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_range is not None:
            pulumi.set(__self__, "port_range", port_range)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter
    def action(self) -> pulumi.Input[_builtins.str]:
        """
        Action when rule match request (drop or accept)
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""Ip address is deprecated. Please use ip_range instead""")
    def ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Ip address for this rule (e.g: 1.1.1.1). Only one of ip or ip_range should be provided
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter(name="ipRange")
    def ip_range(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Ip range for this rule (e.g: 192.168.1.0/24). Only one of ip or ip_range should be provided
        """
        return pulumi.get(self, "ip_range")

    @ip_range.setter
    def ip_range(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip_range", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Network port for this rule
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="portRange")
    def port_range(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Computed port range for this rule (e.g: 1-1024, 22-22)
        """
        return pulumi.get(self, "port_range")

    @port_range.setter
    def port_range(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "port_range", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Protocol for this rule (TCP, UDP, ICMP or ANY)
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol", value)


if not MYPY:
    class InstanceServerFilesystemArgsDict(TypedDict):
        filesystem_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The unique ID of the filesystem attached to the server.
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        The state of the filesystem
        """
elif False:
    InstanceServerFilesystemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceServerFilesystemArgs:
    def __init__(__self__, *,
                 filesystem_id: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] filesystem_id: The unique ID of the filesystem attached to the server.
        :param pulumi.Input[_builtins.str] status: The state of the filesystem
        """
        if filesystem_id is not None:
            pulumi.set(__self__, "filesystem_id", filesystem_id)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="filesystemId")
    def filesystem_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The unique ID of the filesystem attached to the server.
        """
        return pulumi.get(self, "filesystem_id")

    @filesystem_id.setter
    def filesystem_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "filesystem_id", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The state of the filesystem
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class InstanceServerPrivateIpArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[_builtins.str]]
        """
        The private IP address.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the IP address resource.
        """
elif False:
    InstanceServerPrivateIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceServerPrivateIpArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] address: The private IP address.
        :param pulumi.Input[_builtins.str] id: The ID of the IP address resource.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The private IP address.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the IP address resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class InstanceServerPrivateNetworkArgsDict(TypedDict):
        pn_id: pulumi.Input[_builtins.str]
        """
        The Private Network ID
        """
        mac_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        MAC address of the NIC
        """
        pnic_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the NIC
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        The private NIC state
        """
        zone: NotRequired[pulumi.Input[_builtins.str]]
        """
        `zone`) The zone in which the server should be created.
        """
elif False:
    InstanceServerPrivateNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceServerPrivateNetworkArgs:
    def __init__(__self__, *,
                 pn_id: pulumi.Input[_builtins.str],
                 mac_address: Optional[pulumi.Input[_builtins.str]] = None,
                 pnic_id: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 zone: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] pn_id: The Private Network ID
        :param pulumi.Input[_builtins.str] mac_address: MAC address of the NIC
        :param pulumi.Input[_builtins.str] pnic_id: The ID of the NIC
        :param pulumi.Input[_builtins.str] status: The private NIC state
        :param pulumi.Input[_builtins.str] zone: `zone`) The zone in which the server should be created.
        """
        pulumi.set(__self__, "pn_id", pn_id)
        if mac_address is not None:
            pulumi.set(__self__, "mac_address", mac_address)
        if pnic_id is not None:
            pulumi.set(__self__, "pnic_id", pnic_id)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if zone is not None:
            pulumi.set(__self__, "zone", zone)

    @_builtins.property
    @pulumi.getter(name="pnId")
    def pn_id(self) -> pulumi.Input[_builtins.str]:
        """
        The Private Network ID
        """
        return pulumi.get(self, "pn_id")

    @pn_id.setter
    def pn_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "pn_id", value)

    @_builtins.property
    @pulumi.getter(name="macAddress")
    def mac_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        MAC address of the NIC
        """
        return pulumi.get(self, "mac_address")

    @mac_address.setter
    def mac_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mac_address", value)

    @_builtins.property
    @pulumi.getter(name="pnicId")
    def pnic_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the NIC
        """
        return pulumi.get(self, "pnic_id")

    @pnic_id.setter
    def pnic_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "pnic_id", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The private NIC state
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter
    def zone(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        `zone`) The zone in which the server should be created.
        """
        return pulumi.get(self, "zone")

    @zone.setter
    def zone(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "zone", value)


if not MYPY:
    class InstanceServerPublicIpArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[_builtins.str]]
        """
        The address of the IP.
        """
        dynamic: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the IP is dynamic.
        """
        family: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IP address' family.
        """
        gateway: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IP of the Gateway associated with the IP.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the IP.
        """
        netmask: NotRequired[pulumi.Input[_builtins.str]]
        """
        The CIDR netmask of the IP.
        """
        provisioning_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        The provisioning mode of the IP
        """
elif False:
    InstanceServerPublicIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceServerPublicIpArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[_builtins.str]] = None,
                 dynamic: Optional[pulumi.Input[_builtins.bool]] = None,
                 family: Optional[pulumi.Input[_builtins.str]] = None,
                 gateway: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 netmask: Optional[pulumi.Input[_builtins.str]] = None,
                 provisioning_mode: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] address: The address of the IP.
        :param pulumi.Input[_builtins.bool] dynamic: Whether the IP is dynamic.
        :param pulumi.Input[_builtins.str] family: The IP address' family.
        :param pulumi.Input[_builtins.str] gateway: The IP of the Gateway associated with the IP.
        :param pulumi.Input[_builtins.str] id: The ID of the IP.
        :param pulumi.Input[_builtins.str] netmask: The CIDR netmask of the IP.
        :param pulumi.Input[_builtins.str] provisioning_mode: The provisioning mode of the IP
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if dynamic is not None:
            pulumi.set(__self__, "dynamic", dynamic)
        if family is not None:
            pulumi.set(__self__, "family", family)
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if netmask is not None:
            pulumi.set(__self__, "netmask", netmask)
        if provisioning_mode is not None:
            pulumi.set(__self__, "provisioning_mode", provisioning_mode)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The address of the IP.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter
    def dynamic(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the IP is dynamic.
        """
        return pulumi.get(self, "dynamic")

    @dynamic.setter
    def dynamic(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "dynamic", value)

    @_builtins.property
    @pulumi.getter
    def family(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IP address' family.
        """
        return pulumi.get(self, "family")

    @family.setter
    def family(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "family", value)

    @_builtins.property
    @pulumi.getter
    def gateway(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IP of the Gateway associated with the IP.
        """
        return pulumi.get(self, "gateway")

    @gateway.setter
    def gateway(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "gateway", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the IP.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def netmask(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The CIDR netmask of the IP.
        """
        return pulumi.get(self, "netmask")

    @netmask.setter
    def netmask(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "netmask", value)

    @_builtins.property
    @pulumi.getter(name="provisioningMode")
    def provisioning_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The provisioning mode of the IP
        """
        return pulumi.get(self, "provisioning_mode")

    @provisioning_mode.setter
    def provisioning_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "provisioning_mode", value)


if not MYPY:
    class InstanceServerRootVolumeArgsDict(TypedDict):
        boot: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Set the volume where the boot the server
        """
        delete_on_termination: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Forces deletion of the root volume on instance termination.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the root volume.
        """
        sbs_iops: NotRequired[pulumi.Input[_builtins.int]]
        """
        Choose IOPS of your sbs volume, has to be used with `sbs_volume` for root volume type.

        > **Important:** It is not possible to change `root_volume.size_in_gb` for local volumes (`l_ssd`). Changes to this field will recreate the server.
        It is possible to increase `root_volume.size_in_gb` for SBS volumes, but they cannot be resized down without recreating the server.
        """
        size_in_gb: NotRequired[pulumi.Input[_builtins.int]]
        """
        Size of the root volume in gigabytes.
        To find the right size use [this endpoint](https://www.scaleway.com/en/developers/api/instance/#path-instances-list-all-instances) and
        check the `volumes_constraint.{min|max}_size` (in bytes) for your `commercial_type`.
        Depending on `volume_type`, updates to this field may recreate a new resource.
        """
        volume_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The volume ID of the root volume of the server, allows you to create server with an existing volume. If empty, will be computed to a created volume ID.
        """
        volume_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Volume type of root volume, can be `l_ssd` or `sbs_volume`, default value depends on server type
        """
elif False:
    InstanceServerRootVolumeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceServerRootVolumeArgs:
    def __init__(__self__, *,
                 boot: Optional[pulumi.Input[_builtins.bool]] = None,
                 delete_on_termination: Optional[pulumi.Input[_builtins.bool]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 sbs_iops: Optional[pulumi.Input[_builtins.int]] = None,
                 size_in_gb: Optional[pulumi.Input[_builtins.int]] = None,
                 volume_id: Optional[pulumi.Input[_builtins.str]] = None,
                 volume_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] boot: Set the volume where the boot the server
        :param pulumi.Input[_builtins.bool] delete_on_termination: Forces deletion of the root volume on instance termination.
        :param pulumi.Input[_builtins.str] name: Name of the root volume.
        :param pulumi.Input[_builtins.int] sbs_iops: Choose IOPS of your sbs volume, has to be used with `sbs_volume` for root volume type.
               
               > **Important:** It is not possible to change `root_volume.size_in_gb` for local volumes (`l_ssd`). Changes to this field will recreate the server.
               It is possible to increase `root_volume.size_in_gb` for SBS volumes, but they cannot be resized down without recreating the server.
        :param pulumi.Input[_builtins.int] size_in_gb: Size of the root volume in gigabytes.
               To find the right size use [this endpoint](https://www.scaleway.com/en/developers/api/instance/#path-instances-list-all-instances) and
               check the `volumes_constraint.{min|max}_size` (in bytes) for your `commercial_type`.
               Depending on `volume_type`, updates to this field may recreate a new resource.
        :param pulumi.Input[_builtins.str] volume_id: The volume ID of the root volume of the server, allows you to create server with an existing volume. If empty, will be computed to a created volume ID.
        :param pulumi.Input[_builtins.str] volume_type: Volume type of root volume, can be `l_ssd` or `sbs_volume`, default value depends on server type
        """
        if boot is not None:
            pulumi.set(__self__, "boot", boot)
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if sbs_iops is not None:
            pulumi.set(__self__, "sbs_iops", sbs_iops)
        if size_in_gb is not None:
            pulumi.set(__self__, "size_in_gb", size_in_gb)
        if volume_id is not None:
            pulumi.set(__self__, "volume_id", volume_id)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter
    def boot(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Set the volume where the boot the server
        """
        return pulumi.get(self, "boot")

    @boot.setter
    def boot(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "boot", value)

    @_builtins.property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Forces deletion of the root volume on instance termination.
        """
        return pulumi.get(self, "delete_on_termination")

    @delete_on_termination.setter
    def delete_on_termination(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "delete_on_termination", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the root volume.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="sbsIops")
    def sbs_iops(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Choose IOPS of your sbs volume, has to be used with `sbs_volume` for root volume type.

        > **Important:** It is not possible to change `root_volume.size_in_gb` for local volumes (`l_ssd`). Changes to this field will recreate the server.
        It is possible to increase `root_volume.size_in_gb` for SBS volumes, but they cannot be resized down without recreating the server.
        """
        return pulumi.get(self, "sbs_iops")

    @sbs_iops.setter
    def sbs_iops(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "sbs_iops", value)

    @_builtins.property
    @pulumi.getter(name="sizeInGb")
    def size_in_gb(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Size of the root volume in gigabytes.
        To find the right size use [this endpoint](https://www.scaleway.com/en/developers/api/instance/#path-instances-list-all-instances) and
        check the `volumes_constraint.{min|max}_size` (in bytes) for your `commercial_type`.
        Depending on `volume_type`, updates to this field may recreate a new resource.
        """
        return pulumi.get(self, "size_in_gb")

    @size_in_gb.setter
    def size_in_gb(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "size_in_gb", value)

    @_builtins.property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The volume ID of the root volume of the server, allows you to create server with an existing volume. If empty, will be computed to a created volume ID.
        """
        return pulumi.get(self, "volume_id")

    @volume_id.setter
    def volume_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "volume_id", value)

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Volume type of root volume, can be `l_ssd` or `sbs_volume`, default value depends on server type
        """
        return pulumi.get(self, "volume_type")

    @volume_type.setter
    def volume_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "volume_type", value)


if not MYPY:
    class InstanceSnapshotImportArgsDict(TypedDict):
        bucket: pulumi.Input[_builtins.str]
        """
        Bucket name containing [qcow2](https://en.wikipedia.org/wiki/Qcow) to import
        """
        key: pulumi.Input[_builtins.str]
        """
        Key of the object to import
        """
elif False:
    InstanceSnapshotImportArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceSnapshotImportArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[_builtins.str],
                 key: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] bucket: Bucket name containing [qcow2](https://en.wikipedia.org/wiki/Qcow) to import
        :param pulumi.Input[_builtins.str] key: Key of the object to import
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "key", key)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[_builtins.str]:
        """
        Bucket name containing [qcow2](https://en.wikipedia.org/wiki/Qcow) to import
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        Key of the object to import
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)


if not MYPY:
    class IotDeviceCertificateArgsDict(TypedDict):
        crt: NotRequired[pulumi.Input[_builtins.str]]
        """
        X509 PEM encoded certificate of the device
        """
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The private key of the device, in case it is generated by Scaleway.
        """
elif False:
    IotDeviceCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IotDeviceCertificateArgs:
    def __init__(__self__, *,
                 crt: Optional[pulumi.Input[_builtins.str]] = None,
                 key: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] crt: X509 PEM encoded certificate of the device
        :param pulumi.Input[_builtins.str] key: The private key of the device, in case it is generated by Scaleway.
        """
        if crt is not None:
            pulumi.set(__self__, "crt", crt)
        if key is not None:
            pulumi.set(__self__, "key", key)

    @_builtins.property
    @pulumi.getter
    def crt(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        X509 PEM encoded certificate of the device
        """
        return pulumi.get(self, "crt")

    @crt.setter
    def crt(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "crt", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The private key of the device, in case it is generated by Scaleway.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)


if not MYPY:
    class IotDeviceMessageFiltersArgsDict(TypedDict):
        publish: NotRequired[pulumi.Input['IotDeviceMessageFiltersPublishArgsDict']]
        """
        Rules used to restrict topics the device can publish to.
        """
        subscribe: NotRequired[pulumi.Input['IotDeviceMessageFiltersSubscribeArgsDict']]
        """
        Rules used to restrict topics the device can subscribe to.
        """
elif False:
    IotDeviceMessageFiltersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IotDeviceMessageFiltersArgs:
    def __init__(__self__, *,
                 publish: Optional[pulumi.Input['IotDeviceMessageFiltersPublishArgs']] = None,
                 subscribe: Optional[pulumi.Input['IotDeviceMessageFiltersSubscribeArgs']] = None):
        """
        :param pulumi.Input['IotDeviceMessageFiltersPublishArgs'] publish: Rules used to restrict topics the device can publish to.
        :param pulumi.Input['IotDeviceMessageFiltersSubscribeArgs'] subscribe: Rules used to restrict topics the device can subscribe to.
        """
        if publish is not None:
            pulumi.set(__self__, "publish", publish)
        if subscribe is not None:
            pulumi.set(__self__, "subscribe", subscribe)

    @_builtins.property
    @pulumi.getter
    def publish(self) -> Optional[pulumi.Input['IotDeviceMessageFiltersPublishArgs']]:
        """
        Rules used to restrict topics the device can publish to.
        """
        return pulumi.get(self, "publish")

    @publish.setter
    def publish(self, value: Optional[pulumi.Input['IotDeviceMessageFiltersPublishArgs']]):
        pulumi.set(self, "publish", value)

    @_builtins.property
    @pulumi.getter
    def subscribe(self) -> Optional[pulumi.Input['IotDeviceMessageFiltersSubscribeArgs']]:
        """
        Rules used to restrict topics the device can subscribe to.
        """
        return pulumi.get(self, "subscribe")

    @subscribe.setter
    def subscribe(self, value: Optional[pulumi.Input['IotDeviceMessageFiltersSubscribeArgs']]):
        pulumi.set(self, "subscribe", value)


if not MYPY:
    class IotDeviceMessageFiltersPublishArgsDict(TypedDict):
        policy: NotRequired[pulumi.Input[_builtins.str]]
        """
        Filtering policy (eg `accept` or `reject`)
        """
        topics: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of topics to match (eg `foo/bar/+/baz/#`)
        """
elif False:
    IotDeviceMessageFiltersPublishArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IotDeviceMessageFiltersPublishArgs:
    def __init__(__self__, *,
                 policy: Optional[pulumi.Input[_builtins.str]] = None,
                 topics: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] policy: Filtering policy (eg `accept` or `reject`)
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] topics: List of topics to match (eg `foo/bar/+/baz/#`)
        """
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if topics is not None:
            pulumi.set(__self__, "topics", topics)

    @_builtins.property
    @pulumi.getter
    def policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Filtering policy (eg `accept` or `reject`)
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "policy", value)

    @_builtins.property
    @pulumi.getter
    def topics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of topics to match (eg `foo/bar/+/baz/#`)
        """
        return pulumi.get(self, "topics")

    @topics.setter
    def topics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "topics", value)


if not MYPY:
    class IotDeviceMessageFiltersSubscribeArgsDict(TypedDict):
        policy: NotRequired[pulumi.Input[_builtins.str]]
        """
        Same as publish rules.
        """
        topics: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Same as publish rules.

        - `certificate.crt` - (Optional) The certificate of the device, either generated by Scaleway or provided.

        > **Important:** Updates to `certificate.crt` will disconnect connected devices and the previous certificate will be deleted and won't be recoverable.
        """
elif False:
    IotDeviceMessageFiltersSubscribeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IotDeviceMessageFiltersSubscribeArgs:
    def __init__(__self__, *,
                 policy: Optional[pulumi.Input[_builtins.str]] = None,
                 topics: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] policy: Same as publish rules.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] topics: Same as publish rules.
               
               - `certificate.crt` - (Optional) The certificate of the device, either generated by Scaleway or provided.
               
               > **Important:** Updates to `certificate.crt` will disconnect connected devices and the previous certificate will be deleted and won't be recoverable.
        """
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if topics is not None:
            pulumi.set(__self__, "topics", topics)

    @_builtins.property
    @pulumi.getter
    def policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Same as publish rules.
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "policy", value)

    @_builtins.property
    @pulumi.getter
    def topics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Same as publish rules.

        - `certificate.crt` - (Optional) The certificate of the device, either generated by Scaleway or provided.

        > **Important:** Updates to `certificate.crt` will disconnect connected devices and the previous certificate will be deleted and won't be recoverable.
        """
        return pulumi.get(self, "topics")

    @topics.setter
    def topics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "topics", value)


if not MYPY:
    class IotRouteDatabaseArgsDict(TypedDict):
        dbname: pulumi.Input[_builtins.str]
        """
        The database name (e.g. `measurements`).
        """
        host: pulumi.Input[_builtins.str]
        """
        The database hostname. Can be an IP or a FQDN.
        """
        password: pulumi.Input[_builtins.str]
        """
        The database password.
        """
        port: pulumi.Input[_builtins.int]
        """
        The database port (e.g. `5432`)
        """
        query: pulumi.Input[_builtins.str]
        """
        The SQL query that will be executed when receiving a message ($TOPIC and $PAYLOAD variables are available, see documentation, e.g. `INSERT INTO mytable(date, topic, value) VALUES (NOW(), $TOPIC, $PAYLOAD)`).
        """
        username: pulumi.Input[_builtins.str]
        """
        The database username.
        """
elif False:
    IotRouteDatabaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IotRouteDatabaseArgs:
    def __init__(__self__, *,
                 dbname: pulumi.Input[_builtins.str],
                 host: pulumi.Input[_builtins.str],
                 password: pulumi.Input[_builtins.str],
                 port: pulumi.Input[_builtins.int],
                 query: pulumi.Input[_builtins.str],
                 username: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] dbname: The database name (e.g. `measurements`).
        :param pulumi.Input[_builtins.str] host: The database hostname. Can be an IP or a FQDN.
        :param pulumi.Input[_builtins.str] password: The database password.
        :param pulumi.Input[_builtins.int] port: The database port (e.g. `5432`)
        :param pulumi.Input[_builtins.str] query: The SQL query that will be executed when receiving a message ($TOPIC and $PAYLOAD variables are available, see documentation, e.g. `INSERT INTO mytable(date, topic, value) VALUES (NOW(), $TOPIC, $PAYLOAD)`).
        :param pulumi.Input[_builtins.str] username: The database username.
        """
        pulumi.set(__self__, "dbname", dbname)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "query", query)
        pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def dbname(self) -> pulumi.Input[_builtins.str]:
        """
        The database name (e.g. `measurements`).
        """
        return pulumi.get(self, "dbname")

    @dbname.setter
    def dbname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "dbname", value)

    @_builtins.property
    @pulumi.getter
    def host(self) -> pulumi.Input[_builtins.str]:
        """
        The database hostname. Can be an IP or a FQDN.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> pulumi.Input[_builtins.str]:
        """
        The database password.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.int]:
        """
        The database port (e.g. `5432`)
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def query(self) -> pulumi.Input[_builtins.str]:
        """
        The SQL query that will be executed when receiving a message ($TOPIC and $PAYLOAD variables are available, see documentation, e.g. `INSERT INTO mytable(date, topic, value) VALUES (NOW(), $TOPIC, $PAYLOAD)`).
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "query", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> pulumi.Input[_builtins.str]:
        """
        The database username.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "username", value)


if not MYPY:
    class IotRouteRestArgsDict(TypedDict):
        headers: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]
        """
        a map of the extra headers to send with the HTTP call (e.g. `X-Header = Value`).
        """
        uri: pulumi.Input[_builtins.str]
        """
        The URI of the Rest endpoint (e.g. `https://internal.mycompany.com/ingest/mqttdata`).
        """
        verb: pulumi.Input[_builtins.str]
        """
        The HTTP Verb used to call Rest URI (e.g. `post`).
        """
elif False:
    IotRouteRestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IotRouteRestArgs:
    def __init__(__self__, *,
                 headers: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]],
                 uri: pulumi.Input[_builtins.str],
                 verb: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] headers: a map of the extra headers to send with the HTTP call (e.g. `X-Header = Value`).
        :param pulumi.Input[_builtins.str] uri: The URI of the Rest endpoint (e.g. `https://internal.mycompany.com/ingest/mqttdata`).
        :param pulumi.Input[_builtins.str] verb: The HTTP Verb used to call Rest URI (e.g. `post`).
        """
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "uri", uri)
        pulumi.set(__self__, "verb", verb)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]:
        """
        a map of the extra headers to send with the HTTP call (e.g. `X-Header = Value`).
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter
    def uri(self) -> pulumi.Input[_builtins.str]:
        """
        The URI of the Rest endpoint (e.g. `https://internal.mycompany.com/ingest/mqttdata`).
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "uri", value)

    @_builtins.property
    @pulumi.getter
    def verb(self) -> pulumi.Input[_builtins.str]:
        """
        The HTTP Verb used to call Rest URI (e.g. `post`).
        """
        return pulumi.get(self, "verb")

    @verb.setter
    def verb(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "verb", value)


if not MYPY:
    class IotRouteS3ArgsDict(TypedDict):
        bucket_name: pulumi.Input[_builtins.str]
        """
        The name of the S3 route's destination bucket (e.g. `my-object-storage`).
        """
        bucket_region: pulumi.Input[_builtins.str]
        """
        The region of the S3 route's destination bucket (e.g. `fr-par`).
        """
        strategy: pulumi.Input[_builtins.str]
        """
        How the S3 route's objects will be created (e.g. `per_topic`). See [documentation](https://www.scaleway.com/en/docs/iot-hub/how-to/create-route/) for behaviour details.
        """
        object_prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        The string to prefix object names with (e.g. `mykeyprefix-`).
        """
elif False:
    IotRouteS3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IotRouteS3Args:
    def __init__(__self__, *,
                 bucket_name: pulumi.Input[_builtins.str],
                 bucket_region: pulumi.Input[_builtins.str],
                 strategy: pulumi.Input[_builtins.str],
                 object_prefix: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] bucket_name: The name of the S3 route's destination bucket (e.g. `my-object-storage`).
        :param pulumi.Input[_builtins.str] bucket_region: The region of the S3 route's destination bucket (e.g. `fr-par`).
        :param pulumi.Input[_builtins.str] strategy: How the S3 route's objects will be created (e.g. `per_topic`). See [documentation](https://www.scaleway.com/en/docs/iot-hub/how-to/create-route/) for behaviour details.
        :param pulumi.Input[_builtins.str] object_prefix: The string to prefix object names with (e.g. `mykeyprefix-`).
        """
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "bucket_region", bucket_region)
        pulumi.set(__self__, "strategy", strategy)
        if object_prefix is not None:
            pulumi.set(__self__, "object_prefix", object_prefix)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the S3 route's destination bucket (e.g. `my-object-storage`).
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket_name", value)

    @_builtins.property
    @pulumi.getter(name="bucketRegion")
    def bucket_region(self) -> pulumi.Input[_builtins.str]:
        """
        The region of the S3 route's destination bucket (e.g. `fr-par`).
        """
        return pulumi.get(self, "bucket_region")

    @bucket_region.setter
    def bucket_region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket_region", value)

    @_builtins.property
    @pulumi.getter
    def strategy(self) -> pulumi.Input[_builtins.str]:
        """
        How the S3 route's objects will be created (e.g. `per_topic`). See [documentation](https://www.scaleway.com/en/docs/iot-hub/how-to/create-route/) for behaviour details.
        """
        return pulumi.get(self, "strategy")

    @strategy.setter
    def strategy(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "strategy", value)

    @_builtins.property
    @pulumi.getter(name="objectPrefix")
    def object_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The string to prefix object names with (e.g. `mykeyprefix-`).
        """
        return pulumi.get(self, "object_prefix")

    @object_prefix.setter
    def object_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "object_prefix", value)


if not MYPY:
    class IpamIpCustomResourceArgsDict(TypedDict):
        mac_address: pulumi.Input[_builtins.str]
        """
        The MAC address of the custom resource.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        When the resource is in a Private Network, a DNS record is available to resolve the resource name.
        """
elif False:
    IpamIpCustomResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IpamIpCustomResourceArgs:
    def __init__(__self__, *,
                 mac_address: pulumi.Input[_builtins.str],
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] mac_address: The MAC address of the custom resource.
        :param pulumi.Input[_builtins.str] name: When the resource is in a Private Network, a DNS record is available to resolve the resource name.
        """
        pulumi.set(__self__, "mac_address", mac_address)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="macAddress")
    def mac_address(self) -> pulumi.Input[_builtins.str]:
        """
        The MAC address of the custom resource.
        """
        return pulumi.get(self, "mac_address")

    @mac_address.setter
    def mac_address(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "mac_address", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        When the resource is in a Private Network, a DNS record is available to resolve the resource name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class IpamIpResourceArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the resource that the IP is attached to.
        """
        mac_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        The MAC address of the resource the IP is attached to.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the resource the IP is attached to.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of resource the IP is attached to.
        """
elif False:
    IpamIpResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IpamIpResourceArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 mac_address: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the resource that the IP is attached to.
        :param pulumi.Input[_builtins.str] mac_address: The MAC address of the resource the IP is attached to.
        :param pulumi.Input[_builtins.str] name: The name of the resource the IP is attached to.
        :param pulumi.Input[_builtins.str] type: The type of resource the IP is attached to.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if mac_address is not None:
            pulumi.set(__self__, "mac_address", mac_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the resource that the IP is attached to.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="macAddress")
    def mac_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The MAC address of the resource the IP is attached to.
        """
        return pulumi.get(self, "mac_address")

    @mac_address.setter
    def mac_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mac_address", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the resource the IP is attached to.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of resource the IP is attached to.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class IpamIpReverseArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IP corresponding to the hostname
        """
        hostname: NotRequired[pulumi.Input[_builtins.str]]
        """
        The reverse domain name.
        """
elif False:
    IpamIpReverseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IpamIpReverseArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[_builtins.str]] = None,
                 hostname: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] address: The IP corresponding to the hostname
        :param pulumi.Input[_builtins.str] hostname: The reverse domain name.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IP corresponding to the hostname
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The reverse domain name.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "hostname", value)


if not MYPY:
    class IpamIpSourceArgsDict(TypedDict):
        private_network_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Private Network of the IP (if the IP is a private IP).
        """
        subnet_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Private Network subnet of the IP (if the IP is a private IP).
        """
        zonal: NotRequired[pulumi.Input[_builtins.str]]
        """
        The zone of the IP (if the IP is public and zoned, rather than private and/or regional)
        """
elif False:
    IpamIpSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IpamIpSourceArgs:
    def __init__(__self__, *,
                 private_network_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subnet_id: Optional[pulumi.Input[_builtins.str]] = None,
                 zonal: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] private_network_id: The Private Network of the IP (if the IP is a private IP).
        :param pulumi.Input[_builtins.str] subnet_id: The Private Network subnet of the IP (if the IP is a private IP).
        :param pulumi.Input[_builtins.str] zonal: The zone of the IP (if the IP is public and zoned, rather than private and/or regional)
        """
        if private_network_id is not None:
            pulumi.set(__self__, "private_network_id", private_network_id)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if zonal is not None:
            pulumi.set(__self__, "zonal", zonal)

    @_builtins.property
    @pulumi.getter(name="privateNetworkId")
    def private_network_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Private Network of the IP (if the IP is a private IP).
        """
        return pulumi.get(self, "private_network_id")

    @private_network_id.setter
    def private_network_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "private_network_id", value)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Private Network subnet of the IP (if the IP is a private IP).
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subnet_id", value)

    @_builtins.property
    @pulumi.getter
    def zonal(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The zone of the IP (if the IP is public and zoned, rather than private and/or regional)
        """
        return pulumi.get(self, "zonal")

    @zonal.setter
    def zonal(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "zonal", value)


if not MYPY:
    class JobDefinitionCronArgsDict(TypedDict):
        schedule: pulumi.Input[_builtins.str]
        """
        Cron format string.
        """
        timezone: pulumi.Input[_builtins.str]
        """
        The timezone, must be a canonical TZ identifier as found in this [list](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones).
        """
elif False:
    JobDefinitionCronArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobDefinitionCronArgs:
    def __init__(__self__, *,
                 schedule: pulumi.Input[_builtins.str],
                 timezone: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] schedule: Cron format string.
        :param pulumi.Input[_builtins.str] timezone: The timezone, must be a canonical TZ identifier as found in this [list](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones).
        """
        pulumi.set(__self__, "schedule", schedule)
        pulumi.set(__self__, "timezone", timezone)

    @_builtins.property
    @pulumi.getter
    def schedule(self) -> pulumi.Input[_builtins.str]:
        """
        Cron format string.
        """
        return pulumi.get(self, "schedule")

    @schedule.setter
    def schedule(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "schedule", value)

    @_builtins.property
    @pulumi.getter
    def timezone(self) -> pulumi.Input[_builtins.str]:
        """
        The timezone, must be a canonical TZ identifier as found in this [list](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones).
        """
        return pulumi.get(self, "timezone")

    @timezone.setter
    def timezone(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "timezone", value)


if not MYPY:
    class JobDefinitionSecretReferenceArgsDict(TypedDict):
        secret_id: pulumi.Input[_builtins.str]
        """
        The secret unique identifier, it could be formatted as region/UUID or UUID. In case the region is passed, it must be the same as the job definition. You could reference the same secret multiple times in the same job definition.
        """
        environment: NotRequired[pulumi.Input[_builtins.str]]
        """
        An environment variable containing the secret value. Must be specified if `file` is not specified.
        """
        file: NotRequired[pulumi.Input[_builtins.str]]
        """
        The absolute file path where the secret will be mounted. Must be specified if `environment` is not specified.
        """
        secret_reference_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The secret reference UUID that is automatically generated by the provider.
        """
        secret_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        The secret version.
        """
elif False:
    JobDefinitionSecretReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobDefinitionSecretReferenceArgs:
    def __init__(__self__, *,
                 secret_id: pulumi.Input[_builtins.str],
                 environment: Optional[pulumi.Input[_builtins.str]] = None,
                 file: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_reference_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_version: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] secret_id: The secret unique identifier, it could be formatted as region/UUID or UUID. In case the region is passed, it must be the same as the job definition. You could reference the same secret multiple times in the same job definition.
        :param pulumi.Input[_builtins.str] environment: An environment variable containing the secret value. Must be specified if `file` is not specified.
        :param pulumi.Input[_builtins.str] file: The absolute file path where the secret will be mounted. Must be specified if `environment` is not specified.
        :param pulumi.Input[_builtins.str] secret_reference_id: The secret reference UUID that is automatically generated by the provider.
        :param pulumi.Input[_builtins.str] secret_version: The secret version.
        """
        pulumi.set(__self__, "secret_id", secret_id)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if secret_reference_id is not None:
            pulumi.set(__self__, "secret_reference_id", secret_reference_id)
        if secret_version is not None:
            pulumi.set(__self__, "secret_version", secret_version)

    @_builtins.property
    @pulumi.getter(name="secretId")
    def secret_id(self) -> pulumi.Input[_builtins.str]:
        """
        The secret unique identifier, it could be formatted as region/UUID or UUID. In case the region is passed, it must be the same as the job definition. You could reference the same secret multiple times in the same job definition.
        """
        return pulumi.get(self, "secret_id")

    @secret_id.setter
    def secret_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret_id", value)

    @_builtins.property
    @pulumi.getter
    def environment(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An environment variable containing the secret value. Must be specified if `file` is not specified.
        """
        return pulumi.get(self, "environment")

    @environment.setter
    def environment(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "environment", value)

    @_builtins.property
    @pulumi.getter
    def file(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The absolute file path where the secret will be mounted. Must be specified if `environment` is not specified.
        """
        return pulumi.get(self, "file")

    @file.setter
    def file(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "file", value)

    @_builtins.property
    @pulumi.getter(name="secretReferenceId")
    def secret_reference_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The secret reference UUID that is automatically generated by the provider.
        """
        return pulumi.get(self, "secret_reference_id")

    @secret_reference_id.setter
    def secret_reference_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_reference_id", value)

    @_builtins.property
    @pulumi.getter(name="secretVersion")
    def secret_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The secret version.
        """
        return pulumi.get(self, "secret_version")

    @secret_version.setter
    def secret_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_version", value)


if not MYPY:
    class KeyManagerKeyRotationPolicyArgsDict(TypedDict):
        rotation_period: pulumi.Input[_builtins.str]
        """
         The period between key rotations (e.g., `"720h"` for 30 days).
        """
        next_rotation_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        The date and time of the next scheduled rotation.
        """
elif False:
    KeyManagerKeyRotationPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KeyManagerKeyRotationPolicyArgs:
    def __init__(__self__, *,
                 rotation_period: pulumi.Input[_builtins.str],
                 next_rotation_at: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] rotation_period:  The period between key rotations (e.g., `"720h"` for 30 days).
        :param pulumi.Input[_builtins.str] next_rotation_at: The date and time of the next scheduled rotation.
        """
        pulumi.set(__self__, "rotation_period", rotation_period)
        if next_rotation_at is not None:
            pulumi.set(__self__, "next_rotation_at", next_rotation_at)

    @_builtins.property
    @pulumi.getter(name="rotationPeriod")
    def rotation_period(self) -> pulumi.Input[_builtins.str]:
        """
         The period between key rotations (e.g., `"720h"` for 30 days).
        """
        return pulumi.get(self, "rotation_period")

    @rotation_period.setter
    def rotation_period(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "rotation_period", value)

    @_builtins.property
    @pulumi.getter(name="nextRotationAt")
    def next_rotation_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The date and time of the next scheduled rotation.
        """
        return pulumi.get(self, "next_rotation_at")

    @next_rotation_at.setter
    def next_rotation_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "next_rotation_at", value)


if not MYPY:
    class KubernetesClusterAutoUpgradeArgsDict(TypedDict):
        enable: pulumi.Input[_builtins.bool]
        """
        Set to `true` to enable Kubernetes patch version auto upgrades.
        > **Important:** When enabling auto upgrades, the `version` field take a minor version like x.y (ie 1.18).
        """
        maintenance_window_day: pulumi.Input[_builtins.str]
        """
        The day of the auto upgrade maintenance window (`monday` to `sunday`, or `any`).
        """
        maintenance_window_start_hour: pulumi.Input[_builtins.int]
        """
        The start hour (UTC) of the 2-hour auto upgrade maintenance window (0 to 23).
        """
elif False:
    KubernetesClusterAutoUpgradeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesClusterAutoUpgradeArgs:
    def __init__(__self__, *,
                 enable: pulumi.Input[_builtins.bool],
                 maintenance_window_day: pulumi.Input[_builtins.str],
                 maintenance_window_start_hour: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.bool] enable: Set to `true` to enable Kubernetes patch version auto upgrades.
               > **Important:** When enabling auto upgrades, the `version` field take a minor version like x.y (ie 1.18).
        :param pulumi.Input[_builtins.str] maintenance_window_day: The day of the auto upgrade maintenance window (`monday` to `sunday`, or `any`).
        :param pulumi.Input[_builtins.int] maintenance_window_start_hour: The start hour (UTC) of the 2-hour auto upgrade maintenance window (0 to 23).
        """
        pulumi.set(__self__, "enable", enable)
        pulumi.set(__self__, "maintenance_window_day", maintenance_window_day)
        pulumi.set(__self__, "maintenance_window_start_hour", maintenance_window_start_hour)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> pulumi.Input[_builtins.bool]:
        """
        Set to `true` to enable Kubernetes patch version auto upgrades.
        > **Important:** When enabling auto upgrades, the `version` field take a minor version like x.y (ie 1.18).
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter(name="maintenanceWindowDay")
    def maintenance_window_day(self) -> pulumi.Input[_builtins.str]:
        """
        The day of the auto upgrade maintenance window (`monday` to `sunday`, or `any`).
        """
        return pulumi.get(self, "maintenance_window_day")

    @maintenance_window_day.setter
    def maintenance_window_day(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "maintenance_window_day", value)

    @_builtins.property
    @pulumi.getter(name="maintenanceWindowStartHour")
    def maintenance_window_start_hour(self) -> pulumi.Input[_builtins.int]:
        """
        The start hour (UTC) of the 2-hour auto upgrade maintenance window (0 to 23).
        """
        return pulumi.get(self, "maintenance_window_start_hour")

    @maintenance_window_start_hour.setter
    def maintenance_window_start_hour(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "maintenance_window_start_hour", value)


if not MYPY:
    class KubernetesClusterAutoscalerConfigArgsDict(TypedDict):
        balance_similar_node_groups: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Detect similar node groups and balance the number of nodes between them.
        """
        disable_scale_down: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Disables the scale down feature of the autoscaler.
        """
        estimator: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type of resource estimator to be used in scale up.
        """
        expander: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type of node group expander to be used in scale up.
        """
        expendable_pods_priority_cutoff: NotRequired[pulumi.Input[_builtins.int]]
        """
        Pods with priority below cutoff will be expendable. They can be killed without any consideration during scale down and they don't cause scale up. Pods with null priority (PodPriority disabled) are non expendable.
        """
        ignore_daemonsets_utilization: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Ignore DaemonSet pods when calculating resource utilization for scaling down.
        """
        max_graceful_termination_sec: NotRequired[pulumi.Input[_builtins.int]]
        """
        Maximum number of seconds the cluster autoscaler waits for pod termination when trying to scale down a node
        """
        scale_down_delay_after_add: NotRequired[pulumi.Input[_builtins.str]]
        """
        How long after scale up that scale down evaluation resumes.
        """
        scale_down_unneeded_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        How long a node should be unneeded before it is eligible for scale down.
        """
        scale_down_utilization_threshold: NotRequired[pulumi.Input[_builtins.float]]
        """
        Node utilization level, defined as sum of requested resources divided by capacity, below which a node can be considered for scale down
        """
elif False:
    KubernetesClusterAutoscalerConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesClusterAutoscalerConfigArgs:
    def __init__(__self__, *,
                 balance_similar_node_groups: Optional[pulumi.Input[_builtins.bool]] = None,
                 disable_scale_down: Optional[pulumi.Input[_builtins.bool]] = None,
                 estimator: Optional[pulumi.Input[_builtins.str]] = None,
                 expander: Optional[pulumi.Input[_builtins.str]] = None,
                 expendable_pods_priority_cutoff: Optional[pulumi.Input[_builtins.int]] = None,
                 ignore_daemonsets_utilization: Optional[pulumi.Input[_builtins.bool]] = None,
                 max_graceful_termination_sec: Optional[pulumi.Input[_builtins.int]] = None,
                 scale_down_delay_after_add: Optional[pulumi.Input[_builtins.str]] = None,
                 scale_down_unneeded_time: Optional[pulumi.Input[_builtins.str]] = None,
                 scale_down_utilization_threshold: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.bool] balance_similar_node_groups: Detect similar node groups and balance the number of nodes between them.
        :param pulumi.Input[_builtins.bool] disable_scale_down: Disables the scale down feature of the autoscaler.
        :param pulumi.Input[_builtins.str] estimator: Type of resource estimator to be used in scale up.
        :param pulumi.Input[_builtins.str] expander: Type of node group expander to be used in scale up.
        :param pulumi.Input[_builtins.int] expendable_pods_priority_cutoff: Pods with priority below cutoff will be expendable. They can be killed without any consideration during scale down and they don't cause scale up. Pods with null priority (PodPriority disabled) are non expendable.
        :param pulumi.Input[_builtins.bool] ignore_daemonsets_utilization: Ignore DaemonSet pods when calculating resource utilization for scaling down.
        :param pulumi.Input[_builtins.int] max_graceful_termination_sec: Maximum number of seconds the cluster autoscaler waits for pod termination when trying to scale down a node
        :param pulumi.Input[_builtins.str] scale_down_delay_after_add: How long after scale up that scale down evaluation resumes.
        :param pulumi.Input[_builtins.str] scale_down_unneeded_time: How long a node should be unneeded before it is eligible for scale down.
        :param pulumi.Input[_builtins.float] scale_down_utilization_threshold: Node utilization level, defined as sum of requested resources divided by capacity, below which a node can be considered for scale down
        """
        if balance_similar_node_groups is not None:
            pulumi.set(__self__, "balance_similar_node_groups", balance_similar_node_groups)
        if disable_scale_down is not None:
            pulumi.set(__self__, "disable_scale_down", disable_scale_down)
        if estimator is not None:
            pulumi.set(__self__, "estimator", estimator)
        if expander is not None:
            pulumi.set(__self__, "expander", expander)
        if expendable_pods_priority_cutoff is not None:
            pulumi.set(__self__, "expendable_pods_priority_cutoff", expendable_pods_priority_cutoff)
        if ignore_daemonsets_utilization is not None:
            pulumi.set(__self__, "ignore_daemonsets_utilization", ignore_daemonsets_utilization)
        if max_graceful_termination_sec is not None:
            pulumi.set(__self__, "max_graceful_termination_sec", max_graceful_termination_sec)
        if scale_down_delay_after_add is not None:
            pulumi.set(__self__, "scale_down_delay_after_add", scale_down_delay_after_add)
        if scale_down_unneeded_time is not None:
            pulumi.set(__self__, "scale_down_unneeded_time", scale_down_unneeded_time)
        if scale_down_utilization_threshold is not None:
            pulumi.set(__self__, "scale_down_utilization_threshold", scale_down_utilization_threshold)

    @_builtins.property
    @pulumi.getter(name="balanceSimilarNodeGroups")
    def balance_similar_node_groups(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Detect similar node groups and balance the number of nodes between them.
        """
        return pulumi.get(self, "balance_similar_node_groups")

    @balance_similar_node_groups.setter
    def balance_similar_node_groups(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "balance_similar_node_groups", value)

    @_builtins.property
    @pulumi.getter(name="disableScaleDown")
    def disable_scale_down(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Disables the scale down feature of the autoscaler.
        """
        return pulumi.get(self, "disable_scale_down")

    @disable_scale_down.setter
    def disable_scale_down(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_scale_down", value)

    @_builtins.property
    @pulumi.getter
    def estimator(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type of resource estimator to be used in scale up.
        """
        return pulumi.get(self, "estimator")

    @estimator.setter
    def estimator(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "estimator", value)

    @_builtins.property
    @pulumi.getter
    def expander(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type of node group expander to be used in scale up.
        """
        return pulumi.get(self, "expander")

    @expander.setter
    def expander(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expander", value)

    @_builtins.property
    @pulumi.getter(name="expendablePodsPriorityCutoff")
    def expendable_pods_priority_cutoff(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Pods with priority below cutoff will be expendable. They can be killed without any consideration during scale down and they don't cause scale up. Pods with null priority (PodPriority disabled) are non expendable.
        """
        return pulumi.get(self, "expendable_pods_priority_cutoff")

    @expendable_pods_priority_cutoff.setter
    def expendable_pods_priority_cutoff(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "expendable_pods_priority_cutoff", value)

    @_builtins.property
    @pulumi.getter(name="ignoreDaemonsetsUtilization")
    def ignore_daemonsets_utilization(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Ignore DaemonSet pods when calculating resource utilization for scaling down.
        """
        return pulumi.get(self, "ignore_daemonsets_utilization")

    @ignore_daemonsets_utilization.setter
    def ignore_daemonsets_utilization(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ignore_daemonsets_utilization", value)

    @_builtins.property
    @pulumi.getter(name="maxGracefulTerminationSec")
    def max_graceful_termination_sec(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximum number of seconds the cluster autoscaler waits for pod termination when trying to scale down a node
        """
        return pulumi.get(self, "max_graceful_termination_sec")

    @max_graceful_termination_sec.setter
    def max_graceful_termination_sec(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_graceful_termination_sec", value)

    @_builtins.property
    @pulumi.getter(name="scaleDownDelayAfterAdd")
    def scale_down_delay_after_add(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        How long after scale up that scale down evaluation resumes.
        """
        return pulumi.get(self, "scale_down_delay_after_add")

    @scale_down_delay_after_add.setter
    def scale_down_delay_after_add(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scale_down_delay_after_add", value)

    @_builtins.property
    @pulumi.getter(name="scaleDownUnneededTime")
    def scale_down_unneeded_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        How long a node should be unneeded before it is eligible for scale down.
        """
        return pulumi.get(self, "scale_down_unneeded_time")

    @scale_down_unneeded_time.setter
    def scale_down_unneeded_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scale_down_unneeded_time", value)

    @_builtins.property
    @pulumi.getter(name="scaleDownUtilizationThreshold")
    def scale_down_utilization_threshold(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Node utilization level, defined as sum of requested resources divided by capacity, below which a node can be considered for scale down
        """
        return pulumi.get(self, "scale_down_utilization_threshold")

    @scale_down_utilization_threshold.setter
    def scale_down_utilization_threshold(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "scale_down_utilization_threshold", value)


if not MYPY:
    class KubernetesClusterKubeconfigArgsDict(TypedDict):
        cluster_ca_certificate: NotRequired[pulumi.Input[_builtins.str]]
        """
        The CA certificate of the Kubernetes API server.
        """
        config_file: NotRequired[pulumi.Input[_builtins.str]]
        """
        The raw kubeconfig file.
        """
        host: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL of the Kubernetes API server.
        """
        token: NotRequired[pulumi.Input[_builtins.str]]
        """
        The token to connect to the Kubernetes API server.
        """
elif False:
    KubernetesClusterKubeconfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesClusterKubeconfigArgs:
    def __init__(__self__, *,
                 cluster_ca_certificate: Optional[pulumi.Input[_builtins.str]] = None,
                 config_file: Optional[pulumi.Input[_builtins.str]] = None,
                 host: Optional[pulumi.Input[_builtins.str]] = None,
                 token: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] cluster_ca_certificate: The CA certificate of the Kubernetes API server.
        :param pulumi.Input[_builtins.str] config_file: The raw kubeconfig file.
        :param pulumi.Input[_builtins.str] host: The URL of the Kubernetes API server.
        :param pulumi.Input[_builtins.str] token: The token to connect to the Kubernetes API server.
        """
        if cluster_ca_certificate is not None:
            pulumi.set(__self__, "cluster_ca_certificate", cluster_ca_certificate)
        if config_file is not None:
            pulumi.set(__self__, "config_file", config_file)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if token is not None:
            pulumi.set(__self__, "token", token)

    @_builtins.property
    @pulumi.getter(name="clusterCaCertificate")
    def cluster_ca_certificate(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The CA certificate of the Kubernetes API server.
        """
        return pulumi.get(self, "cluster_ca_certificate")

    @cluster_ca_certificate.setter
    def cluster_ca_certificate(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cluster_ca_certificate", value)

    @_builtins.property
    @pulumi.getter(name="configFile")
    def config_file(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The raw kubeconfig file.
        """
        return pulumi.get(self, "config_file")

    @config_file.setter
    def config_file(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "config_file", value)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL of the Kubernetes API server.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter
    def token(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The token to connect to the Kubernetes API server.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "token", value)


if not MYPY:
    class KubernetesClusterOpenIdConnectConfigArgsDict(TypedDict):
        client_id: pulumi.Input[_builtins.str]
        """
        A client id that all tokens must be issued for
        """
        issuer_url: pulumi.Input[_builtins.str]
        """
        URL of the provider which allows the API server to discover public signing keys
        """
        groups_claims: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        JWT claim to use as the user's group
        """
        groups_prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        Prefix prepended to group claims
        """
        required_claims: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Multiple key=value pairs that describes a required claim in the ID Token
        """
        username_claim: NotRequired[pulumi.Input[_builtins.str]]
        """
        JWT claim to use as the user name
        """
        username_prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        Prefix prepended to username
        """
elif False:
    KubernetesClusterOpenIdConnectConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesClusterOpenIdConnectConfigArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[_builtins.str],
                 issuer_url: pulumi.Input[_builtins.str],
                 groups_claims: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 groups_prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 required_claims: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 username_claim: Optional[pulumi.Input[_builtins.str]] = None,
                 username_prefix: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] client_id: A client id that all tokens must be issued for
        :param pulumi.Input[_builtins.str] issuer_url: URL of the provider which allows the API server to discover public signing keys
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] groups_claims: JWT claim to use as the user's group
        :param pulumi.Input[_builtins.str] groups_prefix: Prefix prepended to group claims
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] required_claims: Multiple key=value pairs that describes a required claim in the ID Token
        :param pulumi.Input[_builtins.str] username_claim: JWT claim to use as the user name
        :param pulumi.Input[_builtins.str] username_prefix: Prefix prepended to username
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "issuer_url", issuer_url)
        if groups_claims is not None:
            pulumi.set(__self__, "groups_claims", groups_claims)
        if groups_prefix is not None:
            pulumi.set(__self__, "groups_prefix", groups_prefix)
        if required_claims is not None:
            pulumi.set(__self__, "required_claims", required_claims)
        if username_claim is not None:
            pulumi.set(__self__, "username_claim", username_claim)
        if username_prefix is not None:
            pulumi.set(__self__, "username_prefix", username_prefix)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[_builtins.str]:
        """
        A client id that all tokens must be issued for
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "client_id", value)

    @_builtins.property
    @pulumi.getter(name="issuerUrl")
    def issuer_url(self) -> pulumi.Input[_builtins.str]:
        """
        URL of the provider which allows the API server to discover public signing keys
        """
        return pulumi.get(self, "issuer_url")

    @issuer_url.setter
    def issuer_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "issuer_url", value)

    @_builtins.property
    @pulumi.getter(name="groupsClaims")
    def groups_claims(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        JWT claim to use as the user's group
        """
        return pulumi.get(self, "groups_claims")

    @groups_claims.setter
    def groups_claims(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "groups_claims", value)

    @_builtins.property
    @pulumi.getter(name="groupsPrefix")
    def groups_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Prefix prepended to group claims
        """
        return pulumi.get(self, "groups_prefix")

    @groups_prefix.setter
    def groups_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "groups_prefix", value)

    @_builtins.property
    @pulumi.getter(name="requiredClaims")
    def required_claims(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Multiple key=value pairs that describes a required claim in the ID Token
        """
        return pulumi.get(self, "required_claims")

    @required_claims.setter
    def required_claims(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "required_claims", value)

    @_builtins.property
    @pulumi.getter(name="usernameClaim")
    def username_claim(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        JWT claim to use as the user name
        """
        return pulumi.get(self, "username_claim")

    @username_claim.setter
    def username_claim(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username_claim", value)

    @_builtins.property
    @pulumi.getter(name="usernamePrefix")
    def username_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Prefix prepended to username
        """
        return pulumi.get(self, "username_prefix")

    @username_prefix.setter
    def username_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username_prefix", value)


if not MYPY:
    class KubernetesNodePoolNodeArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the IP address resource.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name for the pool.

        > **Important:** Updates to this field will recreate a new resource.
        """
        private_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['KubernetesNodePoolNodePrivateIpArgsDict']]]]
        """
        The list of private IPv4 and IPv6 addresses associated with the node.
        """
        public_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        The public IPv4. (Deprecated, Please use the official Kubernetes provider and the kubernetes_nodes data source)
        """
        public_ip_v6: NotRequired[pulumi.Input[_builtins.str]]
        """
        The public IPv6. (Deprecated, Please use the official Kubernetes provider and the kubernetes_nodes data source)
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        The status of the node.
        """
elif False:
    KubernetesNodePoolNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesNodePoolNodeArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 private_ips: Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesNodePoolNodePrivateIpArgs']]]] = None,
                 public_ip: Optional[pulumi.Input[_builtins.str]] = None,
                 public_ip_v6: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the IP address resource.
        :param pulumi.Input[_builtins.str] name: The name for the pool.
               
               > **Important:** Updates to this field will recreate a new resource.
        :param pulumi.Input[Sequence[pulumi.Input['KubernetesNodePoolNodePrivateIpArgs']]] private_ips: The list of private IPv4 and IPv6 addresses associated with the node.
        :param pulumi.Input[_builtins.str] public_ip: The public IPv4. (Deprecated, Please use the official Kubernetes provider and the kubernetes_nodes data source)
        :param pulumi.Input[_builtins.str] public_ip_v6: The public IPv6. (Deprecated, Please use the official Kubernetes provider and the kubernetes_nodes data source)
        :param pulumi.Input[_builtins.str] status: The status of the node.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if private_ips is not None:
            pulumi.set(__self__, "private_ips", private_ips)
        if public_ip is not None:
            warnings.warn("""Please use the official Kubernetes provider and the kubernetes_nodes data source""", DeprecationWarning)
            pulumi.log.warn("""public_ip is deprecated: Please use the official Kubernetes provider and the kubernetes_nodes data source""")
        if public_ip is not None:
            pulumi.set(__self__, "public_ip", public_ip)
        if public_ip_v6 is not None:
            warnings.warn("""Please use the official Kubernetes provider and the kubernetes_nodes data source""", DeprecationWarning)
            pulumi.log.warn("""public_ip_v6 is deprecated: Please use the official Kubernetes provider and the kubernetes_nodes data source""")
        if public_ip_v6 is not None:
            pulumi.set(__self__, "public_ip_v6", public_ip_v6)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the IP address resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name for the pool.

        > **Important:** Updates to this field will recreate a new resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="privateIps")
    def private_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesNodePoolNodePrivateIpArgs']]]]:
        """
        The list of private IPv4 and IPv6 addresses associated with the node.
        """
        return pulumi.get(self, "private_ips")

    @private_ips.setter
    def private_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesNodePoolNodePrivateIpArgs']]]]):
        pulumi.set(self, "private_ips", value)

    @_builtins.property
    @pulumi.getter(name="publicIp")
    @_utilities.deprecated("""Please use the official Kubernetes provider and the kubernetes_nodes data source""")
    def public_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The public IPv4. (Deprecated, Please use the official Kubernetes provider and the kubernetes_nodes data source)
        """
        return pulumi.get(self, "public_ip")

    @public_ip.setter
    def public_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_ip", value)

    @_builtins.property
    @pulumi.getter(name="publicIpV6")
    @_utilities.deprecated("""Please use the official Kubernetes provider and the kubernetes_nodes data source""")
    def public_ip_v6(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The public IPv6. (Deprecated, Please use the official Kubernetes provider and the kubernetes_nodes data source)
        """
        return pulumi.get(self, "public_ip_v6")

    @public_ip_v6.setter
    def public_ip_v6(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_ip_v6", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The status of the node.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class KubernetesNodePoolNodePrivateIpArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[_builtins.str]]
        """
        The private IP address.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the IP address resource.
        """
elif False:
    KubernetesNodePoolNodePrivateIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesNodePoolNodePrivateIpArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] address: The private IP address.
        :param pulumi.Input[_builtins.str] id: The ID of the IP address resource.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The private IP address.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the IP address resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class KubernetesNodePoolUpgradePolicyArgsDict(TypedDict):
        max_surge: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum number of nodes to be created during the upgrade
        """
        max_unavailable: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum number of nodes that can be not ready at the same time
        """
elif False:
    KubernetesNodePoolUpgradePolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesNodePoolUpgradePolicyArgs:
    def __init__(__self__, *,
                 max_surge: Optional[pulumi.Input[_builtins.int]] = None,
                 max_unavailable: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] max_surge: The maximum number of nodes to be created during the upgrade
        :param pulumi.Input[_builtins.int] max_unavailable: The maximum number of nodes that can be not ready at the same time
        """
        if max_surge is not None:
            pulumi.set(__self__, "max_surge", max_surge)
        if max_unavailable is not None:
            pulumi.set(__self__, "max_unavailable", max_unavailable)

    @_builtins.property
    @pulumi.getter(name="maxSurge")
    def max_surge(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum number of nodes to be created during the upgrade
        """
        return pulumi.get(self, "max_surge")

    @max_surge.setter
    def max_surge(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_surge", value)

    @_builtins.property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum number of nodes that can be not ready at the same time
        """
        return pulumi.get(self, "max_unavailable")

    @max_unavailable.setter
    def max_unavailable(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_unavailable", value)


if not MYPY:
    class LoadbalancerAclActionArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        The action type. Possible values are: `allow` or `deny` or `redirect`.
        """
        redirects: NotRequired[pulumi.Input[Sequence[pulumi.Input['LoadbalancerAclActionRedirectArgsDict']]]]
        """
        Redirect parameters when using an ACL with `redirect` action.
        """
elif False:
    LoadbalancerAclActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerAclActionArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 redirects: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerAclActionRedirectArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] type: The action type. Possible values are: `allow` or `deny` or `redirect`.
        :param pulumi.Input[Sequence[pulumi.Input['LoadbalancerAclActionRedirectArgs']]] redirects: Redirect parameters when using an ACL with `redirect` action.
        """
        pulumi.set(__self__, "type", type)
        if redirects is not None:
            pulumi.set(__self__, "redirects", redirects)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        The action type. Possible values are: `allow` or `deny` or `redirect`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def redirects(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerAclActionRedirectArgs']]]]:
        """
        Redirect parameters when using an ACL with `redirect` action.
        """
        return pulumi.get(self, "redirects")

    @redirects.setter
    def redirects(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerAclActionRedirectArgs']]]]):
        pulumi.set(self, "redirects", value)


if not MYPY:
    class LoadbalancerAclActionRedirectArgsDict(TypedDict):
        code: NotRequired[pulumi.Input[_builtins.int]]
        """
        The HTTP redirect code to use. Valid values are `301`, `302`, `303`, `307` and `308`.
        """
        target: NotRequired[pulumi.Input[_builtins.str]]
        """
        An URL can be used in case of a location redirect (e.g. `https://scaleway.com` will redirect to this same URL). A scheme name (e.g. `https`, `http`, `ftp`, `git`) will replace the request's original scheme.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The redirect type. Possible values are: `location` or `scheme`.
        """
elif False:
    LoadbalancerAclActionRedirectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerAclActionRedirectArgs:
    def __init__(__self__, *,
                 code: Optional[pulumi.Input[_builtins.int]] = None,
                 target: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] code: The HTTP redirect code to use. Valid values are `301`, `302`, `303`, `307` and `308`.
        :param pulumi.Input[_builtins.str] target: An URL can be used in case of a location redirect (e.g. `https://scaleway.com` will redirect to this same URL). A scheme name (e.g. `https`, `http`, `ftp`, `git`) will replace the request's original scheme.
        :param pulumi.Input[_builtins.str] type: The redirect type. Possible values are: `location` or `scheme`.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The HTTP redirect code to use. Valid values are `301`, `302`, `303`, `307` and `308`.
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "code", value)

    @_builtins.property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An URL can be used in case of a location redirect (e.g. `https://scaleway.com` will redirect to this same URL). A scheme name (e.g. `https`, `http`, `ftp`, `git`) will replace the request's original scheme.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The redirect type. Possible values are: `location` or `scheme`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class LoadbalancerAclMatchArgsDict(TypedDict):
        http_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        The HTTP filter to match. This filter is supported only if your backend protocol has an HTTP forward protocol.
        It extracts the request's URL path, which starts at the first slash and ends before the question mark (without the host part).
        Possible values are: `acl_http_filter_none`, `path_begin`, `path_end`, `http_header_match` or `regex`.
        """
        http_filter_option: NotRequired[pulumi.Input[_builtins.str]]
        """
        If you have `http_filter` at `http_header_match`, you can use this field to filter on the HTTP header's value.
        """
        http_filter_values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of possible values to match for the given HTTP filter.
        Keep in mind that in the case of `http_header_match` the HTTP header field name is case insensitive.
        """
        invert: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set to `true`, the condition will be of type "unless".
        """
        ip_subnets: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of IPs, or CIDR v4/v6 addresses of the session client, to match. Only one of `ip_subnet` and `ips_edge_services` should be specified.
        """
        ips_edge_services: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Defines whether Edge Services IPs should be matched. Only one of `ip_subnet` and `ips_edge_services` should be specified.
        """
elif False:
    LoadbalancerAclMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerAclMatchArgs:
    def __init__(__self__, *,
                 http_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 http_filter_option: Optional[pulumi.Input[_builtins.str]] = None,
                 http_filter_values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 invert: Optional[pulumi.Input[_builtins.bool]] = None,
                 ip_subnets: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 ips_edge_services: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] http_filter: The HTTP filter to match. This filter is supported only if your backend protocol has an HTTP forward protocol.
               It extracts the request's URL path, which starts at the first slash and ends before the question mark (without the host part).
               Possible values are: `acl_http_filter_none`, `path_begin`, `path_end`, `http_header_match` or `regex`.
        :param pulumi.Input[_builtins.str] http_filter_option: If you have `http_filter` at `http_header_match`, you can use this field to filter on the HTTP header's value.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] http_filter_values: A list of possible values to match for the given HTTP filter.
               Keep in mind that in the case of `http_header_match` the HTTP header field name is case insensitive.
        :param pulumi.Input[_builtins.bool] invert: If set to `true`, the condition will be of type "unless".
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ip_subnets: A list of IPs, or CIDR v4/v6 addresses of the session client, to match. Only one of `ip_subnet` and `ips_edge_services` should be specified.
        :param pulumi.Input[_builtins.bool] ips_edge_services: Defines whether Edge Services IPs should be matched. Only one of `ip_subnet` and `ips_edge_services` should be specified.
        """
        if http_filter is not None:
            pulumi.set(__self__, "http_filter", http_filter)
        if http_filter_option is not None:
            pulumi.set(__self__, "http_filter_option", http_filter_option)
        if http_filter_values is not None:
            pulumi.set(__self__, "http_filter_values", http_filter_values)
        if invert is not None:
            pulumi.set(__self__, "invert", invert)
        if ip_subnets is not None:
            pulumi.set(__self__, "ip_subnets", ip_subnets)
        if ips_edge_services is not None:
            pulumi.set(__self__, "ips_edge_services", ips_edge_services)

    @_builtins.property
    @pulumi.getter(name="httpFilter")
    def http_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The HTTP filter to match. This filter is supported only if your backend protocol has an HTTP forward protocol.
        It extracts the request's URL path, which starts at the first slash and ends before the question mark (without the host part).
        Possible values are: `acl_http_filter_none`, `path_begin`, `path_end`, `http_header_match` or `regex`.
        """
        return pulumi.get(self, "http_filter")

    @http_filter.setter
    def http_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "http_filter", value)

    @_builtins.property
    @pulumi.getter(name="httpFilterOption")
    def http_filter_option(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If you have `http_filter` at `http_header_match`, you can use this field to filter on the HTTP header's value.
        """
        return pulumi.get(self, "http_filter_option")

    @http_filter_option.setter
    def http_filter_option(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "http_filter_option", value)

    @_builtins.property
    @pulumi.getter(name="httpFilterValues")
    def http_filter_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of possible values to match for the given HTTP filter.
        Keep in mind that in the case of `http_header_match` the HTTP header field name is case insensitive.
        """
        return pulumi.get(self, "http_filter_values")

    @http_filter_values.setter
    def http_filter_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "http_filter_values", value)

    @_builtins.property
    @pulumi.getter
    def invert(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set to `true`, the condition will be of type "unless".
        """
        return pulumi.get(self, "invert")

    @invert.setter
    def invert(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "invert", value)

    @_builtins.property
    @pulumi.getter(name="ipSubnets")
    def ip_subnets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of IPs, or CIDR v4/v6 addresses of the session client, to match. Only one of `ip_subnet` and `ips_edge_services` should be specified.
        """
        return pulumi.get(self, "ip_subnets")

    @ip_subnets.setter
    def ip_subnets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ip_subnets", value)

    @_builtins.property
    @pulumi.getter(name="ipsEdgeServices")
    def ips_edge_services(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Defines whether Edge Services IPs should be matched. Only one of `ip_subnet` and `ips_edge_services` should be specified.
        """
        return pulumi.get(self, "ips_edge_services")

    @ips_edge_services.setter
    def ips_edge_services(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ips_edge_services", value)


if not MYPY:
    class LoadbalancerBackendHealthCheckHttpArgsDict(TypedDict):
        uri: pulumi.Input[_builtins.str]
        """
        The HTTP endpoint URL to call for HC requests
        """
        code: NotRequired[pulumi.Input[_builtins.int]]
        """
        The expected HTTP status code
        """
        host_header: NotRequired[pulumi.Input[_builtins.str]]
        """
        The HTTP host header to use for HC requests
        """
        method: NotRequired[pulumi.Input[_builtins.str]]
        """
        The HTTP method to use for HC requests
        """
elif False:
    LoadbalancerBackendHealthCheckHttpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerBackendHealthCheckHttpArgs:
    def __init__(__self__, *,
                 uri: pulumi.Input[_builtins.str],
                 code: Optional[pulumi.Input[_builtins.int]] = None,
                 host_header: Optional[pulumi.Input[_builtins.str]] = None,
                 method: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] uri: The HTTP endpoint URL to call for HC requests
        :param pulumi.Input[_builtins.int] code: The expected HTTP status code
        :param pulumi.Input[_builtins.str] host_header: The HTTP host header to use for HC requests
        :param pulumi.Input[_builtins.str] method: The HTTP method to use for HC requests
        """
        pulumi.set(__self__, "uri", uri)
        if code is not None:
            pulumi.set(__self__, "code", code)
        if host_header is not None:
            pulumi.set(__self__, "host_header", host_header)
        if method is not None:
            pulumi.set(__self__, "method", method)

    @_builtins.property
    @pulumi.getter
    def uri(self) -> pulumi.Input[_builtins.str]:
        """
        The HTTP endpoint URL to call for HC requests
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "uri", value)

    @_builtins.property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The expected HTTP status code
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "code", value)

    @_builtins.property
    @pulumi.getter(name="hostHeader")
    def host_header(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The HTTP host header to use for HC requests
        """
        return pulumi.get(self, "host_header")

    @host_header.setter
    def host_header(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host_header", value)

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The HTTP method to use for HC requests
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "method", value)


if not MYPY:
    class LoadbalancerBackendHealthCheckHttpsArgsDict(TypedDict):
        uri: pulumi.Input[_builtins.str]
        """
        The HTTPS endpoint URL to call for HC requests
        """
        code: NotRequired[pulumi.Input[_builtins.int]]
        """
        The expected HTTP status code
        """
        host_header: NotRequired[pulumi.Input[_builtins.str]]
        """
        The HTTP host header to use for HC requests
        """
        method: NotRequired[pulumi.Input[_builtins.str]]
        """
        The HTTP method to use for HC requests
        """
        sni: NotRequired[pulumi.Input[_builtins.str]]
        """
        The SNI to use for HC requests over SSL
        """
elif False:
    LoadbalancerBackendHealthCheckHttpsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerBackendHealthCheckHttpsArgs:
    def __init__(__self__, *,
                 uri: pulumi.Input[_builtins.str],
                 code: Optional[pulumi.Input[_builtins.int]] = None,
                 host_header: Optional[pulumi.Input[_builtins.str]] = None,
                 method: Optional[pulumi.Input[_builtins.str]] = None,
                 sni: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] uri: The HTTPS endpoint URL to call for HC requests
        :param pulumi.Input[_builtins.int] code: The expected HTTP status code
        :param pulumi.Input[_builtins.str] host_header: The HTTP host header to use for HC requests
        :param pulumi.Input[_builtins.str] method: The HTTP method to use for HC requests
        :param pulumi.Input[_builtins.str] sni: The SNI to use for HC requests over SSL
        """
        pulumi.set(__self__, "uri", uri)
        if code is not None:
            pulumi.set(__self__, "code", code)
        if host_header is not None:
            pulumi.set(__self__, "host_header", host_header)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if sni is not None:
            pulumi.set(__self__, "sni", sni)

    @_builtins.property
    @pulumi.getter
    def uri(self) -> pulumi.Input[_builtins.str]:
        """
        The HTTPS endpoint URL to call for HC requests
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "uri", value)

    @_builtins.property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The expected HTTP status code
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "code", value)

    @_builtins.property
    @pulumi.getter(name="hostHeader")
    def host_header(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The HTTP host header to use for HC requests
        """
        return pulumi.get(self, "host_header")

    @host_header.setter
    def host_header(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host_header", value)

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The HTTP method to use for HC requests
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter
    def sni(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The SNI to use for HC requests over SSL
        """
        return pulumi.get(self, "sni")

    @sni.setter
    def sni(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sni", value)


if not MYPY:
    class LoadbalancerBackendHealthCheckTcpArgsDict(TypedDict):
        pass
elif False:
    LoadbalancerBackendHealthCheckTcpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerBackendHealthCheckTcpArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class LoadbalancerCertificateCustomCertificateArgsDict(TypedDict):
        certificate_chain: pulumi.Input[_builtins.str]
        """
        The full PEM-formatted certificate chain
        """
elif False:
    LoadbalancerCertificateCustomCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerCertificateCustomCertificateArgs:
    def __init__(__self__, *,
                 certificate_chain: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] certificate_chain: The full PEM-formatted certificate chain
        """
        pulumi.set(__self__, "certificate_chain", certificate_chain)

    @_builtins.property
    @pulumi.getter(name="certificateChain")
    def certificate_chain(self) -> pulumi.Input[_builtins.str]:
        """
        The full PEM-formatted certificate chain
        """
        return pulumi.get(self, "certificate_chain")

    @certificate_chain.setter
    def certificate_chain(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "certificate_chain", value)


if not MYPY:
    class LoadbalancerCertificateLetsencryptArgsDict(TypedDict):
        common_name: pulumi.Input[_builtins.str]
        """
        Main domain of the certificate
        """
        subject_alternative_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The alternative domain names of the certificate
        """
elif False:
    LoadbalancerCertificateLetsencryptArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerCertificateLetsencryptArgs:
    def __init__(__self__, *,
                 common_name: pulumi.Input[_builtins.str],
                 subject_alternative_names: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] common_name: Main domain of the certificate
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] subject_alternative_names: The alternative domain names of the certificate
        """
        pulumi.set(__self__, "common_name", common_name)
        if subject_alternative_names is not None:
            pulumi.set(__self__, "subject_alternative_names", subject_alternative_names)

    @_builtins.property
    @pulumi.getter(name="commonName")
    def common_name(self) -> pulumi.Input[_builtins.str]:
        """
        Main domain of the certificate
        """
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "common_name", value)

    @_builtins.property
    @pulumi.getter(name="subjectAlternativeNames")
    def subject_alternative_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The alternative domain names of the certificate
        """
        return pulumi.get(self, "subject_alternative_names")

    @subject_alternative_names.setter
    def subject_alternative_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "subject_alternative_names", value)


if not MYPY:
    class LoadbalancerFrontendAclArgsDict(TypedDict):
        action: pulumi.Input['LoadbalancerFrontendAclActionArgsDict']
        """
        Action to undertake when an ACL filter matches.
        """
        match: pulumi.Input['LoadbalancerFrontendAclMatchArgsDict']
        """
        The ACL match rule. At least `ip_subnet` or `ips_edge_services` or `http_filter` and `http_filter_value` are required.
        """
        created_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        The date and time the frontend was created.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of the ACL
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ACL name. If not provided it will be randomly generated.
        """
        updated_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        The date and time the frontend resource was updated.
        """
elif False:
    LoadbalancerFrontendAclArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerFrontendAclArgs:
    def __init__(__self__, *,
                 action: pulumi.Input['LoadbalancerFrontendAclActionArgs'],
                 match: pulumi.Input['LoadbalancerFrontendAclMatchArgs'],
                 created_at: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_at: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['LoadbalancerFrontendAclActionArgs'] action: Action to undertake when an ACL filter matches.
        :param pulumi.Input['LoadbalancerFrontendAclMatchArgs'] match: The ACL match rule. At least `ip_subnet` or `ips_edge_services` or `http_filter` and `http_filter_value` are required.
        :param pulumi.Input[_builtins.str] created_at: The date and time the frontend was created.
        :param pulumi.Input[_builtins.str] description: Description of the ACL
        :param pulumi.Input[_builtins.str] name: The ACL name. If not provided it will be randomly generated.
        :param pulumi.Input[_builtins.str] updated_at: The date and time the frontend resource was updated.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "match", match)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)

    @_builtins.property
    @pulumi.getter
    def action(self) -> pulumi.Input['LoadbalancerFrontendAclActionArgs']:
        """
        Action to undertake when an ACL filter matches.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input['LoadbalancerFrontendAclActionArgs']):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def match(self) -> pulumi.Input['LoadbalancerFrontendAclMatchArgs']:
        """
        The ACL match rule. At least `ip_subnet` or `ips_edge_services` or `http_filter` and `http_filter_value` are required.
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: pulumi.Input['LoadbalancerFrontendAclMatchArgs']):
        pulumi.set(self, "match", value)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The date and time the frontend was created.
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of the ACL
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ACL name. If not provided it will be randomly generated.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The date and time the frontend resource was updated.
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_at", value)


if not MYPY:
    class LoadbalancerFrontendAclActionArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        The action type. Possible values are: `allow` or `deny` or `redirect`.
        """
        redirects: NotRequired[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendAclActionRedirectArgsDict']]]]
        """
        Redirect parameters when using an ACL with `redirect` action.
        """
elif False:
    LoadbalancerFrontendAclActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerFrontendAclActionArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 redirects: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendAclActionRedirectArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] type: The action type. Possible values are: `allow` or `deny` or `redirect`.
        :param pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendAclActionRedirectArgs']]] redirects: Redirect parameters when using an ACL with `redirect` action.
        """
        pulumi.set(__self__, "type", type)
        if redirects is not None:
            pulumi.set(__self__, "redirects", redirects)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        The action type. Possible values are: `allow` or `deny` or `redirect`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def redirects(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendAclActionRedirectArgs']]]]:
        """
        Redirect parameters when using an ACL with `redirect` action.
        """
        return pulumi.get(self, "redirects")

    @redirects.setter
    def redirects(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendAclActionRedirectArgs']]]]):
        pulumi.set(self, "redirects", value)


if not MYPY:
    class LoadbalancerFrontendAclActionRedirectArgsDict(TypedDict):
        code: NotRequired[pulumi.Input[_builtins.int]]
        """
        The HTTP redirect code to use. Valid values are `301`, `302`, `303`, `307` and `308`.
        """
        target: NotRequired[pulumi.Input[_builtins.str]]
        """
        A URL can be used in case of a location redirect (e.g. `https://scaleway.com` will redirect to this same URL). A scheme name (e.g. `https`, `http`, `ftp`, `git`) will replace the request's original scheme.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The redirect type. Possible values are: `location` or `scheme`.
        """
elif False:
    LoadbalancerFrontendAclActionRedirectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerFrontendAclActionRedirectArgs:
    def __init__(__self__, *,
                 code: Optional[pulumi.Input[_builtins.int]] = None,
                 target: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] code: The HTTP redirect code to use. Valid values are `301`, `302`, `303`, `307` and `308`.
        :param pulumi.Input[_builtins.str] target: A URL can be used in case of a location redirect (e.g. `https://scaleway.com` will redirect to this same URL). A scheme name (e.g. `https`, `http`, `ftp`, `git`) will replace the request's original scheme.
        :param pulumi.Input[_builtins.str] type: The redirect type. Possible values are: `location` or `scheme`.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The HTTP redirect code to use. Valid values are `301`, `302`, `303`, `307` and `308`.
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "code", value)

    @_builtins.property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A URL can be used in case of a location redirect (e.g. `https://scaleway.com` will redirect to this same URL). A scheme name (e.g. `https`, `http`, `ftp`, `git`) will replace the request's original scheme.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The redirect type. Possible values are: `location` or `scheme`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class LoadbalancerFrontendAclMatchArgsDict(TypedDict):
        http_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        The HTTP filter to match. This filter is supported only if your backend protocol has an HTTP forward protocol.
        It extracts the request's URL path, which starts at the first slash and ends before the question mark (without the host part).
        Possible values are: `acl_http_filter_none`, `path_begin`, `path_end`, `http_header_match` or `regex`.
        """
        http_filter_option: NotRequired[pulumi.Input[_builtins.str]]
        """
        If you have `http_filter` at `http_header_match`, you can use this field to filter on the HTTP header's value.
        """
        http_filter_values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of possible values to match for the given HTTP filter.
        Keep in mind that in the case of `http_header_match` the HTTP header field name is case insensitive.
        """
        invert: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set to `true`, the condition will be of type "unless".
        """
        ip_subnets: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of IPs, or CIDR v4/v6 addresses of the session client, to match. Only one of `ip_subnet` and `ips_edge_services` should be specified.
        """
        ips_edge_services: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Defines whether Edge Services IPs should be matched. Only one of `ip_subnet` and `ips_edge_services` should be specified.
        """
elif False:
    LoadbalancerFrontendAclMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerFrontendAclMatchArgs:
    def __init__(__self__, *,
                 http_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 http_filter_option: Optional[pulumi.Input[_builtins.str]] = None,
                 http_filter_values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 invert: Optional[pulumi.Input[_builtins.bool]] = None,
                 ip_subnets: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 ips_edge_services: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] http_filter: The HTTP filter to match. This filter is supported only if your backend protocol has an HTTP forward protocol.
               It extracts the request's URL path, which starts at the first slash and ends before the question mark (without the host part).
               Possible values are: `acl_http_filter_none`, `path_begin`, `path_end`, `http_header_match` or `regex`.
        :param pulumi.Input[_builtins.str] http_filter_option: If you have `http_filter` at `http_header_match`, you can use this field to filter on the HTTP header's value.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] http_filter_values: A list of possible values to match for the given HTTP filter.
               Keep in mind that in the case of `http_header_match` the HTTP header field name is case insensitive.
        :param pulumi.Input[_builtins.bool] invert: If set to `true`, the condition will be of type "unless".
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ip_subnets: A list of IPs, or CIDR v4/v6 addresses of the session client, to match. Only one of `ip_subnet` and `ips_edge_services` should be specified.
        :param pulumi.Input[_builtins.bool] ips_edge_services: Defines whether Edge Services IPs should be matched. Only one of `ip_subnet` and `ips_edge_services` should be specified.
        """
        if http_filter is not None:
            pulumi.set(__self__, "http_filter", http_filter)
        if http_filter_option is not None:
            pulumi.set(__self__, "http_filter_option", http_filter_option)
        if http_filter_values is not None:
            pulumi.set(__self__, "http_filter_values", http_filter_values)
        if invert is not None:
            pulumi.set(__self__, "invert", invert)
        if ip_subnets is not None:
            pulumi.set(__self__, "ip_subnets", ip_subnets)
        if ips_edge_services is not None:
            pulumi.set(__self__, "ips_edge_services", ips_edge_services)

    @_builtins.property
    @pulumi.getter(name="httpFilter")
    def http_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The HTTP filter to match. This filter is supported only if your backend protocol has an HTTP forward protocol.
        It extracts the request's URL path, which starts at the first slash and ends before the question mark (without the host part).
        Possible values are: `acl_http_filter_none`, `path_begin`, `path_end`, `http_header_match` or `regex`.
        """
        return pulumi.get(self, "http_filter")

    @http_filter.setter
    def http_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "http_filter", value)

    @_builtins.property
    @pulumi.getter(name="httpFilterOption")
    def http_filter_option(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If you have `http_filter` at `http_header_match`, you can use this field to filter on the HTTP header's value.
        """
        return pulumi.get(self, "http_filter_option")

    @http_filter_option.setter
    def http_filter_option(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "http_filter_option", value)

    @_builtins.property
    @pulumi.getter(name="httpFilterValues")
    def http_filter_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of possible values to match for the given HTTP filter.
        Keep in mind that in the case of `http_header_match` the HTTP header field name is case insensitive.
        """
        return pulumi.get(self, "http_filter_values")

    @http_filter_values.setter
    def http_filter_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "http_filter_values", value)

    @_builtins.property
    @pulumi.getter
    def invert(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set to `true`, the condition will be of type "unless".
        """
        return pulumi.get(self, "invert")

    @invert.setter
    def invert(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "invert", value)

    @_builtins.property
    @pulumi.getter(name="ipSubnets")
    def ip_subnets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of IPs, or CIDR v4/v6 addresses of the session client, to match. Only one of `ip_subnet` and `ips_edge_services` should be specified.
        """
        return pulumi.get(self, "ip_subnets")

    @ip_subnets.setter
    def ip_subnets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ip_subnets", value)

    @_builtins.property
    @pulumi.getter(name="ipsEdgeServices")
    def ips_edge_services(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Defines whether Edge Services IPs should be matched. Only one of `ip_subnet` and `ips_edge_services` should be specified.
        """
        return pulumi.get(self, "ips_edge_services")

    @ips_edge_services.setter
    def ips_edge_services(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ips_edge_services", value)


if not MYPY:
    class LoadbalancerPrivateIpArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[_builtins.str]]
        """
        The private IP address.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the IP address resource.
        """
elif False:
    LoadbalancerPrivateIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerPrivateIpArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] address: The private IP address.
        :param pulumi.Input[_builtins.str] id: The ID of the IP address resource.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The private IP address.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the IP address resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class LoadbalancerPrivateNetworkArgsDict(TypedDict):
        private_network_id: pulumi.Input[_builtins.str]
        """
        The ID of the Private Network to attach to.
        - > **Important:** Updates to `private_network` will recreate the attachment.
        """
        dhcp_config: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Set to true if you want to let DHCP assign IP addresses
        """
        ipam_ids: NotRequired[pulumi.Input[_builtins.str]]
        """
        IPAM ID of a pre-reserved IP address to assign to the Load Balancer on this Private Network.
        """
        static_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Define an IP address in the subnet of your private network that will be assigned to your load balancer instance
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        The status of the private network connection.
        """
        zone: NotRequired[pulumi.Input[_builtins.str]]
        """
        `zone`) The zone of the Load Balancer.
        """
elif False:
    LoadbalancerPrivateNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerPrivateNetworkArgs:
    def __init__(__self__, *,
                 private_network_id: pulumi.Input[_builtins.str],
                 dhcp_config: Optional[pulumi.Input[_builtins.bool]] = None,
                 ipam_ids: Optional[pulumi.Input[_builtins.str]] = None,
                 static_configs: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 zone: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] private_network_id: The ID of the Private Network to attach to.
               - > **Important:** Updates to `private_network` will recreate the attachment.
        :param pulumi.Input[_builtins.bool] dhcp_config: Set to true if you want to let DHCP assign IP addresses
        :param pulumi.Input[_builtins.str] ipam_ids: IPAM ID of a pre-reserved IP address to assign to the Load Balancer on this Private Network.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] static_configs: Define an IP address in the subnet of your private network that will be assigned to your load balancer instance
        :param pulumi.Input[_builtins.str] status: The status of the private network connection.
        :param pulumi.Input[_builtins.str] zone: `zone`) The zone of the Load Balancer.
        """
        pulumi.set(__self__, "private_network_id", private_network_id)
        if dhcp_config is not None:
            warnings.warn("""dhcp_config field is deprecated, please use `private_network_id` or `ipam_ids` instead""", DeprecationWarning)
            pulumi.log.warn("""dhcp_config is deprecated: dhcp_config field is deprecated, please use `private_network_id` or `ipam_ids` instead""")
        if dhcp_config is not None:
            pulumi.set(__self__, "dhcp_config", dhcp_config)
        if ipam_ids is not None:
            pulumi.set(__self__, "ipam_ids", ipam_ids)
        if static_configs is not None:
            warnings.warn("""static_config field is deprecated, please use `private_network_id` or `ipam_ids` instead""", DeprecationWarning)
            pulumi.log.warn("""static_configs is deprecated: static_config field is deprecated, please use `private_network_id` or `ipam_ids` instead""")
        if static_configs is not None:
            pulumi.set(__self__, "static_configs", static_configs)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if zone is not None:
            pulumi.set(__self__, "zone", zone)

    @_builtins.property
    @pulumi.getter(name="privateNetworkId")
    def private_network_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the Private Network to attach to.
        - > **Important:** Updates to `private_network` will recreate the attachment.
        """
        return pulumi.get(self, "private_network_id")

    @private_network_id.setter
    def private_network_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "private_network_id", value)

    @_builtins.property
    @pulumi.getter(name="dhcpConfig")
    @_utilities.deprecated("""dhcp_config field is deprecated, please use `private_network_id` or `ipam_ids` instead""")
    def dhcp_config(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Set to true if you want to let DHCP assign IP addresses
        """
        return pulumi.get(self, "dhcp_config")

    @dhcp_config.setter
    def dhcp_config(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "dhcp_config", value)

    @_builtins.property
    @pulumi.getter(name="ipamIds")
    def ipam_ids(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IPAM ID of a pre-reserved IP address to assign to the Load Balancer on this Private Network.
        """
        return pulumi.get(self, "ipam_ids")

    @ipam_ids.setter
    def ipam_ids(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ipam_ids", value)

    @_builtins.property
    @pulumi.getter(name="staticConfigs")
    @_utilities.deprecated("""static_config field is deprecated, please use `private_network_id` or `ipam_ids` instead""")
    def static_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Define an IP address in the subnet of your private network that will be assigned to your load balancer instance
        """
        return pulumi.get(self, "static_configs")

    @static_configs.setter
    def static_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "static_configs", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The status of the private network connection.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter
    def zone(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        `zone`) The zone of the Load Balancer.
        """
        return pulumi.get(self, "zone")

    @zone.setter
    def zone(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "zone", value)


if not MYPY:
    class MnqSnsCredentialsPermissionsArgsDict(TypedDict):
        can_manage: NotRequired[pulumi.Input[_builtins.bool]]
        """
        . Defines whether the user can manage the associated resource(s).
        """
        can_publish: NotRequired[pulumi.Input[_builtins.bool]]
        """
        . Defines whether the user can publish messages to the service.
        """
        can_receive: NotRequired[pulumi.Input[_builtins.bool]]
        """
        . Defines whether the user can receive messages from the service.
        """
elif False:
    MnqSnsCredentialsPermissionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MnqSnsCredentialsPermissionsArgs:
    def __init__(__self__, *,
                 can_manage: Optional[pulumi.Input[_builtins.bool]] = None,
                 can_publish: Optional[pulumi.Input[_builtins.bool]] = None,
                 can_receive: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] can_manage: . Defines whether the user can manage the associated resource(s).
        :param pulumi.Input[_builtins.bool] can_publish: . Defines whether the user can publish messages to the service.
        :param pulumi.Input[_builtins.bool] can_receive: . Defines whether the user can receive messages from the service.
        """
        if can_manage is not None:
            pulumi.set(__self__, "can_manage", can_manage)
        if can_publish is not None:
            pulumi.set(__self__, "can_publish", can_publish)
        if can_receive is not None:
            pulumi.set(__self__, "can_receive", can_receive)

    @_builtins.property
    @pulumi.getter(name="canManage")
    def can_manage(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        . Defines whether the user can manage the associated resource(s).
        """
        return pulumi.get(self, "can_manage")

    @can_manage.setter
    def can_manage(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "can_manage", value)

    @_builtins.property
    @pulumi.getter(name="canPublish")
    def can_publish(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        . Defines whether the user can publish messages to the service.
        """
        return pulumi.get(self, "can_publish")

    @can_publish.setter
    def can_publish(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "can_publish", value)

    @_builtins.property
    @pulumi.getter(name="canReceive")
    def can_receive(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        . Defines whether the user can receive messages from the service.
        """
        return pulumi.get(self, "can_receive")

    @can_receive.setter
    def can_receive(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "can_receive", value)


if not MYPY:
    class MnqSqsCredentialsPermissionsArgsDict(TypedDict):
        can_manage: NotRequired[pulumi.Input[_builtins.bool]]
        """
        . Defines whether the user can manage the associated resource(s).
        """
        can_publish: NotRequired[pulumi.Input[_builtins.bool]]
        """
        . Defines whether the user can publish messages to the service.
        """
        can_receive: NotRequired[pulumi.Input[_builtins.bool]]
        """
        . Defines whether the user can receive messages from the service.
        """
elif False:
    MnqSqsCredentialsPermissionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MnqSqsCredentialsPermissionsArgs:
    def __init__(__self__, *,
                 can_manage: Optional[pulumi.Input[_builtins.bool]] = None,
                 can_publish: Optional[pulumi.Input[_builtins.bool]] = None,
                 can_receive: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] can_manage: . Defines whether the user can manage the associated resource(s).
        :param pulumi.Input[_builtins.bool] can_publish: . Defines whether the user can publish messages to the service.
        :param pulumi.Input[_builtins.bool] can_receive: . Defines whether the user can receive messages from the service.
        """
        if can_manage is not None:
            pulumi.set(__self__, "can_manage", can_manage)
        if can_publish is not None:
            pulumi.set(__self__, "can_publish", can_publish)
        if can_receive is not None:
            pulumi.set(__self__, "can_receive", can_receive)

    @_builtins.property
    @pulumi.getter(name="canManage")
    def can_manage(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        . Defines whether the user can manage the associated resource(s).
        """
        return pulumi.get(self, "can_manage")

    @can_manage.setter
    def can_manage(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "can_manage", value)

    @_builtins.property
    @pulumi.getter(name="canPublish")
    def can_publish(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        . Defines whether the user can publish messages to the service.
        """
        return pulumi.get(self, "can_publish")

    @can_publish.setter
    def can_publish(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "can_publish", value)

    @_builtins.property
    @pulumi.getter(name="canReceive")
    def can_receive(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        . Defines whether the user can receive messages from the service.
        """
        return pulumi.get(self, "can_receive")

    @can_receive.setter
    def can_receive(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "can_receive", value)


if not MYPY:
    class MnqSqsQueueDeadLetterQueueArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of the queue with format `{region/{project-id}/{queue-name}`
        """
        max_receive_count: pulumi.Input[_builtins.int]
        """
        The number of times a message is delivered to the source queue before being sent to the dead-letter queue. Must be between 1 and 1,000.
        """
elif False:
    MnqSqsQueueDeadLetterQueueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MnqSqsQueueDeadLetterQueueArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 max_receive_count: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the queue with format `{region/{project-id}/{queue-name}`
        :param pulumi.Input[_builtins.int] max_receive_count: The number of times a message is delivered to the source queue before being sent to the dead-letter queue. Must be between 1 and 1,000.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "max_receive_count", max_receive_count)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the queue with format `{region/{project-id}/{queue-name}`
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="maxReceiveCount")
    def max_receive_count(self) -> pulumi.Input[_builtins.int]:
        """
        The number of times a message is delivered to the source queue before being sent to the dead-letter queue. Must be between 1 and 1,000.
        """
        return pulumi.get(self, "max_receive_count")

    @max_receive_count.setter
    def max_receive_count(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "max_receive_count", value)


if not MYPY:
    class MongoDbInstancePrivateIpArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[_builtins.str]]
        """
        The private IPv4 address.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the endpoint.
        """
elif False:
    MongoDbInstancePrivateIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MongoDbInstancePrivateIpArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] address: The private IPv4 address.
        :param pulumi.Input[_builtins.str] id: The ID of the endpoint.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The private IPv4 address.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the endpoint.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class MongoDbInstancePrivateNetworkArgsDict(TypedDict):
        pn_id: pulumi.Input[_builtins.str]
        """
        The ID of the Private Network.
        """
        dns_records: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of DNS records for your endpoint.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the endpoint.
        """
        ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of IP addresses for your endpoint.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        TCP port of the endpoint.
        """
elif False:
    MongoDbInstancePrivateNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MongoDbInstancePrivateNetworkArgs:
    def __init__(__self__, *,
                 pn_id: pulumi.Input[_builtins.str],
                 dns_records: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 ips: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] pn_id: The ID of the Private Network.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] dns_records: List of DNS records for your endpoint.
        :param pulumi.Input[_builtins.str] id: The ID of the endpoint.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ips: List of IP addresses for your endpoint.
        :param pulumi.Input[_builtins.int] port: TCP port of the endpoint.
        """
        pulumi.set(__self__, "pn_id", pn_id)
        if dns_records is not None:
            pulumi.set(__self__, "dns_records", dns_records)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter(name="pnId")
    def pn_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the Private Network.
        """
        return pulumi.get(self, "pn_id")

    @pn_id.setter
    def pn_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "pn_id", value)

    @_builtins.property
    @pulumi.getter(name="dnsRecords")
    def dns_records(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of DNS records for your endpoint.
        """
        return pulumi.get(self, "dns_records")

    @dns_records.setter
    def dns_records(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "dns_records", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the endpoint.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of IP addresses for your endpoint.
        """
        return pulumi.get(self, "ips")

    @ips.setter
    def ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ips", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        TCP port of the endpoint.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class MongoDbInstancePublicNetworkArgsDict(TypedDict):
        dns_record: NotRequired[pulumi.Input[_builtins.str]]
        """
        The DNS record of your endpoint
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the endpoint.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        TCP port of the endpoint.
        """
elif False:
    MongoDbInstancePublicNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MongoDbInstancePublicNetworkArgs:
    def __init__(__self__, *,
                 dns_record: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] dns_record: The DNS record of your endpoint
        :param pulumi.Input[_builtins.str] id: The ID of the endpoint.
        :param pulumi.Input[_builtins.int] port: TCP port of the endpoint.
        """
        if dns_record is not None:
            pulumi.set(__self__, "dns_record", dns_record)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter(name="dnsRecord")
    def dns_record(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The DNS record of your endpoint
        """
        return pulumi.get(self, "dns_record")

    @dns_record.setter
    def dns_record(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dns_record", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the endpoint.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        TCP port of the endpoint.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class ObjectBucketAclAccessControlPolicyArgsDict(TypedDict):
        owner: pulumi.Input['ObjectBucketAclAccessControlPolicyOwnerArgsDict']
        """
        Configuration block of the bucket project owner's display organization ID.
        """
        grants: NotRequired[pulumi.Input[Sequence[pulumi.Input['ObjectBucketAclAccessControlPolicyGrantArgsDict']]]]
        """
        Grant
        """
elif False:
    ObjectBucketAclAccessControlPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ObjectBucketAclAccessControlPolicyArgs:
    def __init__(__self__, *,
                 owner: pulumi.Input['ObjectBucketAclAccessControlPolicyOwnerArgs'],
                 grants: Optional[pulumi.Input[Sequence[pulumi.Input['ObjectBucketAclAccessControlPolicyGrantArgs']]]] = None):
        """
        :param pulumi.Input['ObjectBucketAclAccessControlPolicyOwnerArgs'] owner: Configuration block of the bucket project owner's display organization ID.
        :param pulumi.Input[Sequence[pulumi.Input['ObjectBucketAclAccessControlPolicyGrantArgs']]] grants: Grant
        """
        pulumi.set(__self__, "owner", owner)
        if grants is not None:
            pulumi.set(__self__, "grants", grants)

    @_builtins.property
    @pulumi.getter
    def owner(self) -> pulumi.Input['ObjectBucketAclAccessControlPolicyOwnerArgs']:
        """
        Configuration block of the bucket project owner's display organization ID.
        """
        return pulumi.get(self, "owner")

    @owner.setter
    def owner(self, value: pulumi.Input['ObjectBucketAclAccessControlPolicyOwnerArgs']):
        pulumi.set(self, "owner", value)

    @_builtins.property
    @pulumi.getter
    def grants(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ObjectBucketAclAccessControlPolicyGrantArgs']]]]:
        """
        Grant
        """
        return pulumi.get(self, "grants")

    @grants.setter
    def grants(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ObjectBucketAclAccessControlPolicyGrantArgs']]]]):
        pulumi.set(self, "grants", value)


if not MYPY:
    class ObjectBucketAclAccessControlPolicyGrantArgsDict(TypedDict):
        permission: pulumi.Input[_builtins.str]
        """
        Logging permissions assigned to the grantee for the bucket.
        """
        grantee: NotRequired[pulumi.Input['ObjectBucketAclAccessControlPolicyGrantGranteeArgsDict']]
        """
        Configuration block for the project being granted permissions.
        """
elif False:
    ObjectBucketAclAccessControlPolicyGrantArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ObjectBucketAclAccessControlPolicyGrantArgs:
    def __init__(__self__, *,
                 permission: pulumi.Input[_builtins.str],
                 grantee: Optional[pulumi.Input['ObjectBucketAclAccessControlPolicyGrantGranteeArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] permission: Logging permissions assigned to the grantee for the bucket.
        :param pulumi.Input['ObjectBucketAclAccessControlPolicyGrantGranteeArgs'] grantee: Configuration block for the project being granted permissions.
        """
        pulumi.set(__self__, "permission", permission)
        if grantee is not None:
            pulumi.set(__self__, "grantee", grantee)

    @_builtins.property
    @pulumi.getter
    def permission(self) -> pulumi.Input[_builtins.str]:
        """
        Logging permissions assigned to the grantee for the bucket.
        """
        return pulumi.get(self, "permission")

    @permission.setter
    def permission(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "permission", value)

    @_builtins.property
    @pulumi.getter
    def grantee(self) -> Optional[pulumi.Input['ObjectBucketAclAccessControlPolicyGrantGranteeArgs']]:
        """
        Configuration block for the project being granted permissions.
        """
        return pulumi.get(self, "grantee")

    @grantee.setter
    def grantee(self, value: Optional[pulumi.Input['ObjectBucketAclAccessControlPolicyGrantGranteeArgs']]):
        pulumi.set(self, "grantee", value)


if not MYPY:
    class ObjectBucketAclAccessControlPolicyGrantGranteeArgsDict(TypedDict):
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Display name of the grantee to grant access to.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The `region`, `bucket` and `acl` separated by (`/`).
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type of grantee. Valid values: `CanonicalUser`, `Group`
        """
        uri: NotRequired[pulumi.Input[_builtins.str]]
        """
        The uri of the grantee if you are granting permissions to a predefined group.
        """
elif False:
    ObjectBucketAclAccessControlPolicyGrantGranteeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ObjectBucketAclAccessControlPolicyGrantGranteeArgs:
    def __init__(__self__, *,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 uri: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] display_name: Display name of the grantee to grant access to.
        :param pulumi.Input[_builtins.str] id: The `region`, `bucket` and `acl` separated by (`/`).
        :param pulumi.Input[_builtins.str] type: Type of grantee. Valid values: `CanonicalUser`, `Group`
        :param pulumi.Input[_builtins.str] uri: The uri of the grantee if you are granting permissions to a predefined group.
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Display name of the grantee to grant access to.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The `region`, `bucket` and `acl` separated by (`/`).
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type of grantee. Valid values: `CanonicalUser`, `Group`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The uri of the grantee if you are granting permissions to a predefined group.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uri", value)


if not MYPY:
    class ObjectBucketAclAccessControlPolicyOwnerArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The `region`, `bucket` and `acl` separated by (`/`).
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The project ID of the grantee.
        """
elif False:
    ObjectBucketAclAccessControlPolicyOwnerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ObjectBucketAclAccessControlPolicyOwnerArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 display_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: The `region`, `bucket` and `acl` separated by (`/`).
        :param pulumi.Input[_builtins.str] display_name: The project ID of the grantee.
        """
        pulumi.set(__self__, "id", id)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The `region`, `bucket` and `acl` separated by (`/`).
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The project ID of the grantee.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)


if not MYPY:
    class ObjectBucketCorsRuleArgsDict(TypedDict):
        allowed_methods: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Specifies which methods are allowed (`GET`, `PUT`, `POST`, `DELETE` or `HEAD`).
        """
        allowed_origins: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Specifies which origins are allowed.
        """
        allowed_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies which headers are allowed.
        """
        expose_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies header exposure in the response.
        """
        max_age_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies time in seconds that the browser can cache the response for a preflight request.
        """
elif False:
    ObjectBucketCorsRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ObjectBucketCorsRuleArgs:
    def __init__(__self__, *,
                 allowed_methods: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 allowed_origins: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 allowed_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 expose_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 max_age_seconds: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_methods: Specifies which methods are allowed (`GET`, `PUT`, `POST`, `DELETE` or `HEAD`).
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_origins: Specifies which origins are allowed.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_headers: Specifies which headers are allowed.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] expose_headers: Specifies header exposure in the response.
        :param pulumi.Input[_builtins.int] max_age_seconds: Specifies time in seconds that the browser can cache the response for a preflight request.
        """
        pulumi.set(__self__, "allowed_methods", allowed_methods)
        pulumi.set(__self__, "allowed_origins", allowed_origins)
        if allowed_headers is not None:
            pulumi.set(__self__, "allowed_headers", allowed_headers)
        if expose_headers is not None:
            pulumi.set(__self__, "expose_headers", expose_headers)
        if max_age_seconds is not None:
            pulumi.set(__self__, "max_age_seconds", max_age_seconds)

    @_builtins.property
    @pulumi.getter(name="allowedMethods")
    def allowed_methods(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Specifies which methods are allowed (`GET`, `PUT`, `POST`, `DELETE` or `HEAD`).
        """
        return pulumi.get(self, "allowed_methods")

    @allowed_methods.setter
    def allowed_methods(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "allowed_methods", value)

    @_builtins.property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Specifies which origins are allowed.
        """
        return pulumi.get(self, "allowed_origins")

    @allowed_origins.setter
    def allowed_origins(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "allowed_origins", value)

    @_builtins.property
    @pulumi.getter(name="allowedHeaders")
    def allowed_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies which headers are allowed.
        """
        return pulumi.get(self, "allowed_headers")

    @allowed_headers.setter
    def allowed_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_headers", value)

    @_builtins.property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies header exposure in the response.
        """
        return pulumi.get(self, "expose_headers")

    @expose_headers.setter
    def expose_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "expose_headers", value)

    @_builtins.property
    @pulumi.getter(name="maxAgeSeconds")
    def max_age_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies time in seconds that the browser can cache the response for a preflight request.
        """
        return pulumi.get(self, "max_age_seconds")

    @max_age_seconds.setter
    def max_age_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_age_seconds", value)


if not MYPY:
    class ObjectBucketLifecycleRuleArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        The element value can be either Enabled or Disabled. If a rule is disabled, Scaleway Object Storage does not perform any of the actions defined in the rule.
        """
        abort_incomplete_multipart_upload_days: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the number of days after initiating a multipart upload when the multipart upload must be completed.

        > **Important:** Avoid using `prefix` for `AbortIncompleteMultipartUpload`, as any incomplete multipart upload will be billed
        """
        expiration: NotRequired[pulumi.Input['ObjectBucketLifecycleRuleExpirationArgsDict']]
        """
        Specifies a period in the object's expire
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unique identifier for the rule. Must be less than or equal to 255 characters in length.
        """
        prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        Object key prefix identifying one or more objects to which the rule applies.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Specifies object tags key and value.
        """
        transitions: NotRequired[pulumi.Input[Sequence[pulumi.Input['ObjectBucketLifecycleRuleTransitionArgsDict']]]]
        """
        Define when objects transition to another storage class
        """
elif False:
    ObjectBucketLifecycleRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ObjectBucketLifecycleRuleArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 abort_incomplete_multipart_upload_days: Optional[pulumi.Input[_builtins.int]] = None,
                 expiration: Optional[pulumi.Input['ObjectBucketLifecycleRuleExpirationArgs']] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 transitions: Optional[pulumi.Input[Sequence[pulumi.Input['ObjectBucketLifecycleRuleTransitionArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: The element value can be either Enabled or Disabled. If a rule is disabled, Scaleway Object Storage does not perform any of the actions defined in the rule.
        :param pulumi.Input[_builtins.int] abort_incomplete_multipart_upload_days: Specifies the number of days after initiating a multipart upload when the multipart upload must be completed.
               
               > **Important:** Avoid using `prefix` for `AbortIncompleteMultipartUpload`, as any incomplete multipart upload will be billed
        :param pulumi.Input['ObjectBucketLifecycleRuleExpirationArgs'] expiration: Specifies a period in the object's expire
        :param pulumi.Input[_builtins.str] id: Unique identifier for the rule. Must be less than or equal to 255 characters in length.
        :param pulumi.Input[_builtins.str] prefix: Object key prefix identifying one or more objects to which the rule applies.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Specifies object tags key and value.
        :param pulumi.Input[Sequence[pulumi.Input['ObjectBucketLifecycleRuleTransitionArgs']]] transitions: Define when objects transition to another storage class
        """
        pulumi.set(__self__, "enabled", enabled)
        if abort_incomplete_multipart_upload_days is not None:
            pulumi.set(__self__, "abort_incomplete_multipart_upload_days", abort_incomplete_multipart_upload_days)
        if expiration is not None:
            pulumi.set(__self__, "expiration", expiration)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if transitions is not None:
            pulumi.set(__self__, "transitions", transitions)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        The element value can be either Enabled or Disabled. If a rule is disabled, Scaleway Object Storage does not perform any of the actions defined in the rule.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="abortIncompleteMultipartUploadDays")
    def abort_incomplete_multipart_upload_days(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the number of days after initiating a multipart upload when the multipart upload must be completed.

        > **Important:** Avoid using `prefix` for `AbortIncompleteMultipartUpload`, as any incomplete multipart upload will be billed
        """
        return pulumi.get(self, "abort_incomplete_multipart_upload_days")

    @abort_incomplete_multipart_upload_days.setter
    def abort_incomplete_multipart_upload_days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "abort_incomplete_multipart_upload_days", value)

    @_builtins.property
    @pulumi.getter
    def expiration(self) -> Optional[pulumi.Input['ObjectBucketLifecycleRuleExpirationArgs']]:
        """
        Specifies a period in the object's expire
        """
        return pulumi.get(self, "expiration")

    @expiration.setter
    def expiration(self, value: Optional[pulumi.Input['ObjectBucketLifecycleRuleExpirationArgs']]):
        pulumi.set(self, "expiration", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unique identifier for the rule. Must be less than or equal to 255 characters in length.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Object key prefix identifying one or more objects to which the rule applies.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Specifies object tags key and value.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter
    def transitions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ObjectBucketLifecycleRuleTransitionArgs']]]]:
        """
        Define when objects transition to another storage class
        """
        return pulumi.get(self, "transitions")

    @transitions.setter
    def transitions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ObjectBucketLifecycleRuleTransitionArgs']]]]):
        pulumi.set(self, "transitions", value)


if not MYPY:
    class ObjectBucketLifecycleRuleExpirationArgsDict(TypedDict):
        days: pulumi.Input[_builtins.int]
        """
        Specifies the number of days after object creation when the specific rule action takes effect.
        """
elif False:
    ObjectBucketLifecycleRuleExpirationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ObjectBucketLifecycleRuleExpirationArgs:
    def __init__(__self__, *,
                 days: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.int] days: Specifies the number of days after object creation when the specific rule action takes effect.
        """
        pulumi.set(__self__, "days", days)

    @_builtins.property
    @pulumi.getter
    def days(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the number of days after object creation when the specific rule action takes effect.
        """
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "days", value)


if not MYPY:
    class ObjectBucketLifecycleRuleTransitionArgsDict(TypedDict):
        storage_class: pulumi.Input[_builtins.str]
        """
        Specifies the Scaleway [storage class](https://www.scaleway.com/en/docs/object-storage/concepts/#storage-class) `STANDARD`, `GLACIER`, `ONEZONE_IA`  to which you want the object to transition.


        > **Important:**  If versioning is enabled, this rule only deletes the current version of an object.
        > **Important:**  If versioning is enabled, this rule only deletes the current version of an object.


        > **Important:**  `ONEZONE_IA` is only available in `fr-par` region. The storage class `GLACIER` is not available in `pl-waw` region.
        > **Important:**  `ONEZONE_IA` is only available in `fr-par` region. The storage class `GLACIER` is not available in `pl-waw` region.
        """
        days: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the number of days after object creation when the specific rule action takes effect.
        """
elif False:
    ObjectBucketLifecycleRuleTransitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ObjectBucketLifecycleRuleTransitionArgs:
    def __init__(__self__, *,
                 storage_class: pulumi.Input[_builtins.str],
                 days: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] storage_class: Specifies the Scaleway [storage class](https://www.scaleway.com/en/docs/object-storage/concepts/#storage-class) `STANDARD`, `GLACIER`, `ONEZONE_IA`  to which you want the object to transition.
               
               
               > **Important:**  If versioning is enabled, this rule only deletes the current version of an object.
               > **Important:**  If versioning is enabled, this rule only deletes the current version of an object.
               
               
               > **Important:**  `ONEZONE_IA` is only available in `fr-par` region. The storage class `GLACIER` is not available in `pl-waw` region.
               > **Important:**  `ONEZONE_IA` is only available in `fr-par` region. The storage class `GLACIER` is not available in `pl-waw` region.
        :param pulumi.Input[_builtins.int] days: Specifies the number of days after object creation when the specific rule action takes effect.
        """
        pulumi.set(__self__, "storage_class", storage_class)
        if days is not None:
            pulumi.set(__self__, "days", days)

    @_builtins.property
    @pulumi.getter(name="storageClass")
    def storage_class(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the Scaleway [storage class](https://www.scaleway.com/en/docs/object-storage/concepts/#storage-class) `STANDARD`, `GLACIER`, `ONEZONE_IA`  to which you want the object to transition.


        > **Important:**  If versioning is enabled, this rule only deletes the current version of an object.
        > **Important:**  If versioning is enabled, this rule only deletes the current version of an object.


        > **Important:**  `ONEZONE_IA` is only available in `fr-par` region. The storage class `GLACIER` is not available in `pl-waw` region.
        > **Important:**  `ONEZONE_IA` is only available in `fr-par` region. The storage class `GLACIER` is not available in `pl-waw` region.
        """
        return pulumi.get(self, "storage_class")

    @storage_class.setter
    def storage_class(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "storage_class", value)

    @_builtins.property
    @pulumi.getter
    def days(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the number of days after object creation when the specific rule action takes effect.
        """
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "days", value)


if not MYPY:
    class ObjectBucketLockConfigurationRuleArgsDict(TypedDict):
        default_retention: pulumi.Input['ObjectBucketLockConfigurationRuleDefaultRetentionArgsDict']
        """
        The default retention for the lock.
        """
elif False:
    ObjectBucketLockConfigurationRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ObjectBucketLockConfigurationRuleArgs:
    def __init__(__self__, *,
                 default_retention: pulumi.Input['ObjectBucketLockConfigurationRuleDefaultRetentionArgs']):
        """
        :param pulumi.Input['ObjectBucketLockConfigurationRuleDefaultRetentionArgs'] default_retention: The default retention for the lock.
        """
        pulumi.set(__self__, "default_retention", default_retention)

    @_builtins.property
    @pulumi.getter(name="defaultRetention")
    def default_retention(self) -> pulumi.Input['ObjectBucketLockConfigurationRuleDefaultRetentionArgs']:
        """
        The default retention for the lock.
        """
        return pulumi.get(self, "default_retention")

    @default_retention.setter
    def default_retention(self, value: pulumi.Input['ObjectBucketLockConfigurationRuleDefaultRetentionArgs']):
        pulumi.set(self, "default_retention", value)


if not MYPY:
    class ObjectBucketLockConfigurationRuleDefaultRetentionArgsDict(TypedDict):
        mode: pulumi.Input[_builtins.str]
        """
        The default object lock retention mode you want to apply to new objects placed in the specified bucket. Valid values are `GOVERNANCE` or `COMPLIANCE`. Refer to the [dedicated documentation](https://www.scaleway.com/en/docs/object-storage/api-cli/object-lock/#retention-modes) for more information on retention modes.
        """
        days: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of days you want to specify for the default retention period.
        """
        years: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of years you want to specify for the default retention period.
        """
elif False:
    ObjectBucketLockConfigurationRuleDefaultRetentionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ObjectBucketLockConfigurationRuleDefaultRetentionArgs:
    def __init__(__self__, *,
                 mode: pulumi.Input[_builtins.str],
                 days: Optional[pulumi.Input[_builtins.int]] = None,
                 years: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] mode: The default object lock retention mode you want to apply to new objects placed in the specified bucket. Valid values are `GOVERNANCE` or `COMPLIANCE`. Refer to the [dedicated documentation](https://www.scaleway.com/en/docs/object-storage/api-cli/object-lock/#retention-modes) for more information on retention modes.
        :param pulumi.Input[_builtins.int] days: The number of days you want to specify for the default retention period.
        :param pulumi.Input[_builtins.int] years: The number of years you want to specify for the default retention period.
        """
        pulumi.set(__self__, "mode", mode)
        if days is not None:
            pulumi.set(__self__, "days", days)
        if years is not None:
            pulumi.set(__self__, "years", years)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> pulumi.Input[_builtins.str]:
        """
        The default object lock retention mode you want to apply to new objects placed in the specified bucket. Valid values are `GOVERNANCE` or `COMPLIANCE`. Refer to the [dedicated documentation](https://www.scaleway.com/en/docs/object-storage/api-cli/object-lock/#retention-modes) for more information on retention modes.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "mode", value)

    @_builtins.property
    @pulumi.getter
    def days(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of days you want to specify for the default retention period.
        """
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "days", value)

    @_builtins.property
    @pulumi.getter
    def years(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of years you want to specify for the default retention period.
        """
        return pulumi.get(self, "years")

    @years.setter
    def years(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "years", value)


if not MYPY:
    class ObjectBucketVersioningArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable versioning. Once you version-enable a bucket, it can never return to an unversioned state. You can, however, suspend versioning on that bucket.
        """
elif False:
    ObjectBucketVersioningArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ObjectBucketVersioningArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Enable versioning. Once you version-enable a bucket, it can never return to an unversioned state. You can, however, suspend versioning on that bucket.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable versioning. Once you version-enable a bucket, it can never return to an unversioned state. You can, however, suspend versioning on that bucket.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class ObjectBucketWebsiteConfigurationErrorDocumentArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        The object key name to use when a 4XX class error occurs.
        """
elif False:
    ObjectBucketWebsiteConfigurationErrorDocumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ObjectBucketWebsiteConfigurationErrorDocumentArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: The object key name to use when a 4XX class error occurs.
        """
        pulumi.set(__self__, "key", key)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The object key name to use when a 4XX class error occurs.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)


if not MYPY:
    class ObjectBucketWebsiteConfigurationIndexDocumentArgsDict(TypedDict):
        suffix: pulumi.Input[_builtins.str]
        """
        A suffix that is appended to a request targeting a specific directory on the website endpoint.

        > **Important:** The suffix must not be empty and must not include a slash character. The routing is not supported.
        """
elif False:
    ObjectBucketWebsiteConfigurationIndexDocumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ObjectBucketWebsiteConfigurationIndexDocumentArgs:
    def __init__(__self__, *,
                 suffix: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] suffix: A suffix that is appended to a request targeting a specific directory on the website endpoint.
               
               > **Important:** The suffix must not be empty and must not include a slash character. The routing is not supported.
        """
        pulumi.set(__self__, "suffix", suffix)

    @_builtins.property
    @pulumi.getter
    def suffix(self) -> pulumi.Input[_builtins.str]:
        """
        A suffix that is appended to a request targeting a specific directory on the website endpoint.

        > **Important:** The suffix must not be empty and must not include a slash character. The routing is not supported.
        """
        return pulumi.get(self, "suffix")

    @suffix.setter
    def suffix(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "suffix", value)


if not MYPY:
    class RedisClusterAclArgsDict(TypedDict):
        ip: pulumi.Input[_builtins.str]
        """
        The IP range to whitelist
        in [CIDR notation](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#CIDR_notation)
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A text describing this rule. Default description: `Allow IP`

        > The `acl` conflict with `private_network`. Only one should be specified.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the IPv4 address resource.
        """
elif False:
    RedisClusterAclArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RedisClusterAclArgs:
    def __init__(__self__, *,
                 ip: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ip: The IP range to whitelist
               in [CIDR notation](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#CIDR_notation)
        :param pulumi.Input[_builtins.str] description: A text describing this rule. Default description: `Allow IP`
               
               > The `acl` conflict with `private_network`. Only one should be specified.
        :param pulumi.Input[_builtins.str] id: The ID of the IPv4 address resource.
        """
        pulumi.set(__self__, "ip", ip)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> pulumi.Input[_builtins.str]:
        """
        The IP range to whitelist
        in [CIDR notation](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#CIDR_notation)
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A text describing this rule. Default description: `Allow IP`

        > The `acl` conflict with `private_network`. Only one should be specified.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the IPv4 address resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class RedisClusterPrivateIpArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[_builtins.str]]
        """
        The private IPv4 address.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the IPv4 address resource.
        """
elif False:
    RedisClusterPrivateIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RedisClusterPrivateIpArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] address: The private IPv4 address.
        :param pulumi.Input[_builtins.str] id: The ID of the IPv4 address resource.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The private IPv4 address.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the IPv4 address resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class RedisClusterPrivateNetworkArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The UUID of the Private Network resource.
        """
        endpoint_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the endpoint.
        """
        ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of IPv4 addresses of the endpoint.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        TCP port of the endpoint.
        """
        service_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Endpoint IPv4 addresses in [CIDR notation](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#CIDR_notation). You must provide at least one IP per node.
        Keep in mind that in cluster mode you cannot edit your Private Network after its creation so if you want to be able to
        scale your cluster horizontally (adding nodes) later, you should provide more IPs than nodes.
        If not set, the IP network address within the private subnet is determined by the IP Address Management (IPAM) service.
        > **Important:** When IPAM is enabled, the IPs specified here will be ignored and should not be provided.

        > The `private_network` conflicts with `acl`. Only one should be specified.

        > **Important:** The way to use Private Networks differs whether you are using Redis in Standalone or cluster mode.

        - Standalone mode (`cluster_size` = 1) : you can attach as many Private Networks as you want (each must be a separate
        block). If you detach your only Private Network, your cluster won't be reachable until you define a new Private or
        Public Network. You can modify your `private_network` and its specs, you can have both a Private and Public Network side
        by side.

        - Cluster mode (`cluster_size` > 2) : you can define a single Private Network as you create your cluster, you won't be
        able to edit or detach it afterward, unless you create another cluster. This also means that, if you are using a static
        configuration (`service_ips`), you won't be able to scale your cluster horizontally (add more nodes) since it would
        require updating the Private Network to add IPs.
        Your `service_ips` must be listed as follows:
        """
        zone: NotRequired[pulumi.Input[_builtins.str]]
        """
        `zone`) The zone in which the
        Redis cluster should be created.
        """
elif False:
    RedisClusterPrivateNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RedisClusterPrivateNetworkArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 endpoint_id: Optional[pulumi.Input[_builtins.str]] = None,
                 ips: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 service_ips: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 zone: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: The UUID of the Private Network resource.
        :param pulumi.Input[_builtins.str] endpoint_id: The ID of the endpoint.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ips: List of IPv4 addresses of the endpoint.
        :param pulumi.Input[_builtins.int] port: TCP port of the endpoint.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] service_ips: Endpoint IPv4 addresses in [CIDR notation](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#CIDR_notation). You must provide at least one IP per node.
               Keep in mind that in cluster mode you cannot edit your Private Network after its creation so if you want to be able to
               scale your cluster horizontally (adding nodes) later, you should provide more IPs than nodes.
               If not set, the IP network address within the private subnet is determined by the IP Address Management (IPAM) service.
               > **Important:** When IPAM is enabled, the IPs specified here will be ignored and should not be provided.
               
               > The `private_network` conflicts with `acl`. Only one should be specified.
               
               > **Important:** The way to use Private Networks differs whether you are using Redis in Standalone or cluster mode.
               
               - Standalone mode (`cluster_size` = 1) : you can attach as many Private Networks as you want (each must be a separate
               block). If you detach your only Private Network, your cluster won't be reachable until you define a new Private or
               Public Network. You can modify your `private_network` and its specs, you can have both a Private and Public Network side
               by side.
               
               - Cluster mode (`cluster_size` > 2) : you can define a single Private Network as you create your cluster, you won't be
               able to edit or detach it afterward, unless you create another cluster. This also means that, if you are using a static
               configuration (`service_ips`), you won't be able to scale your cluster horizontally (add more nodes) since it would
               require updating the Private Network to add IPs.
               Your `service_ips` must be listed as follows:
        :param pulumi.Input[_builtins.str] zone: `zone`) The zone in which the
               Redis cluster should be created.
        """
        pulumi.set(__self__, "id", id)
        if endpoint_id is not None:
            pulumi.set(__self__, "endpoint_id", endpoint_id)
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if service_ips is not None:
            pulumi.set(__self__, "service_ips", service_ips)
        if zone is not None:
            pulumi.set(__self__, "zone", zone)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The UUID of the Private Network resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the endpoint.
        """
        return pulumi.get(self, "endpoint_id")

    @endpoint_id.setter
    def endpoint_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "endpoint_id", value)

    @_builtins.property
    @pulumi.getter
    def ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of IPv4 addresses of the endpoint.
        """
        return pulumi.get(self, "ips")

    @ips.setter
    def ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ips", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        TCP port of the endpoint.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="serviceIps")
    def service_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Endpoint IPv4 addresses in [CIDR notation](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#CIDR_notation). You must provide at least one IP per node.
        Keep in mind that in cluster mode you cannot edit your Private Network after its creation so if you want to be able to
        scale your cluster horizontally (adding nodes) later, you should provide more IPs than nodes.
        If not set, the IP network address within the private subnet is determined by the IP Address Management (IPAM) service.
        > **Important:** When IPAM is enabled, the IPs specified here will be ignored and should not be provided.

        > The `private_network` conflicts with `acl`. Only one should be specified.

        > **Important:** The way to use Private Networks differs whether you are using Redis in Standalone or cluster mode.

        - Standalone mode (`cluster_size` = 1) : you can attach as many Private Networks as you want (each must be a separate
        block). If you detach your only Private Network, your cluster won't be reachable until you define a new Private or
        Public Network. You can modify your `private_network` and its specs, you can have both a Private and Public Network side
        by side.

        - Cluster mode (`cluster_size` > 2) : you can define a single Private Network as you create your cluster, you won't be
        able to edit or detach it afterward, unless you create another cluster. This also means that, if you are using a static
        configuration (`service_ips`), you won't be able to scale your cluster horizontally (add more nodes) since it would
        require updating the Private Network to add IPs.
        Your `service_ips` must be listed as follows:
        """
        return pulumi.get(self, "service_ips")

    @service_ips.setter
    def service_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "service_ips", value)

    @_builtins.property
    @pulumi.getter
    def zone(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        `zone`) The zone in which the
        Redis cluster should be created.
        """
        return pulumi.get(self, "zone")

    @zone.setter
    def zone(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "zone", value)


if not MYPY:
    class RedisClusterPublicNetworkArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the IPv4 address resource.
        """
        ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of IPv4 addresses of the endpoint.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        TCP port of the endpoint.
        """
elif False:
    RedisClusterPublicNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RedisClusterPublicNetworkArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 ips: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the IPv4 address resource.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ips: List of IPv4 addresses of the endpoint.
        :param pulumi.Input[_builtins.int] port: TCP port of the endpoint.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the IPv4 address resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of IPv4 addresses of the endpoint.
        """
        return pulumi.get(self, "ips")

    @ips.setter
    def ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ips", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        TCP port of the endpoint.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class SecretEphemeralPolicyArgsDict(TypedDict):
        action: pulumi.Input[_builtins.str]
        """
        Action to perform when the version of a secret expires. Available values can be found in [SDK constants](https://pkg.go.dev/github.com/scaleway/scaleway-sdk-go@master/api/secret/v1beta1#pkg-constants).
        """
        expires_once_accessed: NotRequired[pulumi.Input[_builtins.bool]]
        """
        True if the secret version expires after a single user access.
        """
        ttl: NotRequired[pulumi.Input[_builtins.str]]
        """
        Time frame, from one second and up to one year, during which the secret's versions are valid. Has to be specified in [Go Duration format](https://pkg.go.dev/time#ParseDuration) (ex: "30m", "24h").
        """
elif False:
    SecretEphemeralPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecretEphemeralPolicyArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[_builtins.str],
                 expires_once_accessed: Optional[pulumi.Input[_builtins.bool]] = None,
                 ttl: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] action: Action to perform when the version of a secret expires. Available values can be found in [SDK constants](https://pkg.go.dev/github.com/scaleway/scaleway-sdk-go@master/api/secret/v1beta1#pkg-constants).
        :param pulumi.Input[_builtins.bool] expires_once_accessed: True if the secret version expires after a single user access.
        :param pulumi.Input[_builtins.str] ttl: Time frame, from one second and up to one year, during which the secret's versions are valid. Has to be specified in [Go Duration format](https://pkg.go.dev/time#ParseDuration) (ex: "30m", "24h").
        """
        pulumi.set(__self__, "action", action)
        if expires_once_accessed is not None:
            pulumi.set(__self__, "expires_once_accessed", expires_once_accessed)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @_builtins.property
    @pulumi.getter
    def action(self) -> pulumi.Input[_builtins.str]:
        """
        Action to perform when the version of a secret expires. Available values can be found in [SDK constants](https://pkg.go.dev/github.com/scaleway/scaleway-sdk-go@master/api/secret/v1beta1#pkg-constants).
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter(name="expiresOnceAccessed")
    def expires_once_accessed(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        True if the secret version expires after a single user access.
        """
        return pulumi.get(self, "expires_once_accessed")

    @expires_once_accessed.setter
    def expires_once_accessed(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "expires_once_accessed", value)

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Time frame, from one second and up to one year, during which the secret's versions are valid. Has to be specified in [Go Duration format](https://pkg.go.dev/time#ParseDuration) (ex: "30m", "24h").
        """
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ttl", value)


if not MYPY:
    class SecretVersionArgsDict(TypedDict):
        created_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Date and time of the secret's creation (in RFC 3339 format).
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of the secret (e.g. `my-new-description`).
        """
        latest: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Returns true if the version is the latest.
        """
        revision: NotRequired[pulumi.Input[_builtins.str]]
        """
        The revision of secret version
        """
        secret_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The secret ID associated with this version
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        The status of the secret.
        """
        updated_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Date and time of the secret's last update (in RFC 3339 format).
        """
elif False:
    SecretVersionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecretVersionArgs:
    def __init__(__self__, *,
                 created_at: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 latest: Optional[pulumi.Input[_builtins.bool]] = None,
                 revision: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_id: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_at: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] created_at: Date and time of the secret's creation (in RFC 3339 format).
        :param pulumi.Input[_builtins.str] description: Description of the secret (e.g. `my-new-description`).
        :param pulumi.Input[_builtins.bool] latest: Returns true if the version is the latest.
        :param pulumi.Input[_builtins.str] revision: The revision of secret version
        :param pulumi.Input[_builtins.str] secret_id: The secret ID associated with this version
        :param pulumi.Input[_builtins.str] status: The status of the secret.
        :param pulumi.Input[_builtins.str] updated_at: Date and time of the secret's last update (in RFC 3339 format).
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if latest is not None:
            pulumi.set(__self__, "latest", latest)
        if revision is not None:
            pulumi.set(__self__, "revision", revision)
        if secret_id is not None:
            pulumi.set(__self__, "secret_id", secret_id)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Date and time of the secret's creation (in RFC 3339 format).
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of the secret (e.g. `my-new-description`).
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def latest(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Returns true if the version is the latest.
        """
        return pulumi.get(self, "latest")

    @latest.setter
    def latest(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "latest", value)

    @_builtins.property
    @pulumi.getter
    def revision(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The revision of secret version
        """
        return pulumi.get(self, "revision")

    @revision.setter
    def revision(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "revision", value)

    @_builtins.property
    @pulumi.getter(name="secretId")
    def secret_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The secret ID associated with this version
        """
        return pulumi.get(self, "secret_id")

    @secret_id.setter
    def secret_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_id", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The status of the secret.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Date and time of the secret's last update (in RFC 3339 format).
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_at", value)


if not MYPY:
    class TemDomainReputationArgsDict(TypedDict):
        previous_score: NotRequired[pulumi.Input[_builtins.int]]
        """
        The previously-calculated domain's reputation score.
        """
        previous_scored_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time and date the previous reputation score was calculated.
        """
        score: NotRequired[pulumi.Input[_builtins.int]]
        """
        A range from 0 to 100 that determines your domain's reputation score.
        """
        scored_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time and date the score was calculated.
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        The status of the domain's reputation.
        """
elif False:
    TemDomainReputationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemDomainReputationArgs:
    def __init__(__self__, *,
                 previous_score: Optional[pulumi.Input[_builtins.int]] = None,
                 previous_scored_at: Optional[pulumi.Input[_builtins.str]] = None,
                 score: Optional[pulumi.Input[_builtins.int]] = None,
                 scored_at: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] previous_score: The previously-calculated domain's reputation score.
        :param pulumi.Input[_builtins.str] previous_scored_at: The time and date the previous reputation score was calculated.
        :param pulumi.Input[_builtins.int] score: A range from 0 to 100 that determines your domain's reputation score.
        :param pulumi.Input[_builtins.str] scored_at: The time and date the score was calculated.
        :param pulumi.Input[_builtins.str] status: The status of the domain's reputation.
        """
        if previous_score is not None:
            pulumi.set(__self__, "previous_score", previous_score)
        if previous_scored_at is not None:
            pulumi.set(__self__, "previous_scored_at", previous_scored_at)
        if score is not None:
            pulumi.set(__self__, "score", score)
        if scored_at is not None:
            pulumi.set(__self__, "scored_at", scored_at)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="previousScore")
    def previous_score(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The previously-calculated domain's reputation score.
        """
        return pulumi.get(self, "previous_score")

    @previous_score.setter
    def previous_score(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "previous_score", value)

    @_builtins.property
    @pulumi.getter(name="previousScoredAt")
    def previous_scored_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time and date the previous reputation score was calculated.
        """
        return pulumi.get(self, "previous_scored_at")

    @previous_scored_at.setter
    def previous_scored_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "previous_scored_at", value)

    @_builtins.property
    @pulumi.getter
    def score(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        A range from 0 to 100 that determines your domain's reputation score.
        """
        return pulumi.get(self, "score")

    @score.setter
    def score(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "score", value)

    @_builtins.property
    @pulumi.getter(name="scoredAt")
    def scored_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time and date the score was calculated.
        """
        return pulumi.get(self, "scored_at")

    @scored_at.setter
    def scored_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scored_at", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The status of the domain's reputation.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class VpcGatewayNetworkIpamConfigArgsDict(TypedDict):
        ipam_ip_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Use this IPAM-booked IP ID as the Gateway's IP in this Private Network.
        """
        push_default_route: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Defines whether to enable the default route on the GatewayNetwork.
        """
elif False:
    VpcGatewayNetworkIpamConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcGatewayNetworkIpamConfigArgs:
    def __init__(__self__, *,
                 ipam_ip_id: Optional[pulumi.Input[_builtins.str]] = None,
                 push_default_route: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] ipam_ip_id: Use this IPAM-booked IP ID as the Gateway's IP in this Private Network.
        :param pulumi.Input[_builtins.bool] push_default_route: Defines whether to enable the default route on the GatewayNetwork.
        """
        if ipam_ip_id is not None:
            pulumi.set(__self__, "ipam_ip_id", ipam_ip_id)
        if push_default_route is not None:
            pulumi.set(__self__, "push_default_route", push_default_route)

    @_builtins.property
    @pulumi.getter(name="ipamIpId")
    def ipam_ip_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Use this IPAM-booked IP ID as the Gateway's IP in this Private Network.
        """
        return pulumi.get(self, "ipam_ip_id")

    @ipam_ip_id.setter
    def ipam_ip_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ipam_ip_id", value)

    @_builtins.property
    @pulumi.getter(name="pushDefaultRoute")
    def push_default_route(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Defines whether to enable the default route on the GatewayNetwork.
        """
        return pulumi.get(self, "push_default_route")

    @push_default_route.setter
    def push_default_route(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "push_default_route", value)


if not MYPY:
    class VpcGatewayNetworkPrivateIpArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[_builtins.str]]
        """
        The private IPv4 address.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the IPv4 address resource.
        """
elif False:
    VpcGatewayNetworkPrivateIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcGatewayNetworkPrivateIpArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] address: The private IPv4 address.
        :param pulumi.Input[_builtins.str] id: The ID of the IPv4 address resource.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The private IPv4 address.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the IPv4 address resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class VpcPrivateNetworkIpv4SubnetArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[_builtins.str]]
        """
        The network address of the subnet in hexadecimal notation, e.g., '2001:db8::' for a '2001:db8::/64' subnet.
        """
        created_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        The date and time of the creation of the subnet.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The subnet ID.
        """
        prefix_length: NotRequired[pulumi.Input[_builtins.int]]
        """
        The length of the network prefix, e.g., 64 for a 'ffff:ffff:ffff:ffff::' mask.
        """
        subnet: NotRequired[pulumi.Input[_builtins.str]]
        """
        The subnet CIDR.
        """
        subnet_mask: NotRequired[pulumi.Input[_builtins.str]]
        """
        The subnet mask expressed in dotted decimal notation, e.g., '255.255.255.0' for a /24 subnet
        """
        updated_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        The date and time of the last update of the subnet.
        """
elif False:
    VpcPrivateNetworkIpv4SubnetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcPrivateNetworkIpv4SubnetArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[_builtins.str]] = None,
                 created_at: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 prefix_length: Optional[pulumi.Input[_builtins.int]] = None,
                 subnet: Optional[pulumi.Input[_builtins.str]] = None,
                 subnet_mask: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_at: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] address: The network address of the subnet in hexadecimal notation, e.g., '2001:db8::' for a '2001:db8::/64' subnet.
        :param pulumi.Input[_builtins.str] created_at: The date and time of the creation of the subnet.
        :param pulumi.Input[_builtins.str] id: The subnet ID.
        :param pulumi.Input[_builtins.int] prefix_length: The length of the network prefix, e.g., 64 for a 'ffff:ffff:ffff:ffff::' mask.
        :param pulumi.Input[_builtins.str] subnet: The subnet CIDR.
        :param pulumi.Input[_builtins.str] subnet_mask: The subnet mask expressed in dotted decimal notation, e.g., '255.255.255.0' for a /24 subnet
        :param pulumi.Input[_builtins.str] updated_at: The date and time of the last update of the subnet.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if subnet is not None:
            pulumi.set(__self__, "subnet", subnet)
        if subnet_mask is not None:
            pulumi.set(__self__, "subnet_mask", subnet_mask)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The network address of the subnet in hexadecimal notation, e.g., '2001:db8::' for a '2001:db8::/64' subnet.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The date and time of the creation of the subnet.
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The subnet ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The length of the network prefix, e.g., 64 for a 'ffff:ffff:ffff:ffff::' mask.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "prefix_length", value)

    @_builtins.property
    @pulumi.getter
    def subnet(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The subnet CIDR.
        """
        return pulumi.get(self, "subnet")

    @subnet.setter
    def subnet(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subnet", value)

    @_builtins.property
    @pulumi.getter(name="subnetMask")
    def subnet_mask(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The subnet mask expressed in dotted decimal notation, e.g., '255.255.255.0' for a /24 subnet
        """
        return pulumi.get(self, "subnet_mask")

    @subnet_mask.setter
    def subnet_mask(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subnet_mask", value)

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The date and time of the last update of the subnet.
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_at", value)


if not MYPY:
    class VpcPrivateNetworkIpv6SubnetArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[_builtins.str]]
        """
        The network address of the subnet in hexadecimal notation, e.g., '2001:db8::' for a '2001:db8::/64' subnet.
        """
        created_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        The date and time of the creation of the subnet.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The subnet ID.
        """
        prefix_length: NotRequired[pulumi.Input[_builtins.int]]
        """
        The length of the network prefix, e.g., 64 for a 'ffff:ffff:ffff:ffff::' mask.
        """
        subnet: NotRequired[pulumi.Input[_builtins.str]]
        """
        The subnet CIDR.
        """
        subnet_mask: NotRequired[pulumi.Input[_builtins.str]]
        """
        The subnet mask expressed in dotted decimal notation, e.g., '255.255.255.0' for a /24 subnet
        """
        updated_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        The date and time of the last update of the subnet.
        """
elif False:
    VpcPrivateNetworkIpv6SubnetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcPrivateNetworkIpv6SubnetArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[_builtins.str]] = None,
                 created_at: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 prefix_length: Optional[pulumi.Input[_builtins.int]] = None,
                 subnet: Optional[pulumi.Input[_builtins.str]] = None,
                 subnet_mask: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_at: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] address: The network address of the subnet in hexadecimal notation, e.g., '2001:db8::' for a '2001:db8::/64' subnet.
        :param pulumi.Input[_builtins.str] created_at: The date and time of the creation of the subnet.
        :param pulumi.Input[_builtins.str] id: The subnet ID.
        :param pulumi.Input[_builtins.int] prefix_length: The length of the network prefix, e.g., 64 for a 'ffff:ffff:ffff:ffff::' mask.
        :param pulumi.Input[_builtins.str] subnet: The subnet CIDR.
        :param pulumi.Input[_builtins.str] subnet_mask: The subnet mask expressed in dotted decimal notation, e.g., '255.255.255.0' for a /24 subnet
        :param pulumi.Input[_builtins.str] updated_at: The date and time of the last update of the subnet.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if subnet is not None:
            pulumi.set(__self__, "subnet", subnet)
        if subnet_mask is not None:
            pulumi.set(__self__, "subnet_mask", subnet_mask)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The network address of the subnet in hexadecimal notation, e.g., '2001:db8::' for a '2001:db8::/64' subnet.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The date and time of the creation of the subnet.
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The subnet ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The length of the network prefix, e.g., 64 for a 'ffff:ffff:ffff:ffff::' mask.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "prefix_length", value)

    @_builtins.property
    @pulumi.getter
    def subnet(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The subnet CIDR.
        """
        return pulumi.get(self, "subnet")

    @subnet.setter
    def subnet(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subnet", value)

    @_builtins.property
    @pulumi.getter(name="subnetMask")
    def subnet_mask(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The subnet mask expressed in dotted decimal notation, e.g., '255.255.255.0' for a /24 subnet
        """
        return pulumi.get(self, "subnet_mask")

    @subnet_mask.setter
    def subnet_mask(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subnet_mask", value)

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The date and time of the last update of the subnet.
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_at", value)


if not MYPY:
    class WebhostingCpanelUrlArgsDict(TypedDict):
        dashboard: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL of the Dashboard.
        """
        webmail: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL of the Webmail interface.
        """
elif False:
    WebhostingCpanelUrlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebhostingCpanelUrlArgs:
    def __init__(__self__, *,
                 dashboard: Optional[pulumi.Input[_builtins.str]] = None,
                 webmail: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] dashboard: The URL of the Dashboard.
        :param pulumi.Input[_builtins.str] webmail: The URL of the Webmail interface.
        """
        if dashboard is not None:
            pulumi.set(__self__, "dashboard", dashboard)
        if webmail is not None:
            pulumi.set(__self__, "webmail", webmail)

    @_builtins.property
    @pulumi.getter
    def dashboard(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL of the Dashboard.
        """
        return pulumi.get(self, "dashboard")

    @dashboard.setter
    def dashboard(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dashboard", value)

    @_builtins.property
    @pulumi.getter
    def webmail(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL of the Webmail interface.
        """
        return pulumi.get(self, "webmail")

    @webmail.setter
    def webmail(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "webmail", value)


if not MYPY:
    class WebhostingNameServerArgsDict(TypedDict):
        hostname: NotRequired[pulumi.Input[_builtins.str]]
        """
        Hostname of the server
        """
        is_default: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether or not the webhosting is the default one
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        The hosting status.
        """
elif False:
    WebhostingNameServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebhostingNameServerArgs:
    def __init__(__self__, *,
                 hostname: Optional[pulumi.Input[_builtins.str]] = None,
                 is_default: Optional[pulumi.Input[_builtins.bool]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] hostname: Hostname of the server
        :param pulumi.Input[_builtins.bool] is_default: Whether or not the webhosting is the default one
        :param pulumi.Input[_builtins.str] status: The hosting status.
        """
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if is_default is not None:
            pulumi.set(__self__, "is_default", is_default)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Hostname of the server
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether or not the webhosting is the default one
        """
        return pulumi.get(self, "is_default")

    @is_default.setter
    def is_default(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_default", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The hosting status.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class WebhostingOptionArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The option ID.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The option name.
        """
elif False:
    WebhostingOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebhostingOptionArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: The option ID.
        :param pulumi.Input[_builtins.str] name: The option name.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The option ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The option name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebhostingRecordArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The option name.
        """
        priority: NotRequired[pulumi.Input[_builtins.int]]
        """
        Priority of DNS records associated with the webhosting.
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        The hosting status.
        """
        ttl: NotRequired[pulumi.Input[_builtins.int]]
        """
        Time to live in seconds of the record
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type of the DNS record
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Value of the DNS record
        """
elif False:
    WebhostingRecordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebhostingRecordArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 priority: Optional[pulumi.Input[_builtins.int]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 ttl: Optional[pulumi.Input[_builtins.int]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The option name.
        :param pulumi.Input[_builtins.int] priority: Priority of DNS records associated with the webhosting.
        :param pulumi.Input[_builtins.str] status: The hosting status.
        :param pulumi.Input[_builtins.int] ttl: Time to live in seconds of the record
        :param pulumi.Input[_builtins.str] type: Type of the DNS record
        :param pulumi.Input[_builtins.str] value: Value of the DNS record
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The option name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Priority of DNS records associated with the webhosting.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The hosting status.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Time to live in seconds of the record
        """
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "ttl", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type of the DNS record
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Value of the DNS record
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetIpamIpResourceArgsDict(TypedDict):
        type: _builtins.str
        """
        The type of the resource the IP is attached to. [Documentation](https://pkg.go.dev/github.com/scaleway/scaleway-sdk-go@master/api/ipam/v1#pkg-constants) with type list.
        """
        id: NotRequired[_builtins.str]
        """
        The ID of the resource that the IP is attached to.
        """
        name: NotRequired[_builtins.str]
        """
        The name of the resource the IP is attached to.
        """
elif False:
    GetIpamIpResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetIpamIpResourceArgs:
    def __init__(__self__, *,
                 type: _builtins.str,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: The type of the resource the IP is attached to. [Documentation](https://pkg.go.dev/github.com/scaleway/scaleway-sdk-go@master/api/ipam/v1#pkg-constants) with type list.
        :param _builtins.str id: The ID of the resource that the IP is attached to.
        :param _builtins.str name: The name of the resource the IP is attached to.
        """
        pulumi.set(__self__, "type", type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of the resource the IP is attached to. [Documentation](https://pkg.go.dev/github.com/scaleway/scaleway-sdk-go@master/api/ipam/v1#pkg-constants) with type list.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: _builtins.str):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The ID of the resource that the IP is attached to.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the resource the IP is attached to.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class GetIpamIpsResourceArgsDict(TypedDict):
        type: _builtins.str
        """
        The type of the attached resource. [Documentation](https://pkg.go.dev/github.com/scaleway/scaleway-sdk-go@master/api/ipam/v1#pkg-constants) with type list.
        """
        id: NotRequired[_builtins.str]
        """
        The ID of the attached resource.
        """
        name: NotRequired[_builtins.str]
        """
        The name of the attached resource.
        """
elif False:
    GetIpamIpsResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetIpamIpsResourceArgs:
    def __init__(__self__, *,
                 type: _builtins.str,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: The type of the attached resource. [Documentation](https://pkg.go.dev/github.com/scaleway/scaleway-sdk-go@master/api/ipam/v1#pkg-constants) with type list.
        :param _builtins.str id: The ID of the attached resource.
        :param _builtins.str name: The name of the attached resource.
        """
        pulumi.set(__self__, "type", type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of the attached resource. [Documentation](https://pkg.go.dev/github.com/scaleway/scaleway-sdk-go@master/api/ipam/v1#pkg-constants) with type list.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: _builtins.str):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The ID of the attached resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the attached resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[_builtins.str]):
        pulumi.set(self, "name", value)


