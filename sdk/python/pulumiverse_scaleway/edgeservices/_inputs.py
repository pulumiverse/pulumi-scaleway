# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'BackendStageLbBackendConfigArgs',
    'BackendStageLbBackendConfigArgsDict',
    'BackendStageLbBackendConfigLbConfigArgs',
    'BackendStageLbBackendConfigLbConfigArgsDict',
    'BackendStageS3BackendConfigArgs',
    'BackendStageS3BackendConfigArgsDict',
    'CacheStagePurgeRequestArgs',
    'CacheStagePurgeRequestArgsDict',
    'RouteStageRuleArgs',
    'RouteStageRuleArgsDict',
    'RouteStageRuleRuleHttpMatchArgs',
    'RouteStageRuleRuleHttpMatchArgsDict',
    'RouteStageRuleRuleHttpMatchPathFilterArgs',
    'RouteStageRuleRuleHttpMatchPathFilterArgsDict',
    'TlsStageSecretArgs',
    'TlsStageSecretArgsDict',
]

MYPY = False

if not MYPY:
    class BackendStageLbBackendConfigArgsDict(TypedDict):
        lb_config: NotRequired[pulumi.Input['BackendStageLbBackendConfigLbConfigArgsDict']]
        """
        The Load Balancer config.
        """
elif False:
    BackendStageLbBackendConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BackendStageLbBackendConfigArgs:
    def __init__(__self__, *,
                 lb_config: Optional[pulumi.Input['BackendStageLbBackendConfigLbConfigArgs']] = None):
        """
        :param pulumi.Input['BackendStageLbBackendConfigLbConfigArgs'] lb_config: The Load Balancer config.
        """
        if lb_config is not None:
            pulumi.set(__self__, "lb_config", lb_config)

    @_builtins.property
    @pulumi.getter(name="lbConfig")
    def lb_config(self) -> Optional[pulumi.Input['BackendStageLbBackendConfigLbConfigArgs']]:
        """
        The Load Balancer config.
        """
        return pulumi.get(self, "lb_config")

    @lb_config.setter
    def lb_config(self, value: Optional[pulumi.Input['BackendStageLbBackendConfigLbConfigArgs']]):
        pulumi.set(self, "lb_config", value)


if not MYPY:
    class BackendStageLbBackendConfigLbConfigArgsDict(TypedDict):
        domain_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Fully Qualified Domain Name (in the format subdomain.example.com) to use in HTTP requests sent towards your Load Balancer.
        """
        frontend_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the frontend.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the Load Balancer.
        """
        is_ssl: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Defines whether the Load Balancer's frontend handles SSL connections.
        """
        zone: NotRequired[pulumi.Input[_builtins.str]]
        """
        `zone`) The zone of the Load Balancer.
        """
elif False:
    BackendStageLbBackendConfigLbConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BackendStageLbBackendConfigLbConfigArgs:
    def __init__(__self__, *,
                 domain_name: Optional[pulumi.Input[_builtins.str]] = None,
                 frontend_id: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 is_ssl: Optional[pulumi.Input[_builtins.bool]] = None,
                 zone: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] domain_name: The Fully Qualified Domain Name (in the format subdomain.example.com) to use in HTTP requests sent towards your Load Balancer.
        :param pulumi.Input[_builtins.str] frontend_id: The ID of the frontend.
        :param pulumi.Input[_builtins.str] id: The ID of the Load Balancer.
        :param pulumi.Input[_builtins.bool] is_ssl: Defines whether the Load Balancer's frontend handles SSL connections.
        :param pulumi.Input[_builtins.str] zone: `zone`) The zone of the Load Balancer.
        """
        if domain_name is not None:
            pulumi.set(__self__, "domain_name", domain_name)
        if frontend_id is not None:
            pulumi.set(__self__, "frontend_id", frontend_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_ssl is not None:
            pulumi.set(__self__, "is_ssl", is_ssl)
        if zone is not None:
            pulumi.set(__self__, "zone", zone)

    @_builtins.property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Fully Qualified Domain Name (in the format subdomain.example.com) to use in HTTP requests sent towards your Load Balancer.
        """
        return pulumi.get(self, "domain_name")

    @domain_name.setter
    def domain_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "domain_name", value)

    @_builtins.property
    @pulumi.getter(name="frontendId")
    def frontend_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the frontend.
        """
        return pulumi.get(self, "frontend_id")

    @frontend_id.setter
    def frontend_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "frontend_id", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the Load Balancer.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="isSsl")
    def is_ssl(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Defines whether the Load Balancer's frontend handles SSL connections.
        """
        return pulumi.get(self, "is_ssl")

    @is_ssl.setter
    def is_ssl(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_ssl", value)

    @_builtins.property
    @pulumi.getter
    def zone(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        `zone`) The zone of the Load Balancer.
        """
        return pulumi.get(self, "zone")

    @zone.setter
    def zone(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "zone", value)


if not MYPY:
    class BackendStageS3BackendConfigArgsDict(TypedDict):
        bucket_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the Bucket.
        """
        bucket_region: NotRequired[pulumi.Input[_builtins.str]]
        """
        The region of the Bucket.
        """
        is_website: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Defines whether the bucket website feature is enabled.
        """
elif False:
    BackendStageS3BackendConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BackendStageS3BackendConfigArgs:
    def __init__(__self__, *,
                 bucket_name: Optional[pulumi.Input[_builtins.str]] = None,
                 bucket_region: Optional[pulumi.Input[_builtins.str]] = None,
                 is_website: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] bucket_name: The name of the Bucket.
        :param pulumi.Input[_builtins.str] bucket_region: The region of the Bucket.
        :param pulumi.Input[_builtins.bool] is_website: Defines whether the bucket website feature is enabled.
        """
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if bucket_region is not None:
            pulumi.set(__self__, "bucket_region", bucket_region)
        if is_website is not None:
            pulumi.set(__self__, "is_website", is_website)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the Bucket.
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket_name", value)

    @_builtins.property
    @pulumi.getter(name="bucketRegion")
    def bucket_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The region of the Bucket.
        """
        return pulumi.get(self, "bucket_region")

    @bucket_region.setter
    def bucket_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket_region", value)

    @_builtins.property
    @pulumi.getter(name="isWebsite")
    def is_website(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Defines whether the bucket website feature is enabled.
        """
        return pulumi.get(self, "is_website")

    @is_website.setter
    def is_website(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_website", value)


if not MYPY:
    class CacheStagePurgeRequestArgsDict(TypedDict):
        all: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Defines whether to purge all content.
        """
        assets: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The list of asserts to purge.
        """
        pipeline_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The pipeline ID in which the purge request will be created.
        """
elif False:
    CacheStagePurgeRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CacheStagePurgeRequestArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input[_builtins.bool]] = None,
                 assets: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 pipeline_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] all: Defines whether to purge all content.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] assets: The list of asserts to purge.
        :param pulumi.Input[_builtins.str] pipeline_id: The pipeline ID in which the purge request will be created.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if assets is not None:
            pulumi.set(__self__, "assets", assets)
        if pipeline_id is not None:
            pulumi.set(__self__, "pipeline_id", pipeline_id)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Defines whether to purge all content.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter
    def assets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The list of asserts to purge.
        """
        return pulumi.get(self, "assets")

    @assets.setter
    def assets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "assets", value)

    @_builtins.property
    @pulumi.getter(name="pipelineId")
    def pipeline_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The pipeline ID in which the purge request will be created.
        """
        return pulumi.get(self, "pipeline_id")

    @pipeline_id.setter
    def pipeline_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "pipeline_id", value)


if not MYPY:
    class RouteStageRuleArgsDict(TypedDict):
        backend_stage_id: pulumi.Input[_builtins.str]
        """
        The ID of the backend stage that requests matching the rule should be forwarded to.
        """
        rule_http_match: NotRequired[pulumi.Input['RouteStageRuleRuleHttpMatchArgsDict']]
        """
        The rule condition to be matched. Requests matching the condition defined here will be directly forwarded to the backend specified by the `backend_stage_id` field. Requests that do not match will be checked by the next rule's condition.
        """
elif False:
    RouteStageRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteStageRuleArgs:
    def __init__(__self__, *,
                 backend_stage_id: pulumi.Input[_builtins.str],
                 rule_http_match: Optional[pulumi.Input['RouteStageRuleRuleHttpMatchArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] backend_stage_id: The ID of the backend stage that requests matching the rule should be forwarded to.
        :param pulumi.Input['RouteStageRuleRuleHttpMatchArgs'] rule_http_match: The rule condition to be matched. Requests matching the condition defined here will be directly forwarded to the backend specified by the `backend_stage_id` field. Requests that do not match will be checked by the next rule's condition.
        """
        pulumi.set(__self__, "backend_stage_id", backend_stage_id)
        if rule_http_match is not None:
            pulumi.set(__self__, "rule_http_match", rule_http_match)

    @_builtins.property
    @pulumi.getter(name="backendStageId")
    def backend_stage_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the backend stage that requests matching the rule should be forwarded to.
        """
        return pulumi.get(self, "backend_stage_id")

    @backend_stage_id.setter
    def backend_stage_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "backend_stage_id", value)

    @_builtins.property
    @pulumi.getter(name="ruleHttpMatch")
    def rule_http_match(self) -> Optional[pulumi.Input['RouteStageRuleRuleHttpMatchArgs']]:
        """
        The rule condition to be matched. Requests matching the condition defined here will be directly forwarded to the backend specified by the `backend_stage_id` field. Requests that do not match will be checked by the next rule's condition.
        """
        return pulumi.get(self, "rule_http_match")

    @rule_http_match.setter
    def rule_http_match(self, value: Optional[pulumi.Input['RouteStageRuleRuleHttpMatchArgs']]):
        pulumi.set(self, "rule_http_match", value)


if not MYPY:
    class RouteStageRuleRuleHttpMatchArgsDict(TypedDict):
        method_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        HTTP methods to filter for. A request using any of these methods will be considered to match the rule. Possible values are `get`, `post`, `put`, `patch`, `delete`, `head`, `options`. All methods will match if none is provided.
        """
        path_filter: NotRequired[pulumi.Input['RouteStageRuleRuleHttpMatchPathFilterArgsDict']]
        """
        HTTP URL path to filter for. A request whose path matches the given filter will be considered to match the rule. All paths will match if none is provided.
        """
elif False:
    RouteStageRuleRuleHttpMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteStageRuleRuleHttpMatchArgs:
    def __init__(__self__, *,
                 method_filters: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 path_filter: Optional[pulumi.Input['RouteStageRuleRuleHttpMatchPathFilterArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] method_filters: HTTP methods to filter for. A request using any of these methods will be considered to match the rule. Possible values are `get`, `post`, `put`, `patch`, `delete`, `head`, `options`. All methods will match if none is provided.
        :param pulumi.Input['RouteStageRuleRuleHttpMatchPathFilterArgs'] path_filter: HTTP URL path to filter for. A request whose path matches the given filter will be considered to match the rule. All paths will match if none is provided.
        """
        if method_filters is not None:
            pulumi.set(__self__, "method_filters", method_filters)
        if path_filter is not None:
            pulumi.set(__self__, "path_filter", path_filter)

    @_builtins.property
    @pulumi.getter(name="methodFilters")
    def method_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        HTTP methods to filter for. A request using any of these methods will be considered to match the rule. Possible values are `get`, `post`, `put`, `patch`, `delete`, `head`, `options`. All methods will match if none is provided.
        """
        return pulumi.get(self, "method_filters")

    @method_filters.setter
    def method_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "method_filters", value)

    @_builtins.property
    @pulumi.getter(name="pathFilter")
    def path_filter(self) -> Optional[pulumi.Input['RouteStageRuleRuleHttpMatchPathFilterArgs']]:
        """
        HTTP URL path to filter for. A request whose path matches the given filter will be considered to match the rule. All paths will match if none is provided.
        """
        return pulumi.get(self, "path_filter")

    @path_filter.setter
    def path_filter(self, value: Optional[pulumi.Input['RouteStageRuleRuleHttpMatchPathFilterArgs']]):
        pulumi.set(self, "path_filter", value)


if not MYPY:
    class RouteStageRuleRuleHttpMatchPathFilterArgsDict(TypedDict):
        path_filter_type: pulumi.Input[_builtins.str]
        """
        The type of filter to match for the HTTP URL path. For now, all path filters must be written in regex and use the `regex` type.
        """
        value: pulumi.Input[_builtins.str]
        """
        The value to be matched for the HTTP URL path.
        """
elif False:
    RouteStageRuleRuleHttpMatchPathFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteStageRuleRuleHttpMatchPathFilterArgs:
    def __init__(__self__, *,
                 path_filter_type: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] path_filter_type: The type of filter to match for the HTTP URL path. For now, all path filters must be written in regex and use the `regex` type.
        :param pulumi.Input[_builtins.str] value: The value to be matched for the HTTP URL path.
        """
        pulumi.set(__self__, "path_filter_type", path_filter_type)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="pathFilterType")
    def path_filter_type(self) -> pulumi.Input[_builtins.str]:
        """
        The type of filter to match for the HTTP URL path. For now, all path filters must be written in regex and use the `regex` type.
        """
        return pulumi.get(self, "path_filter_type")

    @path_filter_type.setter
    def path_filter_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "path_filter_type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        The value to be matched for the HTTP URL path.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class TlsStageSecretArgsDict(TypedDict):
        region: NotRequired[pulumi.Input[_builtins.str]]
        """
        The region of the secret.
        """
        secret_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the Secret
        """
elif False:
    TlsStageSecretArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TlsStageSecretArgs:
    def __init__(__self__, *,
                 region: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] region: The region of the secret.
        :param pulumi.Input[_builtins.str] secret_id: The ID of the Secret
        """
        if region is not None:
            pulumi.set(__self__, "region", region)
        if secret_id is not None:
            pulumi.set(__self__, "secret_id", secret_id)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The region of the secret.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="secretId")
    def secret_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the Secret
        """
        return pulumi.get(self, "secret_id")

    @secret_id.setter
    def secret_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_id", value)


