# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'BackendStageLbBackendConfig',
    'BackendStageLbBackendConfigLbConfig',
    'BackendStageS3BackendConfig',
    'CacheStagePurgeRequest',
    'RouteStageRule',
    'RouteStageRuleRuleHttpMatch',
    'RouteStageRuleRuleHttpMatchPathFilter',
    'TlsStageSecret',
]

@pulumi.output_type
class BackendStageLbBackendConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lbConfig":
            suggest = "lb_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackendStageLbBackendConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackendStageLbBackendConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackendStageLbBackendConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lb_config: Optional['outputs.BackendStageLbBackendConfigLbConfig'] = None):
        """
        :param 'BackendStageLbBackendConfigLbConfigArgs' lb_config: The Load Balancer config.
        """
        if lb_config is not None:
            pulumi.set(__self__, "lb_config", lb_config)

    @_builtins.property
    @pulumi.getter(name="lbConfig")
    def lb_config(self) -> Optional['outputs.BackendStageLbBackendConfigLbConfig']:
        """
        The Load Balancer config.
        """
        return pulumi.get(self, "lb_config")


@pulumi.output_type
class BackendStageLbBackendConfigLbConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "domainName":
            suggest = "domain_name"
        elif key == "frontendId":
            suggest = "frontend_id"
        elif key == "isSsl":
            suggest = "is_ssl"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackendStageLbBackendConfigLbConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackendStageLbBackendConfigLbConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackendStageLbBackendConfigLbConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 domain_name: Optional[_builtins.str] = None,
                 frontend_id: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 is_ssl: Optional[_builtins.bool] = None,
                 zone: Optional[_builtins.str] = None):
        """
        :param _builtins.str domain_name: The Fully Qualified Domain Name (in the format subdomain.example.com) to use in HTTP requests sent towards your Load Balancer.
        :param _builtins.str frontend_id: The ID of the frontend.
        :param _builtins.str id: The ID of the Load Balancer.
        :param _builtins.bool is_ssl: Defines whether the Load Balancer's frontend handles SSL connections.
        :param _builtins.str zone: `zone`) The zone of the Load Balancer.
        """
        if domain_name is not None:
            pulumi.set(__self__, "domain_name", domain_name)
        if frontend_id is not None:
            pulumi.set(__self__, "frontend_id", frontend_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_ssl is not None:
            pulumi.set(__self__, "is_ssl", is_ssl)
        if zone is not None:
            pulumi.set(__self__, "zone", zone)

    @_builtins.property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> Optional[_builtins.str]:
        """
        The Fully Qualified Domain Name (in the format subdomain.example.com) to use in HTTP requests sent towards your Load Balancer.
        """
        return pulumi.get(self, "domain_name")

    @_builtins.property
    @pulumi.getter(name="frontendId")
    def frontend_id(self) -> Optional[_builtins.str]:
        """
        The ID of the frontend.
        """
        return pulumi.get(self, "frontend_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The ID of the Load Balancer.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="isSsl")
    def is_ssl(self) -> Optional[_builtins.bool]:
        """
        Defines whether the Load Balancer's frontend handles SSL connections.
        """
        return pulumi.get(self, "is_ssl")

    @_builtins.property
    @pulumi.getter
    def zone(self) -> Optional[_builtins.str]:
        """
        `zone`) The zone of the Load Balancer.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class BackendStageS3BackendConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "bucketRegion":
            suggest = "bucket_region"
        elif key == "isWebsite":
            suggest = "is_website"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackendStageS3BackendConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackendStageS3BackendConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackendStageS3BackendConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: Optional[_builtins.str] = None,
                 bucket_region: Optional[_builtins.str] = None,
                 is_website: Optional[_builtins.bool] = None):
        """
        :param _builtins.str bucket_name: The name of the Bucket.
        :param _builtins.str bucket_region: The region of the Bucket.
        :param _builtins.bool is_website: Defines whether the bucket website feature is enabled.
        """
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if bucket_region is not None:
            pulumi.set(__self__, "bucket_region", bucket_region)
        if is_website is not None:
            pulumi.set(__self__, "is_website", is_website)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[_builtins.str]:
        """
        The name of the Bucket.
        """
        return pulumi.get(self, "bucket_name")

    @_builtins.property
    @pulumi.getter(name="bucketRegion")
    def bucket_region(self) -> Optional[_builtins.str]:
        """
        The region of the Bucket.
        """
        return pulumi.get(self, "bucket_region")

    @_builtins.property
    @pulumi.getter(name="isWebsite")
    def is_website(self) -> Optional[_builtins.bool]:
        """
        Defines whether the bucket website feature is enabled.
        """
        return pulumi.get(self, "is_website")


@pulumi.output_type
class CacheStagePurgeRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pipelineId":
            suggest = "pipeline_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CacheStagePurgeRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CacheStagePurgeRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CacheStagePurgeRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional[_builtins.bool] = None,
                 assets: Optional[Sequence[_builtins.str]] = None,
                 pipeline_id: Optional[_builtins.str] = None):
        """
        :param _builtins.bool all: Defines whether to purge all content.
        :param Sequence[_builtins.str] assets: The list of asserts to purge.
        :param _builtins.str pipeline_id: The pipeline ID in which the purge request will be created.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if assets is not None:
            pulumi.set(__self__, "assets", assets)
        if pipeline_id is not None:
            pulumi.set(__self__, "pipeline_id", pipeline_id)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[_builtins.bool]:
        """
        Defines whether to purge all content.
        """
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter
    def assets(self) -> Optional[Sequence[_builtins.str]]:
        """
        The list of asserts to purge.
        """
        return pulumi.get(self, "assets")

    @_builtins.property
    @pulumi.getter(name="pipelineId")
    def pipeline_id(self) -> Optional[_builtins.str]:
        """
        The pipeline ID in which the purge request will be created.
        """
        return pulumi.get(self, "pipeline_id")


@pulumi.output_type
class RouteStageRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backendStageId":
            suggest = "backend_stage_id"
        elif key == "ruleHttpMatch":
            suggest = "rule_http_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RouteStageRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RouteStageRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RouteStageRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backend_stage_id: _builtins.str,
                 rule_http_match: Optional['outputs.RouteStageRuleRuleHttpMatch'] = None):
        """
        :param _builtins.str backend_stage_id: The ID of the backend stage that requests matching the rule should be forwarded to.
        :param 'RouteStageRuleRuleHttpMatchArgs' rule_http_match: The rule condition to be matched. Requests matching the condition defined here will be directly forwarded to the backend specified by the `backend_stage_id` field. Requests that do not match will be checked by the next rule's condition.
        """
        pulumi.set(__self__, "backend_stage_id", backend_stage_id)
        if rule_http_match is not None:
            pulumi.set(__self__, "rule_http_match", rule_http_match)

    @_builtins.property
    @pulumi.getter(name="backendStageId")
    def backend_stage_id(self) -> _builtins.str:
        """
        The ID of the backend stage that requests matching the rule should be forwarded to.
        """
        return pulumi.get(self, "backend_stage_id")

    @_builtins.property
    @pulumi.getter(name="ruleHttpMatch")
    def rule_http_match(self) -> Optional['outputs.RouteStageRuleRuleHttpMatch']:
        """
        The rule condition to be matched. Requests matching the condition defined here will be directly forwarded to the backend specified by the `backend_stage_id` field. Requests that do not match will be checked by the next rule's condition.
        """
        return pulumi.get(self, "rule_http_match")


@pulumi.output_type
class RouteStageRuleRuleHttpMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "methodFilters":
            suggest = "method_filters"
        elif key == "pathFilter":
            suggest = "path_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RouteStageRuleRuleHttpMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RouteStageRuleRuleHttpMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RouteStageRuleRuleHttpMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 method_filters: Optional[Sequence[_builtins.str]] = None,
                 path_filter: Optional['outputs.RouteStageRuleRuleHttpMatchPathFilter'] = None):
        """
        :param Sequence[_builtins.str] method_filters: HTTP methods to filter for. A request using any of these methods will be considered to match the rule. Possible values are `get`, `post`, `put`, `patch`, `delete`, `head`, `options`. All methods will match if none is provided.
        :param 'RouteStageRuleRuleHttpMatchPathFilterArgs' path_filter: HTTP URL path to filter for. A request whose path matches the given filter will be considered to match the rule. All paths will match if none is provided.
        """
        if method_filters is not None:
            pulumi.set(__self__, "method_filters", method_filters)
        if path_filter is not None:
            pulumi.set(__self__, "path_filter", path_filter)

    @_builtins.property
    @pulumi.getter(name="methodFilters")
    def method_filters(self) -> Optional[Sequence[_builtins.str]]:
        """
        HTTP methods to filter for. A request using any of these methods will be considered to match the rule. Possible values are `get`, `post`, `put`, `patch`, `delete`, `head`, `options`. All methods will match if none is provided.
        """
        return pulumi.get(self, "method_filters")

    @_builtins.property
    @pulumi.getter(name="pathFilter")
    def path_filter(self) -> Optional['outputs.RouteStageRuleRuleHttpMatchPathFilter']:
        """
        HTTP URL path to filter for. A request whose path matches the given filter will be considered to match the rule. All paths will match if none is provided.
        """
        return pulumi.get(self, "path_filter")


@pulumi.output_type
class RouteStageRuleRuleHttpMatchPathFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pathFilterType":
            suggest = "path_filter_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RouteStageRuleRuleHttpMatchPathFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RouteStageRuleRuleHttpMatchPathFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RouteStageRuleRuleHttpMatchPathFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path_filter_type: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str path_filter_type: The type of filter to match for the HTTP URL path. For now, all path filters must be written in regex and use the `regex` type.
        :param _builtins.str value: The value to be matched for the HTTP URL path.
        """
        pulumi.set(__self__, "path_filter_type", path_filter_type)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="pathFilterType")
    def path_filter_type(self) -> _builtins.str:
        """
        The type of filter to match for the HTTP URL path. For now, all path filters must be written in regex and use the `regex` type.
        """
        return pulumi.get(self, "path_filter_type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The value to be matched for the HTTP URL path.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class TlsStageSecret(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretId":
            suggest = "secret_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TlsStageSecret. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TlsStageSecret.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TlsStageSecret.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 region: Optional[_builtins.str] = None,
                 secret_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str region: The region of the secret.
        :param _builtins.str secret_id: The ID of the Secret
        """
        if region is not None:
            pulumi.set(__self__, "region", region)
        if secret_id is not None:
            pulumi.set(__self__, "secret_id", secret_id)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        The region of the secret.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="secretId")
    def secret_id(self) -> Optional[_builtins.str]:
        """
        The ID of the Secret
        """
        return pulumi.get(self, "secret_id")


