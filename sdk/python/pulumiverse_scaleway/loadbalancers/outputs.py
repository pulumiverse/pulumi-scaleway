# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'AclAction',
    'AclActionRedirect',
    'AclMatch',
    'BackendHealthCheckHttp',
    'BackendHealthCheckHttps',
    'BackendHealthCheckTcp',
    'CertificateCustomCertificate',
    'CertificateLetsencrypt',
    'FrontendAcl',
    'FrontendAclAction',
    'FrontendAclActionRedirect',
    'FrontendAclMatch',
    'LoadBalancerPrivateNetwork',
    'GetAclsAclResult',
    'GetAclsAclActionResult',
    'GetAclsAclActionRedirectResult',
    'GetAclsAclMatchResult',
    'GetBackendHealthCheckHttpResult',
    'GetBackendHealthCheckTcpResult',
    'GetBackendsBackendResult',
    'GetBackendsBackendHealthCheckHttpResult',
    'GetBackendsBackendHealthCheckTcpResult',
    'GetCertificateCustomCertificateResult',
    'GetCertificateLetsencryptResult',
    'GetFrontendAclResult',
    'GetFrontendAclActionResult',
    'GetFrontendAclActionRedirectResult',
    'GetFrontendAclMatchResult',
    'GetFrontendsFrontendResult',
    'GetIpsIpResult',
    'GetLoadBalancerPrivateNetworkResult',
    'GetLoadBalancersLbResult',
    'GetLoadBalancersLbInstanceResult',
    'GetLoadBalancersLbIpResult',
    'GetRoutesRouteResult',
]

@pulumi.output_type
class AclAction(dict):
    def __init__(__self__, *,
                 type: str,
                 redirects: Optional[Sequence['outputs.AclActionRedirect']] = None):
        """
        :param str type: The action type. Possible values are: `allow` or `deny` or `redirect`.
        :param Sequence['AclActionRedirectArgs'] redirects: Redirect parameters when using an ACL with `redirect` action.
        """
        pulumi.set(__self__, "type", type)
        if redirects is not None:
            pulumi.set(__self__, "redirects", redirects)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The action type. Possible values are: `allow` or `deny` or `redirect`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def redirects(self) -> Optional[Sequence['outputs.AclActionRedirect']]:
        """
        Redirect parameters when using an ACL with `redirect` action.
        """
        return pulumi.get(self, "redirects")


@pulumi.output_type
class AclActionRedirect(dict):
    def __init__(__self__, *,
                 code: Optional[int] = None,
                 target: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param int code: The HTTP redirect code to use. Valid values are `301`, `302`, `303`, `307` and `308`.
        :param str target: An URL can be used in case of a location redirect (e.g. `https://scaleway.com` will redirect to this same URL). A scheme name (e.g. `https`, `http`, `ftp`, `git`) will replace the request's original scheme.
        :param str type: The redirect type. Possible values are: `location` or `scheme`.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def code(self) -> Optional[int]:
        """
        The HTTP redirect code to use. Valid values are `301`, `302`, `303`, `307` and `308`.
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def target(self) -> Optional[str]:
        """
        An URL can be used in case of a location redirect (e.g. `https://scaleway.com` will redirect to this same URL). A scheme name (e.g. `https`, `http`, `ftp`, `git`) will replace the request's original scheme.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The redirect type. Possible values are: `location` or `scheme`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class AclMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpFilter":
            suggest = "http_filter"
        elif key == "httpFilterOption":
            suggest = "http_filter_option"
        elif key == "httpFilterValues":
            suggest = "http_filter_values"
        elif key == "ipSubnets":
            suggest = "ip_subnets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AclMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AclMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AclMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_filter: Optional[str] = None,
                 http_filter_option: Optional[str] = None,
                 http_filter_values: Optional[Sequence[str]] = None,
                 invert: Optional[bool] = None,
                 ip_subnets: Optional[Sequence[str]] = None):
        """
        :param str http_filter: The HTTP filter to match. This filter is supported only if your backend protocol has an HTTP forward protocol.
               It extracts the request's URL path, which starts at the first slash and ends before the question mark (without the host part).
               Possible values are: `acl_http_filter_none`, `path_begin`, `path_end`, `http_header_match` or `regex`.
        :param str http_filter_option: If you have `http_filter` at `http_header_match`, you can use this field to filter on the HTTP header's value.
        :param Sequence[str] http_filter_values: A list of possible values to match for the given HTTP filter.
               Keep in mind that in the case of `http_header_match` the HTTP header field name is case insensitive.
        :param bool invert: If set to `true`, the condition will be of type "unless".
        :param Sequence[str] ip_subnets: A list of IPs, or CIDR v4/v6 addresses of the session client, to match.
        """
        if http_filter is not None:
            pulumi.set(__self__, "http_filter", http_filter)
        if http_filter_option is not None:
            pulumi.set(__self__, "http_filter_option", http_filter_option)
        if http_filter_values is not None:
            pulumi.set(__self__, "http_filter_values", http_filter_values)
        if invert is not None:
            pulumi.set(__self__, "invert", invert)
        if ip_subnets is not None:
            pulumi.set(__self__, "ip_subnets", ip_subnets)

    @property
    @pulumi.getter(name="httpFilter")
    def http_filter(self) -> Optional[str]:
        """
        The HTTP filter to match. This filter is supported only if your backend protocol has an HTTP forward protocol.
        It extracts the request's URL path, which starts at the first slash and ends before the question mark (without the host part).
        Possible values are: `acl_http_filter_none`, `path_begin`, `path_end`, `http_header_match` or `regex`.
        """
        return pulumi.get(self, "http_filter")

    @property
    @pulumi.getter(name="httpFilterOption")
    def http_filter_option(self) -> Optional[str]:
        """
        If you have `http_filter` at `http_header_match`, you can use this field to filter on the HTTP header's value.
        """
        return pulumi.get(self, "http_filter_option")

    @property
    @pulumi.getter(name="httpFilterValues")
    def http_filter_values(self) -> Optional[Sequence[str]]:
        """
        A list of possible values to match for the given HTTP filter.
        Keep in mind that in the case of `http_header_match` the HTTP header field name is case insensitive.
        """
        return pulumi.get(self, "http_filter_values")

    @property
    @pulumi.getter
    def invert(self) -> Optional[bool]:
        """
        If set to `true`, the condition will be of type "unless".
        """
        return pulumi.get(self, "invert")

    @property
    @pulumi.getter(name="ipSubnets")
    def ip_subnets(self) -> Optional[Sequence[str]]:
        """
        A list of IPs, or CIDR v4/v6 addresses of the session client, to match.
        """
        return pulumi.get(self, "ip_subnets")


@pulumi.output_type
class BackendHealthCheckHttp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostHeader":
            suggest = "host_header"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackendHealthCheckHttp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackendHealthCheckHttp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackendHealthCheckHttp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 uri: str,
                 code: Optional[int] = None,
                 host_header: Optional[str] = None,
                 method: Optional[str] = None):
        """
        :param str uri: The HTTP endpoint URL to call for HC requests
        :param int code: The expected HTTP status code
        :param str host_header: The HTTP host header to use for HC requests
        :param str method: The HTTP method to use for HC requests
        """
        pulumi.set(__self__, "uri", uri)
        if code is not None:
            pulumi.set(__self__, "code", code)
        if host_header is not None:
            pulumi.set(__self__, "host_header", host_header)
        if method is not None:
            pulumi.set(__self__, "method", method)

    @property
    @pulumi.getter
    def uri(self) -> str:
        """
        The HTTP endpoint URL to call for HC requests
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter
    def code(self) -> Optional[int]:
        """
        The expected HTTP status code
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter(name="hostHeader")
    def host_header(self) -> Optional[str]:
        """
        The HTTP host header to use for HC requests
        """
        return pulumi.get(self, "host_header")

    @property
    @pulumi.getter
    def method(self) -> Optional[str]:
        """
        The HTTP method to use for HC requests
        """
        return pulumi.get(self, "method")


@pulumi.output_type
class BackendHealthCheckHttps(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostHeader":
            suggest = "host_header"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackendHealthCheckHttps. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackendHealthCheckHttps.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackendHealthCheckHttps.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 uri: str,
                 code: Optional[int] = None,
                 host_header: Optional[str] = None,
                 method: Optional[str] = None,
                 sni: Optional[str] = None):
        """
        :param str uri: The HTTPS endpoint URL to call for HC requests
        :param int code: The expected HTTP status code
        :param str host_header: The HTTP host header to use for HC requests
        :param str method: The HTTP method to use for HC requests
        :param str sni: The SNI to use for HC requests over SSL
        """
        pulumi.set(__self__, "uri", uri)
        if code is not None:
            pulumi.set(__self__, "code", code)
        if host_header is not None:
            pulumi.set(__self__, "host_header", host_header)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if sni is not None:
            pulumi.set(__self__, "sni", sni)

    @property
    @pulumi.getter
    def uri(self) -> str:
        """
        The HTTPS endpoint URL to call for HC requests
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter
    def code(self) -> Optional[int]:
        """
        The expected HTTP status code
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter(name="hostHeader")
    def host_header(self) -> Optional[str]:
        """
        The HTTP host header to use for HC requests
        """
        return pulumi.get(self, "host_header")

    @property
    @pulumi.getter
    def method(self) -> Optional[str]:
        """
        The HTTP method to use for HC requests
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def sni(self) -> Optional[str]:
        """
        The SNI to use for HC requests over SSL
        """
        return pulumi.get(self, "sni")


@pulumi.output_type
class BackendHealthCheckTcp(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class CertificateCustomCertificate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateChain":
            suggest = "certificate_chain"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CertificateCustomCertificate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CertificateCustomCertificate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CertificateCustomCertificate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_chain: str):
        """
        :param str certificate_chain: The full PEM-formatted certificate chain
        """
        pulumi.set(__self__, "certificate_chain", certificate_chain)

    @property
    @pulumi.getter(name="certificateChain")
    def certificate_chain(self) -> str:
        """
        The full PEM-formatted certificate chain
        """
        return pulumi.get(self, "certificate_chain")


@pulumi.output_type
class CertificateLetsencrypt(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "commonName":
            suggest = "common_name"
        elif key == "subjectAlternativeNames":
            suggest = "subject_alternative_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CertificateLetsencrypt. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CertificateLetsencrypt.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CertificateLetsencrypt.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 common_name: str,
                 subject_alternative_names: Optional[Sequence[str]] = None):
        """
        :param str common_name: Main domain of the certificate
        :param Sequence[str] subject_alternative_names: The alternative domain names of the certificate
        """
        pulumi.set(__self__, "common_name", common_name)
        if subject_alternative_names is not None:
            pulumi.set(__self__, "subject_alternative_names", subject_alternative_names)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> str:
        """
        Main domain of the certificate
        """
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter(name="subjectAlternativeNames")
    def subject_alternative_names(self) -> Optional[Sequence[str]]:
        """
        The alternative domain names of the certificate
        """
        return pulumi.get(self, "subject_alternative_names")


@pulumi.output_type
class FrontendAcl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "updatedAt":
            suggest = "updated_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FrontendAcl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FrontendAcl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FrontendAcl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: 'outputs.FrontendAclAction',
                 match: 'outputs.FrontendAclMatch',
                 created_at: Optional[str] = None,
                 description: Optional[str] = None,
                 name: Optional[str] = None,
                 updated_at: Optional[str] = None):
        """
        :param 'FrontendAclActionArgs' action: Action to undertake when an ACL filter matches.
        :param 'FrontendAclMatchArgs' match: The ACL match rule. At least `ip_subnet` or `http_filter` and `http_filter_value` are required.
        :param str created_at: IsDate and time of ACL's creation (RFC 3339 format)
        :param str description: Description of the ACL
        :param str name: The ACL name. If not provided it will be randomly generated.
        :param str updated_at: IsDate and time of ACL's update (RFC 3339 format)
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "match", match)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)

    @property
    @pulumi.getter
    def action(self) -> 'outputs.FrontendAclAction':
        """
        Action to undertake when an ACL filter matches.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def match(self) -> 'outputs.FrontendAclMatch':
        """
        The ACL match rule. At least `ip_subnet` or `http_filter` and `http_filter_value` are required.
        """
        return pulumi.get(self, "match")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[str]:
        """
        IsDate and time of ACL's creation (RFC 3339 format)
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of the ACL
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The ACL name. If not provided it will be randomly generated.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[str]:
        """
        IsDate and time of ACL's update (RFC 3339 format)
        """
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class FrontendAclAction(dict):
    def __init__(__self__, *,
                 type: str,
                 redirects: Optional[Sequence['outputs.FrontendAclActionRedirect']] = None):
        """
        :param str type: The action type. Possible values are: `allow` or `deny` or `redirect`.
        :param Sequence['FrontendAclActionRedirectArgs'] redirects: Redirect parameters when using an ACL with `redirect` action.
        """
        pulumi.set(__self__, "type", type)
        if redirects is not None:
            pulumi.set(__self__, "redirects", redirects)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The action type. Possible values are: `allow` or `deny` or `redirect`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def redirects(self) -> Optional[Sequence['outputs.FrontendAclActionRedirect']]:
        """
        Redirect parameters when using an ACL with `redirect` action.
        """
        return pulumi.get(self, "redirects")


@pulumi.output_type
class FrontendAclActionRedirect(dict):
    def __init__(__self__, *,
                 code: Optional[int] = None,
                 target: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param int code: The HTTP redirect code to use. Valid values are `301`, `302`, `303`, `307` and `308`.
        :param str target: A URL can be used in case of a location redirect (e.g. `https://scaleway.com` will redirect to this same URL). A scheme name (e.g. `https`, `http`, `ftp`, `git`) will replace the request's original scheme.
        :param str type: The redirect type. Possible values are: `location` or `scheme`.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def code(self) -> Optional[int]:
        """
        The HTTP redirect code to use. Valid values are `301`, `302`, `303`, `307` and `308`.
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def target(self) -> Optional[str]:
        """
        A URL can be used in case of a location redirect (e.g. `https://scaleway.com` will redirect to this same URL). A scheme name (e.g. `https`, `http`, `ftp`, `git`) will replace the request's original scheme.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The redirect type. Possible values are: `location` or `scheme`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class FrontendAclMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpFilter":
            suggest = "http_filter"
        elif key == "httpFilterOption":
            suggest = "http_filter_option"
        elif key == "httpFilterValues":
            suggest = "http_filter_values"
        elif key == "ipSubnets":
            suggest = "ip_subnets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FrontendAclMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FrontendAclMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FrontendAclMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_filter: Optional[str] = None,
                 http_filter_option: Optional[str] = None,
                 http_filter_values: Optional[Sequence[str]] = None,
                 invert: Optional[bool] = None,
                 ip_subnets: Optional[Sequence[str]] = None):
        """
        :param str http_filter: The HTTP filter to match. This filter is supported only if your backend protocol has an HTTP forward protocol.
               It extracts the request's URL path, which starts at the first slash and ends before the question mark (without the host part).
               Possible values are: `acl_http_filter_none`, `path_begin`, `path_end`, `http_header_match` or `regex`.
        :param str http_filter_option: If you have `http_filter` at `http_header_match`, you can use this field to filter on the HTTP header's value.
        :param Sequence[str] http_filter_values: A list of possible values to match for the given HTTP filter.
               Keep in mind that in the case of `http_header_match` the HTTP header field name is case insensitive.
        :param bool invert: If set to `true`, the condition will be of type "unless".
        :param Sequence[str] ip_subnets: A list of IPs, or CIDR v4/v6 addresses of the session client, to match.
        """
        if http_filter is not None:
            pulumi.set(__self__, "http_filter", http_filter)
        if http_filter_option is not None:
            pulumi.set(__self__, "http_filter_option", http_filter_option)
        if http_filter_values is not None:
            pulumi.set(__self__, "http_filter_values", http_filter_values)
        if invert is not None:
            pulumi.set(__self__, "invert", invert)
        if ip_subnets is not None:
            pulumi.set(__self__, "ip_subnets", ip_subnets)

    @property
    @pulumi.getter(name="httpFilter")
    def http_filter(self) -> Optional[str]:
        """
        The HTTP filter to match. This filter is supported only if your backend protocol has an HTTP forward protocol.
        It extracts the request's URL path, which starts at the first slash and ends before the question mark (without the host part).
        Possible values are: `acl_http_filter_none`, `path_begin`, `path_end`, `http_header_match` or `regex`.
        """
        return pulumi.get(self, "http_filter")

    @property
    @pulumi.getter(name="httpFilterOption")
    def http_filter_option(self) -> Optional[str]:
        """
        If you have `http_filter` at `http_header_match`, you can use this field to filter on the HTTP header's value.
        """
        return pulumi.get(self, "http_filter_option")

    @property
    @pulumi.getter(name="httpFilterValues")
    def http_filter_values(self) -> Optional[Sequence[str]]:
        """
        A list of possible values to match for the given HTTP filter.
        Keep in mind that in the case of `http_header_match` the HTTP header field name is case insensitive.
        """
        return pulumi.get(self, "http_filter_values")

    @property
    @pulumi.getter
    def invert(self) -> Optional[bool]:
        """
        If set to `true`, the condition will be of type "unless".
        """
        return pulumi.get(self, "invert")

    @property
    @pulumi.getter(name="ipSubnets")
    def ip_subnets(self) -> Optional[Sequence[str]]:
        """
        A list of IPs, or CIDR v4/v6 addresses of the session client, to match.
        """
        return pulumi.get(self, "ip_subnets")


@pulumi.output_type
class LoadBalancerPrivateNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateNetworkId":
            suggest = "private_network_id"
        elif key == "dhcpConfig":
            suggest = "dhcp_config"
        elif key == "ipamIds":
            suggest = "ipam_ids"
        elif key == "staticConfig":
            suggest = "static_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerPrivateNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerPrivateNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerPrivateNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 private_network_id: str,
                 dhcp_config: Optional[bool] = None,
                 ipam_ids: Optional[str] = None,
                 static_config: Optional[str] = None,
                 status: Optional[str] = None,
                 zone: Optional[str] = None):
        """
        :param str private_network_id: The ID of the Private Network to attach to.
               - > **Important:** Updates to `private_network` will recreate the attachment.
        :param bool dhcp_config: Please use `ipam_ids`. Set to `true` if you want to let DHCP assign IP addresses.
        :param str ipam_ids: IPAM ID of a pre-reserved IP address to assign to the Load Balancer on this Private Network.
        :param str static_config: Please use `ipam_ids`. Define a local ip address of your choice for the load balancer instance.
        :param str status: The status of the private network connection.
        :param str zone: `zone`) The zone of the Load Balancer.
        """
        pulumi.set(__self__, "private_network_id", private_network_id)
        if dhcp_config is not None:
            pulumi.set(__self__, "dhcp_config", dhcp_config)
        if ipam_ids is not None:
            pulumi.set(__self__, "ipam_ids", ipam_ids)
        if static_config is not None:
            pulumi.set(__self__, "static_config", static_config)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if zone is not None:
            pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter(name="privateNetworkId")
    def private_network_id(self) -> str:
        """
        The ID of the Private Network to attach to.
        - > **Important:** Updates to `private_network` will recreate the attachment.
        """
        return pulumi.get(self, "private_network_id")

    @property
    @pulumi.getter(name="dhcpConfig")
    @_utilities.deprecated("""dhcp_config field is deprecated, please use `private_network_id` or `ipam_ids` instead""")
    def dhcp_config(self) -> Optional[bool]:
        """
        Please use `ipam_ids`. Set to `true` if you want to let DHCP assign IP addresses.
        """
        return pulumi.get(self, "dhcp_config")

    @property
    @pulumi.getter(name="ipamIds")
    def ipam_ids(self) -> Optional[str]:
        """
        IPAM ID of a pre-reserved IP address to assign to the Load Balancer on this Private Network.
        """
        return pulumi.get(self, "ipam_ids")

    @property
    @pulumi.getter(name="staticConfig")
    @_utilities.deprecated("""static_config field is deprecated, please use `private_network_id` or `ipam_ids` instead""")
    def static_config(self) -> Optional[str]:
        """
        Please use `ipam_ids`. Define a local ip address of your choice for the load balancer instance.
        """
        return pulumi.get(self, "static_config")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        The status of the private network connection.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def zone(self) -> Optional[str]:
        """
        `zone`) The zone of the Load Balancer.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class GetAclsAclResult(dict):
    def __init__(__self__, *,
                 actions: Sequence['outputs.GetAclsAclActionResult'],
                 created_at: str,
                 description: str,
                 frontend_id: str,
                 id: str,
                 index: int,
                 matches: Sequence['outputs.GetAclsAclMatchResult'],
                 name: str,
                 update_at: str):
        """
        :param Sequence['GetAclsAclActionArgs'] actions: The action to be undertaken when an ACL filter matches.
        :param str created_at: The date on which the ACL was created (RFC 3339 format).
        :param str description: The description of the ACL resource.
        :param str frontend_id: The frontend ID this ACL is attached to. ACLs with a matching frontend ID are listed.
               > **Important:** LB frontend IDs are zoned, which means they are of the form `{zone}/{id}`, e.g. `fr-par-1/11111111-1111-1111-1111-111111111111`
        :param str id: The associated ACL ID.
               > **Important:** LB ACLs' IDs are zoned, which means they are of the form `{zone}/{id}`, e.g. `fr-par-1/11111111-1111-1111-1111-111111111111`
        :param int index: The priority of this ACL in the ordered list.
        :param Sequence['GetAclsAclMatchArgs'] matches: The ACL match rule.
        :param str name: The ACL name to filter for. ACLs with a matching name are listed.
        :param str update_at: The date on which the ACL was last updated (RFC 3339 format).
        """
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "frontend_id", frontend_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "index", index)
        pulumi.set(__self__, "matches", matches)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "update_at", update_at)

    @property
    @pulumi.getter
    def actions(self) -> Sequence['outputs.GetAclsAclActionResult']:
        """
        The action to be undertaken when an ACL filter matches.
        """
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        The date on which the ACL was created (RFC 3339 format).
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the ACL resource.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="frontendId")
    def frontend_id(self) -> str:
        """
        The frontend ID this ACL is attached to. ACLs with a matching frontend ID are listed.
        > **Important:** LB frontend IDs are zoned, which means they are of the form `{zone}/{id}`, e.g. `fr-par-1/11111111-1111-1111-1111-111111111111`
        """
        return pulumi.get(self, "frontend_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The associated ACL ID.
        > **Important:** LB ACLs' IDs are zoned, which means they are of the form `{zone}/{id}`, e.g. `fr-par-1/11111111-1111-1111-1111-111111111111`
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def index(self) -> int:
        """
        The priority of this ACL in the ordered list.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def matches(self) -> Sequence['outputs.GetAclsAclMatchResult']:
        """
        The ACL match rule.
        """
        return pulumi.get(self, "matches")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The ACL name to filter for. ACLs with a matching name are listed.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="updateAt")
    def update_at(self) -> str:
        """
        The date on which the ACL was last updated (RFC 3339 format).
        """
        return pulumi.get(self, "update_at")


@pulumi.output_type
class GetAclsAclActionResult(dict):
    def __init__(__self__, *,
                 redirects: Sequence['outputs.GetAclsAclActionRedirectResult'],
                 type: str):
        """
        :param Sequence['GetAclsAclActionRedirectArgs'] redirects: Redirect parameters when using an ACL with `redirect` action.
        :param str type: The redirect type.
        """
        pulumi.set(__self__, "redirects", redirects)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def redirects(self) -> Sequence['outputs.GetAclsAclActionRedirectResult']:
        """
        Redirect parameters when using an ACL with `redirect` action.
        """
        return pulumi.get(self, "redirects")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The redirect type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetAclsAclActionRedirectResult(dict):
    def __init__(__self__, *,
                 code: int,
                 target: str,
                 type: str):
        """
        :param int code: The HTTP redirect code to use.
        :param str target: The URL used in case of a location redirect, or the scheme name that replaces the request's original scheme.
        :param str type: The redirect type.
        """
        pulumi.set(__self__, "code", code)
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def code(self) -> int:
        """
        The HTTP redirect code to use.
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        The URL used in case of a location redirect, or the scheme name that replaces the request's original scheme.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The redirect type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetAclsAclMatchResult(dict):
    def __init__(__self__, *,
                 http_filter: str,
                 http_filter_option: str,
                 http_filter_values: Sequence[str],
                 invert: bool,
                 ip_subnets: Sequence[str]):
        """
        :param str http_filter: The HTTP filter to match.
        :param str http_filter_option: A list of possible values for the HTTP filter based on the HTTP header.
        :param Sequence[str] http_filter_values: The possible values to match for a given HTTP filter.
        :param bool invert: The condition will be of type "unless" if invert is set to `true`
        :param Sequence[str] ip_subnets: A list of IPs, or CIDR v4/v6 addresses of the session client, to match.
        """
        pulumi.set(__self__, "http_filter", http_filter)
        pulumi.set(__self__, "http_filter_option", http_filter_option)
        pulumi.set(__self__, "http_filter_values", http_filter_values)
        pulumi.set(__self__, "invert", invert)
        pulumi.set(__self__, "ip_subnets", ip_subnets)

    @property
    @pulumi.getter(name="httpFilter")
    def http_filter(self) -> str:
        """
        The HTTP filter to match.
        """
        return pulumi.get(self, "http_filter")

    @property
    @pulumi.getter(name="httpFilterOption")
    def http_filter_option(self) -> str:
        """
        A list of possible values for the HTTP filter based on the HTTP header.
        """
        return pulumi.get(self, "http_filter_option")

    @property
    @pulumi.getter(name="httpFilterValues")
    def http_filter_values(self) -> Sequence[str]:
        """
        The possible values to match for a given HTTP filter.
        """
        return pulumi.get(self, "http_filter_values")

    @property
    @pulumi.getter
    def invert(self) -> bool:
        """
        The condition will be of type "unless" if invert is set to `true`
        """
        return pulumi.get(self, "invert")

    @property
    @pulumi.getter(name="ipSubnets")
    def ip_subnets(self) -> Sequence[str]:
        """
        A list of IPs, or CIDR v4/v6 addresses of the session client, to match.
        """
        return pulumi.get(self, "ip_subnets")


@pulumi.output_type
class GetBackendHealthCheckHttpResult(dict):
    def __init__(__self__, *,
                 code: int,
                 host_header: str,
                 method: str,
                 sni: str,
                 uri: str):
        """
        :param int code: The expected HTTP status code
        :param str host_header: The HTTP host header to use for HC requests
        :param str method: The HTTP method to use for HC requests
        :param str sni: The SNI to use for HC requests over SSL
        :param str uri: The HTTPS endpoint URL to call for HC requests
        """
        pulumi.set(__self__, "code", code)
        pulumi.set(__self__, "host_header", host_header)
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "sni", sni)
        pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def code(self) -> int:
        """
        The expected HTTP status code
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter(name="hostHeader")
    def host_header(self) -> str:
        """
        The HTTP host header to use for HC requests
        """
        return pulumi.get(self, "host_header")

    @property
    @pulumi.getter
    def method(self) -> str:
        """
        The HTTP method to use for HC requests
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def sni(self) -> str:
        """
        The SNI to use for HC requests over SSL
        """
        return pulumi.get(self, "sni")

    @property
    @pulumi.getter
    def uri(self) -> str:
        """
        The HTTPS endpoint URL to call for HC requests
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class GetBackendHealthCheckTcpResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetBackendsBackendResult(dict):
    def __init__(__self__, *,
                 created_at: str,
                 failover_host: str,
                 forward_port: int,
                 forward_port_algorithm: str,
                 forward_protocol: str,
                 health_check_delay: str,
                 health_check_http: Sequence['outputs.GetBackendsBackendHealthCheckHttpResult'],
                 health_check_https: Sequence['outputs.GetBackendsBackendHealthCheckHttpResult'],
                 health_check_max_retries: int,
                 health_check_port: int,
                 health_check_tcps: Sequence['outputs.GetBackendsBackendHealthCheckTcpResult'],
                 health_check_timeout: str,
                 id: str,
                 ignore_ssl_server_verify: bool,
                 lb_id: str,
                 name: str,
                 on_marked_down_action: str,
                 proxy_protocol: str,
                 server_ips: Sequence[str],
                 ssl_bridging: bool,
                 sticky_sessions: str,
                 sticky_sessions_cookie_name: str,
                 timeout_connect: str,
                 timeout_server: str,
                 timeout_tunnel: str,
                 update_at: str):
        """
        :param str created_at: The date on which the backend was created (RFC 3339 format).
        :param str failover_host: Scaleway S3 bucket website to be served if all backend servers are down.
        :param int forward_port: User sessions will be forwarded to this backend server port.
        :param str forward_port_algorithm: Load balancing algorithm.
        :param str forward_protocol: Backend protocol.
        :param str health_check_delay: Interval between two health check requests.
        :param Sequence['GetBackendsBackendHealthCheckHttpArgs'] health_check_http: This block enables HTTP health checks.
        :param Sequence['GetBackendsBackendHealthCheckHttpArgs'] health_check_https: This block enables HTTPS health checks.
        :param int health_check_max_retries: Number of allowed failed health check requests before the backend server is marked as down.
        :param int health_check_port: Port the health check requests will be sent to.
        :param Sequence['GetBackendsBackendHealthCheckTcpArgs'] health_check_tcps: This block enables TCP health checks.
        :param str health_check_timeout: Timeout before a health check request is considered failed.
        :param str id: The associated backend ID.
        :param bool ignore_ssl_server_verify: Specifies whether the Load Balancer should check the backend server’s certificate before initiating a connection.
        :param str lb_id: The Load Balancer ID this backend is attached to. Backends with a matching ID are listed.
        :param str name: The backend name to filter for. Backends with a matching name are listed.
        :param str on_marked_down_action: Modify what occurs when a backend server is marked down.
        :param str proxy_protocol: The type of PROXY protocol.
        :param Sequence[str] server_ips: List of backend server IP addresses.
        :param bool ssl_bridging: Enables SSL between Load Balancer and backend servers.
        :param str sticky_sessions: Enables cookie-based session persistence.
        :param str sticky_sessions_cookie_name: Cookie name for sticky sessions.
        :param str timeout_connect: Maximum initial server connection establishment time.
        :param str timeout_server: Maximum server connection inactivity time.
        :param str timeout_tunnel: Maximum tunnel inactivity time.
        :param str update_at: The date on which the backend was last updated (RFC 3339 format).
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "failover_host", failover_host)
        pulumi.set(__self__, "forward_port", forward_port)
        pulumi.set(__self__, "forward_port_algorithm", forward_port_algorithm)
        pulumi.set(__self__, "forward_protocol", forward_protocol)
        pulumi.set(__self__, "health_check_delay", health_check_delay)
        pulumi.set(__self__, "health_check_http", health_check_http)
        pulumi.set(__self__, "health_check_https", health_check_https)
        pulumi.set(__self__, "health_check_max_retries", health_check_max_retries)
        pulumi.set(__self__, "health_check_port", health_check_port)
        pulumi.set(__self__, "health_check_tcps", health_check_tcps)
        pulumi.set(__self__, "health_check_timeout", health_check_timeout)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ignore_ssl_server_verify", ignore_ssl_server_verify)
        pulumi.set(__self__, "lb_id", lb_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "on_marked_down_action", on_marked_down_action)
        pulumi.set(__self__, "proxy_protocol", proxy_protocol)
        pulumi.set(__self__, "server_ips", server_ips)
        pulumi.set(__self__, "ssl_bridging", ssl_bridging)
        pulumi.set(__self__, "sticky_sessions", sticky_sessions)
        pulumi.set(__self__, "sticky_sessions_cookie_name", sticky_sessions_cookie_name)
        pulumi.set(__self__, "timeout_connect", timeout_connect)
        pulumi.set(__self__, "timeout_server", timeout_server)
        pulumi.set(__self__, "timeout_tunnel", timeout_tunnel)
        pulumi.set(__self__, "update_at", update_at)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        The date on which the backend was created (RFC 3339 format).
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="failoverHost")
    def failover_host(self) -> str:
        """
        Scaleway S3 bucket website to be served if all backend servers are down.
        """
        return pulumi.get(self, "failover_host")

    @property
    @pulumi.getter(name="forwardPort")
    def forward_port(self) -> int:
        """
        User sessions will be forwarded to this backend server port.
        """
        return pulumi.get(self, "forward_port")

    @property
    @pulumi.getter(name="forwardPortAlgorithm")
    def forward_port_algorithm(self) -> str:
        """
        Load balancing algorithm.
        """
        return pulumi.get(self, "forward_port_algorithm")

    @property
    @pulumi.getter(name="forwardProtocol")
    def forward_protocol(self) -> str:
        """
        Backend protocol.
        """
        return pulumi.get(self, "forward_protocol")

    @property
    @pulumi.getter(name="healthCheckDelay")
    def health_check_delay(self) -> str:
        """
        Interval between two health check requests.
        """
        return pulumi.get(self, "health_check_delay")

    @property
    @pulumi.getter(name="healthCheckHttp")
    def health_check_http(self) -> Sequence['outputs.GetBackendsBackendHealthCheckHttpResult']:
        """
        This block enables HTTP health checks.
        """
        return pulumi.get(self, "health_check_http")

    @property
    @pulumi.getter(name="healthCheckHttps")
    def health_check_https(self) -> Sequence['outputs.GetBackendsBackendHealthCheckHttpResult']:
        """
        This block enables HTTPS health checks.
        """
        return pulumi.get(self, "health_check_https")

    @property
    @pulumi.getter(name="healthCheckMaxRetries")
    def health_check_max_retries(self) -> int:
        """
        Number of allowed failed health check requests before the backend server is marked as down.
        """
        return pulumi.get(self, "health_check_max_retries")

    @property
    @pulumi.getter(name="healthCheckPort")
    def health_check_port(self) -> int:
        """
        Port the health check requests will be sent to.
        """
        return pulumi.get(self, "health_check_port")

    @property
    @pulumi.getter(name="healthCheckTcps")
    def health_check_tcps(self) -> Sequence['outputs.GetBackendsBackendHealthCheckTcpResult']:
        """
        This block enables TCP health checks.
        """
        return pulumi.get(self, "health_check_tcps")

    @property
    @pulumi.getter(name="healthCheckTimeout")
    def health_check_timeout(self) -> str:
        """
        Timeout before a health check request is considered failed.
        """
        return pulumi.get(self, "health_check_timeout")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The associated backend ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="ignoreSslServerVerify")
    def ignore_ssl_server_verify(self) -> bool:
        """
        Specifies whether the Load Balancer should check the backend server’s certificate before initiating a connection.
        """
        return pulumi.get(self, "ignore_ssl_server_verify")

    @property
    @pulumi.getter(name="lbId")
    def lb_id(self) -> str:
        """
        The Load Balancer ID this backend is attached to. Backends with a matching ID are listed.
        """
        return pulumi.get(self, "lb_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The backend name to filter for. Backends with a matching name are listed.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="onMarkedDownAction")
    def on_marked_down_action(self) -> str:
        """
        Modify what occurs when a backend server is marked down.
        """
        return pulumi.get(self, "on_marked_down_action")

    @property
    @pulumi.getter(name="proxyProtocol")
    def proxy_protocol(self) -> str:
        """
        The type of PROXY protocol.
        """
        return pulumi.get(self, "proxy_protocol")

    @property
    @pulumi.getter(name="serverIps")
    def server_ips(self) -> Sequence[str]:
        """
        List of backend server IP addresses.
        """
        return pulumi.get(self, "server_ips")

    @property
    @pulumi.getter(name="sslBridging")
    def ssl_bridging(self) -> bool:
        """
        Enables SSL between Load Balancer and backend servers.
        """
        return pulumi.get(self, "ssl_bridging")

    @property
    @pulumi.getter(name="stickySessions")
    def sticky_sessions(self) -> str:
        """
        Enables cookie-based session persistence.
        """
        return pulumi.get(self, "sticky_sessions")

    @property
    @pulumi.getter(name="stickySessionsCookieName")
    def sticky_sessions_cookie_name(self) -> str:
        """
        Cookie name for sticky sessions.
        """
        return pulumi.get(self, "sticky_sessions_cookie_name")

    @property
    @pulumi.getter(name="timeoutConnect")
    def timeout_connect(self) -> str:
        """
        Maximum initial server connection establishment time.
        """
        return pulumi.get(self, "timeout_connect")

    @property
    @pulumi.getter(name="timeoutServer")
    def timeout_server(self) -> str:
        """
        Maximum server connection inactivity time.
        """
        return pulumi.get(self, "timeout_server")

    @property
    @pulumi.getter(name="timeoutTunnel")
    def timeout_tunnel(self) -> str:
        """
        Maximum tunnel inactivity time.
        """
        return pulumi.get(self, "timeout_tunnel")

    @property
    @pulumi.getter(name="updateAt")
    def update_at(self) -> str:
        """
        The date on which the backend was last updated (RFC 3339 format).
        """
        return pulumi.get(self, "update_at")


@pulumi.output_type
class GetBackendsBackendHealthCheckHttpResult(dict):
    def __init__(__self__, *,
                 code: int,
                 host_header: str,
                 method: str,
                 sni: str,
                 uri: str):
        """
        :param int code: The expected HTTP status code.
        :param str host_header: The HTTP host header to use for health check requests.
        :param str method: The HTTP method to use for health check requests.
        :param str sni: The SNI to use for HC requests over SSL.
        :param str uri: The HTTPS endpoint URL to call for health check requests.
        """
        pulumi.set(__self__, "code", code)
        pulumi.set(__self__, "host_header", host_header)
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "sni", sni)
        pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def code(self) -> int:
        """
        The expected HTTP status code.
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter(name="hostHeader")
    def host_header(self) -> str:
        """
        The HTTP host header to use for health check requests.
        """
        return pulumi.get(self, "host_header")

    @property
    @pulumi.getter
    def method(self) -> str:
        """
        The HTTP method to use for health check requests.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def sni(self) -> str:
        """
        The SNI to use for HC requests over SSL.
        """
        return pulumi.get(self, "sni")

    @property
    @pulumi.getter
    def uri(self) -> str:
        """
        The HTTPS endpoint URL to call for health check requests.
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class GetBackendsBackendHealthCheckTcpResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetCertificateCustomCertificateResult(dict):
    def __init__(__self__, *,
                 certificate_chain: str):
        """
        :param str certificate_chain: The full PEM-formatted certificate chain
        """
        pulumi.set(__self__, "certificate_chain", certificate_chain)

    @property
    @pulumi.getter(name="certificateChain")
    def certificate_chain(self) -> str:
        """
        The full PEM-formatted certificate chain
        """
        return pulumi.get(self, "certificate_chain")


@pulumi.output_type
class GetCertificateLetsencryptResult(dict):
    def __init__(__self__, *,
                 common_name: str,
                 subject_alternative_names: Sequence[str]):
        """
        :param str common_name: The main domain name of the certificate
        :param Sequence[str] subject_alternative_names: The alternative domain names of the certificate
        """
        pulumi.set(__self__, "common_name", common_name)
        pulumi.set(__self__, "subject_alternative_names", subject_alternative_names)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> str:
        """
        The main domain name of the certificate
        """
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter(name="subjectAlternativeNames")
    def subject_alternative_names(self) -> Sequence[str]:
        """
        The alternative domain names of the certificate
        """
        return pulumi.get(self, "subject_alternative_names")


@pulumi.output_type
class GetFrontendAclResult(dict):
    def __init__(__self__, *,
                 actions: Sequence['outputs.GetFrontendAclActionResult'],
                 created_at: str,
                 description: str,
                 matches: Sequence['outputs.GetFrontendAclMatchResult'],
                 name: str,
                 updated_at: str):
        """
        :param Sequence['GetFrontendAclActionArgs'] actions: Action to undertake when an ACL filter matches
        :param str created_at: IsDate and time of ACL's creation (RFC 3339 format)
        :param str description: Description of the ACL
        :param Sequence['GetFrontendAclMatchArgs'] matches: The ACL match rule
        :param str name: The name of the frontend.
               - When using the `name` you should specify the `lb-id`
        :param str updated_at: IsDate and time of ACL's update (RFC 3339 format)
        """
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "matches", matches)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "updated_at", updated_at)

    @property
    @pulumi.getter
    def actions(self) -> Sequence['outputs.GetFrontendAclActionResult']:
        """
        Action to undertake when an ACL filter matches
        """
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        IsDate and time of ACL's creation (RFC 3339 format)
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Description of the ACL
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def matches(self) -> Sequence['outputs.GetFrontendAclMatchResult']:
        """
        The ACL match rule
        """
        return pulumi.get(self, "matches")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the frontend.
        - When using the `name` you should specify the `lb-id`
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> str:
        """
        IsDate and time of ACL's update (RFC 3339 format)
        """
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class GetFrontendAclActionResult(dict):
    def __init__(__self__, *,
                 redirects: Sequence['outputs.GetFrontendAclActionRedirectResult'],
                 type: str):
        """
        :param Sequence['GetFrontendAclActionRedirectArgs'] redirects: Redirect parameters when using an ACL with `redirect` action
        :param str type: The action type
        """
        pulumi.set(__self__, "redirects", redirects)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def redirects(self) -> Sequence['outputs.GetFrontendAclActionRedirectResult']:
        """
        Redirect parameters when using an ACL with `redirect` action
        """
        return pulumi.get(self, "redirects")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The action type
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetFrontendAclActionRedirectResult(dict):
    def __init__(__self__, *,
                 code: int,
                 target: str,
                 type: str):
        """
        :param int code: The HTTP redirect code to use
        :param str target: An URL can be used in case of a location redirect
        :param str type: The redirect type
        """
        pulumi.set(__self__, "code", code)
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def code(self) -> int:
        """
        The HTTP redirect code to use
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        An URL can be used in case of a location redirect
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The redirect type
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetFrontendAclMatchResult(dict):
    def __init__(__self__, *,
                 http_filter: str,
                 http_filter_option: str,
                 http_filter_values: Sequence[str],
                 invert: bool,
                 ip_subnets: Sequence[str]):
        """
        :param str http_filter: The HTTP filter to match
        :param str http_filter_option: You can use this field with http_header_match acl type to set the header name to filter
        :param Sequence[str] http_filter_values: A list of possible values to match for the given HTTP filter
        :param bool invert: If set to true, the condition will be of type "unless"
        :param Sequence[str] ip_subnets: A list of IPs or CIDR v4/v6 addresses of the client of the session to match
        """
        pulumi.set(__self__, "http_filter", http_filter)
        pulumi.set(__self__, "http_filter_option", http_filter_option)
        pulumi.set(__self__, "http_filter_values", http_filter_values)
        pulumi.set(__self__, "invert", invert)
        pulumi.set(__self__, "ip_subnets", ip_subnets)

    @property
    @pulumi.getter(name="httpFilter")
    def http_filter(self) -> str:
        """
        The HTTP filter to match
        """
        return pulumi.get(self, "http_filter")

    @property
    @pulumi.getter(name="httpFilterOption")
    def http_filter_option(self) -> str:
        """
        You can use this field with http_header_match acl type to set the header name to filter
        """
        return pulumi.get(self, "http_filter_option")

    @property
    @pulumi.getter(name="httpFilterValues")
    def http_filter_values(self) -> Sequence[str]:
        """
        A list of possible values to match for the given HTTP filter
        """
        return pulumi.get(self, "http_filter_values")

    @property
    @pulumi.getter
    def invert(self) -> bool:
        """
        If set to true, the condition will be of type "unless"
        """
        return pulumi.get(self, "invert")

    @property
    @pulumi.getter(name="ipSubnets")
    def ip_subnets(self) -> Sequence[str]:
        """
        A list of IPs or CIDR v4/v6 addresses of the client of the session to match
        """
        return pulumi.get(self, "ip_subnets")


@pulumi.output_type
class GetFrontendsFrontendResult(dict):
    def __init__(__self__, *,
                 backend_id: str,
                 certificate_ids: Sequence[str],
                 created_at: str,
                 enable_http3: bool,
                 id: str,
                 inbound_port: int,
                 lb_id: str,
                 name: str,
                 timeout_client: str,
                 update_at: str):
        """
        :param str backend_id: The Load Balancer backend ID this frontend is attached to.
               > **Important:** Load Balancer backend IDs are zoned, which means they are of the form `{zone}/{id}`, e.g. `fr-par-1/11111111-1111-1111-1111-111111111111`
        :param Sequence[str] certificate_ids: List of certificate IDs that are used by the frontend.
        :param str created_at: The date on which the frontend was created (RFC 3339 format).
        :param bool enable_http3: Whether HTTP/3 protocol is activated.
        :param str id: The ID of the associated frontend.
               > **Important:** LB frontend IDs are zoned, which means they are of the form `{zone}/{id}`, e.g. `fr-par-1/11111111-1111-1111-1111-111111111111`
        :param int inbound_port: TCP port the frontend listens to.
        :param str lb_id: The Load Balancer ID this frontend is attached to. Frontends with a matching ID are listed.
        :param str name: The frontend name to filter for. Frontends with a matching name are listed.
        :param str timeout_client: Maximum inactivity time on the client side.
        :param str update_at: The date aont which the frontend was last updated (RFC 3339 format).
        """
        pulumi.set(__self__, "backend_id", backend_id)
        pulumi.set(__self__, "certificate_ids", certificate_ids)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "enable_http3", enable_http3)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "inbound_port", inbound_port)
        pulumi.set(__self__, "lb_id", lb_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "timeout_client", timeout_client)
        pulumi.set(__self__, "update_at", update_at)

    @property
    @pulumi.getter(name="backendId")
    def backend_id(self) -> str:
        """
        The Load Balancer backend ID this frontend is attached to.
        > **Important:** Load Balancer backend IDs are zoned, which means they are of the form `{zone}/{id}`, e.g. `fr-par-1/11111111-1111-1111-1111-111111111111`
        """
        return pulumi.get(self, "backend_id")

    @property
    @pulumi.getter(name="certificateIds")
    def certificate_ids(self) -> Sequence[str]:
        """
        List of certificate IDs that are used by the frontend.
        """
        return pulumi.get(self, "certificate_ids")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        The date on which the frontend was created (RFC 3339 format).
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="enableHttp3")
    def enable_http3(self) -> bool:
        """
        Whether HTTP/3 protocol is activated.
        """
        return pulumi.get(self, "enable_http3")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the associated frontend.
        > **Important:** LB frontend IDs are zoned, which means they are of the form `{zone}/{id}`, e.g. `fr-par-1/11111111-1111-1111-1111-111111111111`
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="inboundPort")
    def inbound_port(self) -> int:
        """
        TCP port the frontend listens to.
        """
        return pulumi.get(self, "inbound_port")

    @property
    @pulumi.getter(name="lbId")
    def lb_id(self) -> str:
        """
        The Load Balancer ID this frontend is attached to. Frontends with a matching ID are listed.
        """
        return pulumi.get(self, "lb_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The frontend name to filter for. Frontends with a matching name are listed.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="timeoutClient")
    def timeout_client(self) -> str:
        """
        Maximum inactivity time on the client side.
        """
        return pulumi.get(self, "timeout_client")

    @property
    @pulumi.getter(name="updateAt")
    def update_at(self) -> str:
        """
        The date aont which the frontend was last updated (RFC 3339 format).
        """
        return pulumi.get(self, "update_at")


@pulumi.output_type
class GetIpsIpResult(dict):
    def __init__(__self__, *,
                 id: str,
                 ip_address: str,
                 lb_id: str,
                 organization_id: str,
                 project_id: str,
                 reverse: str,
                 tags: Sequence[str],
                 zone: str):
        """
        :param str id: The ID of the associated IP.
        :param str ip_address: The IP address
        :param str lb_id: The ID of the associated Load BalancerD, if any
        :param str organization_id: The ID of the Organization the Load Balancer is associated with.
        :param str project_id: The ID of the Project the Load Balancer is associated with.
        :param str reverse: The reverse domain associated with this IP.
        :param Sequence[str] tags: List of tags used as filter. IPs with these exact tags are listed.
        :param str zone: `zone`) The zone in which the IPs exist.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "lb_id", lb_id)
        pulumi.set(__self__, "organization_id", organization_id)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "reverse", reverse)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the associated IP.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        """
        The IP address
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter(name="lbId")
    def lb_id(self) -> str:
        """
        The ID of the associated Load BalancerD, if any
        """
        return pulumi.get(self, "lb_id")

    @property
    @pulumi.getter(name="organizationId")
    def organization_id(self) -> str:
        """
        The ID of the Organization the Load Balancer is associated with.
        """
        return pulumi.get(self, "organization_id")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        The ID of the Project the Load Balancer is associated with.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def reverse(self) -> str:
        """
        The reverse domain associated with this IP.
        """
        return pulumi.get(self, "reverse")

    @property
    @pulumi.getter
    def tags(self) -> Sequence[str]:
        """
        List of tags used as filter. IPs with these exact tags are listed.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def zone(self) -> str:
        """
        `zone`) The zone in which the IPs exist.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class GetLoadBalancerPrivateNetworkResult(dict):
    def __init__(__self__, *,
                 dhcp_config: bool,
                 ipam_ids: Sequence[str],
                 private_network_id: str,
                 static_configs: Sequence[str],
                 status: str,
                 zone: str):
        """
        :param bool dhcp_config: Set to true if you want to let DHCP assign IP addresses
        :param Sequence[str] ipam_ids: IPAM ID of a pre-reserved IP address to assign to the Load Balancer on this Private Network
        :param str private_network_id: The Private Network ID
        :param Sequence[str] static_configs: Define an IP address in the subnet of your private network that will be assigned to your load balancer instance
        :param str status: The status of private network connection
        :param str zone: (Defaults to provider `zone`) The zone in which the Load Balancer exists.
        """
        pulumi.set(__self__, "dhcp_config", dhcp_config)
        pulumi.set(__self__, "ipam_ids", ipam_ids)
        pulumi.set(__self__, "private_network_id", private_network_id)
        pulumi.set(__self__, "static_configs", static_configs)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter(name="dhcpConfig")
    def dhcp_config(self) -> bool:
        """
        Set to true if you want to let DHCP assign IP addresses
        """
        return pulumi.get(self, "dhcp_config")

    @property
    @pulumi.getter(name="ipamIds")
    def ipam_ids(self) -> Sequence[str]:
        """
        IPAM ID of a pre-reserved IP address to assign to the Load Balancer on this Private Network
        """
        return pulumi.get(self, "ipam_ids")

    @property
    @pulumi.getter(name="privateNetworkId")
    def private_network_id(self) -> str:
        """
        The Private Network ID
        """
        return pulumi.get(self, "private_network_id")

    @property
    @pulumi.getter(name="staticConfigs")
    def static_configs(self) -> Sequence[str]:
        """
        Define an IP address in the subnet of your private network that will be assigned to your load balancer instance
        """
        return pulumi.get(self, "static_configs")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The status of private network connection
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def zone(self) -> str:
        """
        (Defaults to provider `zone`) The zone in which the Load Balancer exists.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class GetLoadBalancersLbResult(dict):
    def __init__(__self__, *,
                 backend_count: int,
                 created_at: str,
                 description: str,
                 frontend_count: int,
                 id: str,
                 instances: Sequence['outputs.GetLoadBalancersLbInstanceResult'],
                 ips: Sequence['outputs.GetLoadBalancersLbIpResult'],
                 name: str,
                 organization_id: str,
                 private_network_count: int,
                 project_id: str,
                 route_count: int,
                 ssl_compatibility_level: str,
                 status: str,
                 subscriber: str,
                 tags: Sequence[str],
                 type: str,
                 updated_at: str,
                 zone: str):
        """
        :param int backend_count: Number of backends the Load Balancer has.
        :param str created_at: Date on which the Load Balancer was created.
        :param str description: The description of the Load Balancer.
        :param int frontend_count: Number of frontends the Load Balancer has.
        :param str id: The ID of the Load Balancer.
        :param Sequence['GetLoadBalancersLbInstanceArgs'] instances: List of underlying Instances.
        :param Sequence['GetLoadBalancersLbIpArgs'] ips: List of IPs attached to the Load Balancer.
        :param str name: The Load Balancer name to filter for. Load Balancers with a matching name are listed.
        :param str organization_id: The ID of the Organization the Load Balancer is associated with.
        :param int private_network_count: Number of Private Networks attached to the Load balancer.
        :param str project_id: The ID of the Project the Load Balancer is associated with.
        :param int route_count: Number of routes the Load balancer has.
        :param str ssl_compatibility_level: Determines the minimal SSL version which needs to be supported on the client side.
        :param str status: The state of the Load Balancer Instance. Possible values are: `unknown`, `ready`, `pending`, `stopped`, `error`, `locked` and `migrating`.
        :param str subscriber: The subscriber information.
        :param Sequence[str] tags: List of tags to filter for. Load Balancers with these exact tags are listed.
        :param str type: The offer type of the Load Balancer.
        :param str updated_at: Date on which the Load Balancer was updated.
        :param str zone: `zone`) The zone in which the Load Balancers exist.
        """
        pulumi.set(__self__, "backend_count", backend_count)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "frontend_count", frontend_count)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "instances", instances)
        pulumi.set(__self__, "ips", ips)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "organization_id", organization_id)
        pulumi.set(__self__, "private_network_count", private_network_count)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "route_count", route_count)
        pulumi.set(__self__, "ssl_compatibility_level", ssl_compatibility_level)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "subscriber", subscriber)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "updated_at", updated_at)
        pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter(name="backendCount")
    def backend_count(self) -> int:
        """
        Number of backends the Load Balancer has.
        """
        return pulumi.get(self, "backend_count")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        Date on which the Load Balancer was created.
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the Load Balancer.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="frontendCount")
    def frontend_count(self) -> int:
        """
        Number of frontends the Load Balancer has.
        """
        return pulumi.get(self, "frontend_count")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Load Balancer.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def instances(self) -> Sequence['outputs.GetLoadBalancersLbInstanceResult']:
        """
        List of underlying Instances.
        """
        return pulumi.get(self, "instances")

    @property
    @pulumi.getter
    def ips(self) -> Sequence['outputs.GetLoadBalancersLbIpResult']:
        """
        List of IPs attached to the Load Balancer.
        """
        return pulumi.get(self, "ips")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The Load Balancer name to filter for. Load Balancers with a matching name are listed.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="organizationId")
    def organization_id(self) -> str:
        """
        The ID of the Organization the Load Balancer is associated with.
        """
        return pulumi.get(self, "organization_id")

    @property
    @pulumi.getter(name="privateNetworkCount")
    def private_network_count(self) -> int:
        """
        Number of Private Networks attached to the Load balancer.
        """
        return pulumi.get(self, "private_network_count")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        The ID of the Project the Load Balancer is associated with.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter(name="routeCount")
    def route_count(self) -> int:
        """
        Number of routes the Load balancer has.
        """
        return pulumi.get(self, "route_count")

    @property
    @pulumi.getter(name="sslCompatibilityLevel")
    def ssl_compatibility_level(self) -> str:
        """
        Determines the minimal SSL version which needs to be supported on the client side.
        """
        return pulumi.get(self, "ssl_compatibility_level")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The state of the Load Balancer Instance. Possible values are: `unknown`, `ready`, `pending`, `stopped`, `error`, `locked` and `migrating`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def subscriber(self) -> str:
        """
        The subscriber information.
        """
        return pulumi.get(self, "subscriber")

    @property
    @pulumi.getter
    def tags(self) -> Sequence[str]:
        """
        List of tags to filter for. Load Balancers with these exact tags are listed.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The offer type of the Load Balancer.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> str:
        """
        Date on which the Load Balancer was updated.
        """
        return pulumi.get(self, "updated_at")

    @property
    @pulumi.getter
    def zone(self) -> str:
        """
        `zone`) The zone in which the Load Balancers exist.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class GetLoadBalancersLbInstanceResult(dict):
    def __init__(__self__, *,
                 created_at: str,
                 id: str,
                 ip_address: str,
                 status: str,
                 updated_at: str,
                 zone: str):
        """
        :param str created_at: Date on which the Load Balancer was created.
        :param str id: The ID of the Load Balancer.
        :param str status: The state of the Load Balancer Instance. Possible values are: `unknown`, `ready`, `pending`, `stopped`, `error`, `locked` and `migrating`.
        :param str updated_at: Date on which the Load Balancer was updated.
        :param str zone: `zone`) The zone in which the Load Balancers exist.
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "updated_at", updated_at)
        pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        Date on which the Load Balancer was created.
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Load Balancer.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The state of the Load Balancer Instance. Possible values are: `unknown`, `ready`, `pending`, `stopped`, `error`, `locked` and `migrating`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> str:
        """
        Date on which the Load Balancer was updated.
        """
        return pulumi.get(self, "updated_at")

    @property
    @pulumi.getter
    def zone(self) -> str:
        """
        `zone`) The zone in which the Load Balancers exist.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class GetLoadBalancersLbIpResult(dict):
    def __init__(__self__, *,
                 id: str,
                 ip_address: str,
                 lb_id: str,
                 organization_id: str,
                 project_id: str,
                 reverse: str,
                 zone: str):
        """
        :param str id: The ID of the Load Balancer.
        :param str organization_id: The ID of the Organization the Load Balancer is associated with.
        :param str project_id: The ID of the Project the Load Balancer is associated with.
        :param str zone: `zone`) The zone in which the Load Balancers exist.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "lb_id", lb_id)
        pulumi.set(__self__, "organization_id", organization_id)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "reverse", reverse)
        pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Load Balancer.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter(name="lbId")
    def lb_id(self) -> str:
        return pulumi.get(self, "lb_id")

    @property
    @pulumi.getter(name="organizationId")
    def organization_id(self) -> str:
        """
        The ID of the Organization the Load Balancer is associated with.
        """
        return pulumi.get(self, "organization_id")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        The ID of the Project the Load Balancer is associated with.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def reverse(self) -> str:
        return pulumi.get(self, "reverse")

    @property
    @pulumi.getter
    def zone(self) -> str:
        """
        `zone`) The zone in which the Load Balancers exist.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class GetRoutesRouteResult(dict):
    def __init__(__self__, *,
                 backend_id: str,
                 created_at: str,
                 frontend_id: str,
                 id: str,
                 match_host_header: str,
                 match_sni: str,
                 update_at: str):
        """
        :param str backend_id: The backend ID to redirect to
        :param str created_at: The date on which the route was created (RFC 3339 format).
        :param str frontend_id: The frontend ID (the origin of the redirection), to filter for. Routes with a matching frontend ID are listed.
        :param str id: The associated route ID.
        :param str match_host_header: Specifies the host of the server to which the request is being sent.
        :param str match_sni: Server Name Indication TLS extension field from an incoming connection made via an SSL/TLS transport layer.
        :param str update_at: The date on which the route was last updated (RFC 3339 format).
        """
        pulumi.set(__self__, "backend_id", backend_id)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "frontend_id", frontend_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "match_host_header", match_host_header)
        pulumi.set(__self__, "match_sni", match_sni)
        pulumi.set(__self__, "update_at", update_at)

    @property
    @pulumi.getter(name="backendId")
    def backend_id(self) -> str:
        """
        The backend ID to redirect to
        """
        return pulumi.get(self, "backend_id")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        The date on which the route was created (RFC 3339 format).
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="frontendId")
    def frontend_id(self) -> str:
        """
        The frontend ID (the origin of the redirection), to filter for. Routes with a matching frontend ID are listed.
        """
        return pulumi.get(self, "frontend_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The associated route ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="matchHostHeader")
    def match_host_header(self) -> str:
        """
        Specifies the host of the server to which the request is being sent.
        """
        return pulumi.get(self, "match_host_header")

    @property
    @pulumi.getter(name="matchSni")
    def match_sni(self) -> str:
        """
        Server Name Indication TLS extension field from an incoming connection made via an SSL/TLS transport layer.
        """
        return pulumi.get(self, "match_sni")

    @property
    @pulumi.getter(name="updateAt")
    def update_at(self) -> str:
        """
        The date on which the route was last updated (RFC 3339 format).
        """
        return pulumi.get(self, "update_at")


