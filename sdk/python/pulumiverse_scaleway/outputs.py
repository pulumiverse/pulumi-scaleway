# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs

__all__ = [
    'BaremetalServerIp',
    'BaremetalServerIpv4',
    'BaremetalServerIpv6',
    'BaremetalServerOption',
    'BaremetalServerPrivateNetwork',
    'CockpitAlertManagerContactPoint',
    'CockpitEndpoint',
    'CockpitPushUrl',
    'CockpitTokenScopes',
    'ContainerTriggerNats',
    'ContainerTriggerSqs',
    'DatabaseAclAclRule',
    'DatabaseInstanceLoadBalancer',
    'DatabaseInstanceLogsPolicy',
    'DatabaseInstancePrivateNetwork',
    'DatabaseInstanceReadReplica',
    'DatabaseReadReplicaDirectAccess',
    'DatabaseReadReplicaPrivateNetwork',
    'DomainRecordGeoIp',
    'DomainRecordGeoIpMatch',
    'DomainRecordHttpService',
    'DomainRecordView',
    'DomainRecordWeighted',
    'FunctionTriggerNats',
    'FunctionTriggerSqs',
    'IamPolicyRule',
    'InferenceDeploymentPrivateEndpoint',
    'InferenceDeploymentPublicEndpoint',
    'InstanceImageAdditionalVolume',
    'InstanceSecurityGroupInboundRule',
    'InstanceSecurityGroupOutboundRule',
    'InstanceSecurityGroupRulesInboundRule',
    'InstanceSecurityGroupRulesOutboundRule',
    'InstanceServerPrivateNetwork',
    'InstanceServerPublicIp',
    'InstanceServerRootVolume',
    'InstanceSnapshotImport',
    'IotDeviceCertificate',
    'IotDeviceMessageFilters',
    'IotDeviceMessageFiltersPublish',
    'IotDeviceMessageFiltersSubscribe',
    'IotRouteDatabase',
    'IotRouteRest',
    'IotRouteS3',
    'IpamIpCustomResource',
    'IpamIpResource',
    'IpamIpReverse',
    'IpamIpSource',
    'JobDefinitionCron',
    'KubernetesClusterAutoUpgrade',
    'KubernetesClusterAutoscalerConfig',
    'KubernetesClusterKubeconfig',
    'KubernetesClusterOpenIdConnectConfig',
    'KubernetesNodePoolNode',
    'KubernetesNodePoolUpgradePolicy',
    'LoadbalancerAclAction',
    'LoadbalancerAclActionRedirect',
    'LoadbalancerAclMatch',
    'LoadbalancerBackendHealthCheckHttp',
    'LoadbalancerBackendHealthCheckHttps',
    'LoadbalancerBackendHealthCheckTcp',
    'LoadbalancerCertificateCustomCertificate',
    'LoadbalancerCertificateLetsencrypt',
    'LoadbalancerFrontendAcl',
    'LoadbalancerFrontendAclAction',
    'LoadbalancerFrontendAclActionRedirect',
    'LoadbalancerFrontendAclMatch',
    'LoadbalancerPrivateNetwork',
    'MnqSnsCredentialsPermissions',
    'MnqSqsCredentialsPermissions',
    'MongoDbInstancePublicNetwork',
    'ObjectBucketAclAccessControlPolicy',
    'ObjectBucketAclAccessControlPolicyGrant',
    'ObjectBucketAclAccessControlPolicyGrantGrantee',
    'ObjectBucketAclAccessControlPolicyOwner',
    'ObjectBucketCorsRule',
    'ObjectBucketLifecycleRule',
    'ObjectBucketLifecycleRuleExpiration',
    'ObjectBucketLifecycleRuleTransition',
    'ObjectBucketLockConfigurationRule',
    'ObjectBucketLockConfigurationRuleDefaultRetention',
    'ObjectBucketVersioning',
    'ObjectBucketWebsiteConfigurationErrorDocument',
    'ObjectBucketWebsiteConfigurationIndexDocument',
    'RedisClusterAcl',
    'RedisClusterPrivateNetwork',
    'RedisClusterPublicNetwork',
    'SecretEphemeralPolicy',
    'TemDomainReputation',
    'VpcGatewayNetworkIpamConfig',
    'VpcPrivateNetworkIpv4Subnet',
    'VpcPrivateNetworkIpv6Subnet',
    'WebhostingCpanelUrl',
    'WebhostingOption',
    'GetBaremetalOfferCpuResult',
    'GetBaremetalOfferDiskResult',
    'GetBaremetalOfferMemoryResult',
    'GetBaremetalServerIpResult',
    'GetBaremetalServerIpv4Result',
    'GetBaremetalServerIpv6Result',
    'GetBaremetalServerOptionResult',
    'GetBaremetalServerPrivateNetworkResult',
    'GetBillingConsumptionsConsumptionResult',
    'GetBillingInvoicesInvoiceResult',
    'GetCockpitEndpointResult',
    'GetCockpitPushUrlResult',
    'GetDatabaseAclAclRuleResult',
    'GetDatabaseInstanceLoadBalancerResult',
    'GetDatabaseInstanceLogsPolicyResult',
    'GetDatabaseInstancePrivateNetworkResult',
    'GetDatabaseInstanceReadReplicaResult',
    'GetDomainRecordGeoIpResult',
    'GetDomainRecordGeoIpMatchResult',
    'GetDomainRecordHttpServiceResult',
    'GetDomainRecordViewResult',
    'GetDomainRecordWeightedResult',
    'GetFlexibleIpsIpResult',
    'GetFlexibleIpsIpMacAddressResult',
    'GetInstanceSecurityGroupInboundRuleResult',
    'GetInstanceSecurityGroupOutboundRuleResult',
    'GetInstanceServerPrivateNetworkResult',
    'GetInstanceServerPublicIpResult',
    'GetInstanceServerRootVolumeResult',
    'GetInstanceServersServerResult',
    'GetInstanceServersServerPublicIpResult',
    'GetInstanceSnapshotImportResult',
    'GetIotDeviceCertificateResult',
    'GetIotDeviceMessageFilterResult',
    'GetIotDeviceMessageFilterPublishResult',
    'GetIotDeviceMessageFilterSubscribeResult',
    'GetIpamIpResourceResult',
    'GetIpamIpsIpResult',
    'GetIpamIpsIpResourceResult',
    'GetIpamIpsResourceResult',
    'GetKubernetesClusterAutoUpgradeResult',
    'GetKubernetesClusterAutoscalerConfigResult',
    'GetKubernetesClusterKubeconfigResult',
    'GetKubernetesClusterOpenIdConnectConfigResult',
    'GetKubernetesNodePoolNodeResult',
    'GetKubernetesNodePoolUpgradePolicyResult',
    'GetLbAclsAclResult',
    'GetLbAclsAclActionResult',
    'GetLbAclsAclActionRedirectResult',
    'GetLbAclsAclMatchResult',
    'GetLbBackendHealthCheckHttpResult',
    'GetLbBackendHealthCheckTcpResult',
    'GetLbBackendsBackendResult',
    'GetLbBackendsBackendHealthCheckHttpResult',
    'GetLbBackendsBackendHealthCheckTcpResult',
    'GetLbFrontendAclResult',
    'GetLbFrontendAclActionResult',
    'GetLbFrontendAclActionRedirectResult',
    'GetLbFrontendAclMatchResult',
    'GetLbFrontendsFrontendResult',
    'GetLbIpsIpResult',
    'GetLbRoutesRouteResult',
    'GetLbsLbResult',
    'GetLbsLbInstanceResult',
    'GetLbsLbIpResult',
    'GetLoadbalancerCertificateCustomCertificateResult',
    'GetLoadbalancerCertificateLetsencryptResult',
    'GetLoadbalancerPrivateNetworkResult',
    'GetMongoDbInstancePublicNetworkResult',
    'GetObjectBucketCorsRuleResult',
    'GetObjectBucketLifecycleRuleResult',
    'GetObjectBucketLifecycleRuleExpirationResult',
    'GetObjectBucketLifecycleRuleTransitionResult',
    'GetObjectBucketVersioningResult',
    'GetRedisClusterAclResult',
    'GetRedisClusterPrivateNetworkResult',
    'GetRedisClusterPublicNetworkResult',
    'GetSecretEphemeralPolicyResult',
    'GetTemDomainReputationResult',
    'GetVpcGatewayNetworkIpamConfigResult',
    'GetVpcPrivateNetworkIpv4SubnetResult',
    'GetVpcPrivateNetworkIpv6SubnetResult',
    'GetVpcRoutesRouteResult',
    'GetVpcsVpcResult',
    'GetWebHostOfferProductResult',
    'GetWebhostingCpanelUrlResult',
    'GetWebhostingOptionResult',
]

@pulumi.output_type
class BaremetalServerIp(dict):
    def __init__(__self__, *,
                 address: Optional[str] = None,
                 id: Optional[str] = None,
                 reverse: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param str address: The address of the IPv6.
        :param str id: The ID of the IPv6.
        :param str reverse: The reverse of the IPv6.
        :param str version: The type of the IPv6.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if reverse is not None:
            pulumi.set(__self__, "reverse", reverse)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        """
        The address of the IPv6.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the IPv6.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def reverse(self) -> Optional[str]:
        """
        The reverse of the IPv6.
        """
        return pulumi.get(self, "reverse")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        The type of the IPv6.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class BaremetalServerIpv4(dict):
    def __init__(__self__, *,
                 address: Optional[str] = None,
                 id: Optional[str] = None,
                 reverse: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param str address: The address of the IPv6.
        :param str id: The ID of the IPv6.
        :param str reverse: The reverse of the IPv6.
        :param str version: The type of the IPv6.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if reverse is not None:
            pulumi.set(__self__, "reverse", reverse)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        """
        The address of the IPv6.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the IPv6.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def reverse(self) -> Optional[str]:
        """
        The reverse of the IPv6.
        """
        return pulumi.get(self, "reverse")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        The type of the IPv6.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class BaremetalServerIpv6(dict):
    def __init__(__self__, *,
                 address: Optional[str] = None,
                 id: Optional[str] = None,
                 reverse: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param str address: The address of the IPv6.
        :param str id: The ID of the IPv6.
        :param str reverse: The reverse of the IPv6.
        :param str version: The type of the IPv6.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if reverse is not None:
            pulumi.set(__self__, "reverse", reverse)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        """
        The address of the IPv6.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the IPv6.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def reverse(self) -> Optional[str]:
        """
        The reverse of the IPv6.
        """
        return pulumi.get(self, "reverse")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        The type of the IPv6.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class BaremetalServerOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "expiresAt":
            suggest = "expires_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BaremetalServerOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BaremetalServerOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BaremetalServerOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 expires_at: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str id: The id of the option to enable. Use [this endpoint](https://www.scaleway.com/en/developers/api/elastic-metal/#path-options-list-options) to find the available options IDs.
        :param str expires_at: The auto expiration date for compatible options
        :param str name: The name of the server.
        """
        pulumi.set(__self__, "id", id)
        if expires_at is not None:
            pulumi.set(__self__, "expires_at", expires_at)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The id of the option to enable. Use [this endpoint](https://www.scaleway.com/en/developers/api/elastic-metal/#path-options-list-options) to find the available options IDs.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> Optional[str]:
        """
        The auto expiration date for compatible options
        """
        return pulumi.get(self, "expires_at")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the server.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class BaremetalServerPrivateNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "ipamIpIds":
            suggest = "ipam_ip_ids"
        elif key == "updatedAt":
            suggest = "updated_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BaremetalServerPrivateNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BaremetalServerPrivateNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BaremetalServerPrivateNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 created_at: Optional[str] = None,
                 ipam_ip_ids: Optional[Sequence[str]] = None,
                 status: Optional[str] = None,
                 updated_at: Optional[str] = None,
                 vlan: Optional[int] = None):
        """
        :param str id: The id of the private network to attach.
        :param str created_at: The date and time of the creation of the private network.
        :param Sequence[str] ipam_ip_ids: List of IPAM IP IDs to assign to the server in the requested private network.
        :param str status: The private network status.
        :param str updated_at: The date and time of the last update of the private network.
        :param int vlan: The VLAN ID associated to the private network.
        """
        pulumi.set(__self__, "id", id)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if ipam_ip_ids is not None:
            pulumi.set(__self__, "ipam_ip_ids", ipam_ip_ids)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if vlan is not None:
            pulumi.set(__self__, "vlan", vlan)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The id of the private network to attach.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[str]:
        """
        The date and time of the creation of the private network.
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="ipamIpIds")
    def ipam_ip_ids(self) -> Optional[Sequence[str]]:
        """
        List of IPAM IP IDs to assign to the server in the requested private network.
        """
        return pulumi.get(self, "ipam_ip_ids")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        The private network status.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[str]:
        """
        The date and time of the last update of the private network.
        """
        return pulumi.get(self, "updated_at")

    @property
    @pulumi.getter
    def vlan(self) -> Optional[int]:
        """
        The VLAN ID associated to the private network.
        """
        return pulumi.get(self, "vlan")


@pulumi.output_type
class CockpitAlertManagerContactPoint(dict):
    def __init__(__self__, *,
                 email: Optional[str] = None):
        """
        :param str email: Email addresses for the alert receivers
        """
        if email is not None:
            pulumi.set(__self__, "email", email)

    @property
    @pulumi.getter
    def email(self) -> Optional[str]:
        """
        Email addresses for the alert receivers
        """
        return pulumi.get(self, "email")


@pulumi.output_type
class CockpitEndpoint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertmanagerUrl":
            suggest = "alertmanager_url"
        elif key == "grafanaUrl":
            suggest = "grafana_url"
        elif key == "logsUrl":
            suggest = "logs_url"
        elif key == "metricsUrl":
            suggest = "metrics_url"
        elif key == "tracesUrl":
            suggest = "traces_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CockpitEndpoint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CockpitEndpoint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CockpitEndpoint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alertmanager_url: Optional[str] = None,
                 grafana_url: Optional[str] = None,
                 logs_url: Optional[str] = None,
                 metrics_url: Optional[str] = None,
                 traces_url: Optional[str] = None):
        """
        :param str alertmanager_url: (Deprecated) URL for the [Alert manager](https://www.scaleway.com/en/docs/observability/cockpit/concepts/#alert-manager).
        :param str grafana_url: (Deprecated) URL for Grafana.
        :param str logs_url: (Deprecated) URL for [logs](https://www.scaleway.com/en/docs/observability/cockpit/concepts/#logs) to retrieve in the [Data sources tab](https://console.scaleway.com/cockpit/dataSource) of the Scaleway console.
        :param str metrics_url: (Deprecated) URL for [metrics](https://www.scaleway.com/en/docs/observability/cockpit/concepts/#metric) to retrieve in the [Data sources tab](https://console.scaleway.com/cockpit/dataSource) of the Scaleway console.
        :param str traces_url: (Deprecated) URL for [traces](https://www.scaleway.com/en/docs/observability/cockpit/concepts/#traces) to retrieve in the [Data sources tab](https://console.scaleway.com/cockpit/dataSource) of the Scaleway console.
        """
        if alertmanager_url is not None:
            pulumi.set(__self__, "alertmanager_url", alertmanager_url)
        if grafana_url is not None:
            pulumi.set(__self__, "grafana_url", grafana_url)
        if logs_url is not None:
            pulumi.set(__self__, "logs_url", logs_url)
        if metrics_url is not None:
            pulumi.set(__self__, "metrics_url", metrics_url)
        if traces_url is not None:
            pulumi.set(__self__, "traces_url", traces_url)

    @property
    @pulumi.getter(name="alertmanagerUrl")
    def alertmanager_url(self) -> Optional[str]:
        """
        (Deprecated) URL for the [Alert manager](https://www.scaleway.com/en/docs/observability/cockpit/concepts/#alert-manager).
        """
        return pulumi.get(self, "alertmanager_url")

    @property
    @pulumi.getter(name="grafanaUrl")
    def grafana_url(self) -> Optional[str]:
        """
        (Deprecated) URL for Grafana.
        """
        return pulumi.get(self, "grafana_url")

    @property
    @pulumi.getter(name="logsUrl")
    def logs_url(self) -> Optional[str]:
        """
        (Deprecated) URL for [logs](https://www.scaleway.com/en/docs/observability/cockpit/concepts/#logs) to retrieve in the [Data sources tab](https://console.scaleway.com/cockpit/dataSource) of the Scaleway console.
        """
        return pulumi.get(self, "logs_url")

    @property
    @pulumi.getter(name="metricsUrl")
    def metrics_url(self) -> Optional[str]:
        """
        (Deprecated) URL for [metrics](https://www.scaleway.com/en/docs/observability/cockpit/concepts/#metric) to retrieve in the [Data sources tab](https://console.scaleway.com/cockpit/dataSource) of the Scaleway console.
        """
        return pulumi.get(self, "metrics_url")

    @property
    @pulumi.getter(name="tracesUrl")
    def traces_url(self) -> Optional[str]:
        """
        (Deprecated) URL for [traces](https://www.scaleway.com/en/docs/observability/cockpit/concepts/#traces) to retrieve in the [Data sources tab](https://console.scaleway.com/cockpit/dataSource) of the Scaleway console.
        """
        return pulumi.get(self, "traces_url")


@pulumi.output_type
class CockpitPushUrl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pushLogsUrl":
            suggest = "push_logs_url"
        elif key == "pushMetricsUrl":
            suggest = "push_metrics_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CockpitPushUrl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CockpitPushUrl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CockpitPushUrl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 push_logs_url: Optional[str] = None,
                 push_metrics_url: Optional[str] = None):
        """
        :param str push_logs_url: Push URL for logs (Grafana Loki)
        :param str push_metrics_url: Push URL for metrics (Grafana Mimir)
        """
        if push_logs_url is not None:
            pulumi.set(__self__, "push_logs_url", push_logs_url)
        if push_metrics_url is not None:
            pulumi.set(__self__, "push_metrics_url", push_metrics_url)

    @property
    @pulumi.getter(name="pushLogsUrl")
    def push_logs_url(self) -> Optional[str]:
        """
        Push URL for logs (Grafana Loki)
        """
        return pulumi.get(self, "push_logs_url")

    @property
    @pulumi.getter(name="pushMetricsUrl")
    def push_metrics_url(self) -> Optional[str]:
        """
        Push URL for metrics (Grafana Mimir)
        """
        return pulumi.get(self, "push_metrics_url")


@pulumi.output_type
class CockpitTokenScopes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryLogs":
            suggest = "query_logs"
        elif key == "queryMetrics":
            suggest = "query_metrics"
        elif key == "queryTraces":
            suggest = "query_traces"
        elif key == "setupAlerts":
            suggest = "setup_alerts"
        elif key == "setupLogsRules":
            suggest = "setup_logs_rules"
        elif key == "setupMetricsRules":
            suggest = "setup_metrics_rules"
        elif key == "writeLogs":
            suggest = "write_logs"
        elif key == "writeMetrics":
            suggest = "write_metrics"
        elif key == "writeTraces":
            suggest = "write_traces"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CockpitTokenScopes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CockpitTokenScopes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CockpitTokenScopes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query_logs: Optional[bool] = None,
                 query_metrics: Optional[bool] = None,
                 query_traces: Optional[bool] = None,
                 setup_alerts: Optional[bool] = None,
                 setup_logs_rules: Optional[bool] = None,
                 setup_metrics_rules: Optional[bool] = None,
                 write_logs: Optional[bool] = None,
                 write_metrics: Optional[bool] = None,
                 write_traces: Optional[bool] = None):
        """
        :param bool query_logs: Permission to query logs.
        :param bool query_metrics: Permission to query metrics.
        :param bool query_traces: Permission to query traces.
        :param bool setup_alerts: Permission to set up alerts.
        :param bool setup_logs_rules: Permission to set up logs rules.
        :param bool setup_metrics_rules: Permission to set up metrics rules.
        :param bool write_logs: Permission to write logs.
        :param bool write_metrics: Permission to write metrics.
        :param bool write_traces: Permission to write traces.
        """
        if query_logs is not None:
            pulumi.set(__self__, "query_logs", query_logs)
        if query_metrics is not None:
            pulumi.set(__self__, "query_metrics", query_metrics)
        if query_traces is not None:
            pulumi.set(__self__, "query_traces", query_traces)
        if setup_alerts is not None:
            pulumi.set(__self__, "setup_alerts", setup_alerts)
        if setup_logs_rules is not None:
            pulumi.set(__self__, "setup_logs_rules", setup_logs_rules)
        if setup_metrics_rules is not None:
            pulumi.set(__self__, "setup_metrics_rules", setup_metrics_rules)
        if write_logs is not None:
            pulumi.set(__self__, "write_logs", write_logs)
        if write_metrics is not None:
            pulumi.set(__self__, "write_metrics", write_metrics)
        if write_traces is not None:
            pulumi.set(__self__, "write_traces", write_traces)

    @property
    @pulumi.getter(name="queryLogs")
    def query_logs(self) -> Optional[bool]:
        """
        Permission to query logs.
        """
        return pulumi.get(self, "query_logs")

    @property
    @pulumi.getter(name="queryMetrics")
    def query_metrics(self) -> Optional[bool]:
        """
        Permission to query metrics.
        """
        return pulumi.get(self, "query_metrics")

    @property
    @pulumi.getter(name="queryTraces")
    def query_traces(self) -> Optional[bool]:
        """
        Permission to query traces.
        """
        return pulumi.get(self, "query_traces")

    @property
    @pulumi.getter(name="setupAlerts")
    def setup_alerts(self) -> Optional[bool]:
        """
        Permission to set up alerts.
        """
        return pulumi.get(self, "setup_alerts")

    @property
    @pulumi.getter(name="setupLogsRules")
    def setup_logs_rules(self) -> Optional[bool]:
        """
        Permission to set up logs rules.
        """
        return pulumi.get(self, "setup_logs_rules")

    @property
    @pulumi.getter(name="setupMetricsRules")
    def setup_metrics_rules(self) -> Optional[bool]:
        """
        Permission to set up metrics rules.
        """
        return pulumi.get(self, "setup_metrics_rules")

    @property
    @pulumi.getter(name="writeLogs")
    def write_logs(self) -> Optional[bool]:
        """
        Permission to write logs.
        """
        return pulumi.get(self, "write_logs")

    @property
    @pulumi.getter(name="writeMetrics")
    def write_metrics(self) -> Optional[bool]:
        """
        Permission to write metrics.
        """
        return pulumi.get(self, "write_metrics")

    @property
    @pulumi.getter(name="writeTraces")
    def write_traces(self) -> Optional[bool]:
        """
        Permission to write traces.
        """
        return pulumi.get(self, "write_traces")


@pulumi.output_type
class ContainerTriggerNats(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountId":
            suggest = "account_id"
        elif key == "projectId":
            suggest = "project_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContainerTriggerNats. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContainerTriggerNats.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContainerTriggerNats.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subject: str,
                 account_id: Optional[str] = None,
                 project_id: Optional[str] = None,
                 region: Optional[str] = None):
        """
        :param str subject: The subject to listen to.
        :param str account_id: unique identifier of the Messaging and Queuing NATS account.
        :param str project_id: THe ID of the project that contains the Messaging and Queuing NATS account (defaults to provider `project_id`)
        :param str region: Region where the Messaging and Queuing NATS account is enabled (defaults to provider `region`)
        """
        pulumi.set(__self__, "subject", subject)
        if account_id is not None:
            pulumi.set(__self__, "account_id", account_id)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def subject(self) -> str:
        """
        The subject to listen to.
        """
        return pulumi.get(self, "subject")

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> Optional[str]:
        """
        unique identifier of the Messaging and Queuing NATS account.
        """
        return pulumi.get(self, "account_id")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[str]:
        """
        THe ID of the project that contains the Messaging and Queuing NATS account (defaults to provider `project_id`)
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        Region where the Messaging and Queuing NATS account is enabled (defaults to provider `region`)
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class ContainerTriggerSqs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "namespaceId":
            suggest = "namespace_id"
        elif key == "projectId":
            suggest = "project_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContainerTriggerSqs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContainerTriggerSqs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContainerTriggerSqs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 queue: str,
                 namespace_id: Optional[str] = None,
                 project_id: Optional[str] = None,
                 region: Optional[str] = None):
        """
        :param str queue: The name of the SQS queue.
        :param str namespace_id: ID of the Messaging and Queuing namespace. This argument is deprecated.
        :param str project_id: The ID of the project in which SQS is enabled, (defaults to provider `project_id`)
        :param str region: Region where SQS is enabled (defaults to provider `region`)
        """
        pulumi.set(__self__, "queue", queue)
        if namespace_id is not None:
            pulumi.set(__self__, "namespace_id", namespace_id)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def queue(self) -> str:
        """
        The name of the SQS queue.
        """
        return pulumi.get(self, "queue")

    @property
    @pulumi.getter(name="namespaceId")
    @_utilities.deprecated("""The 'namespace_id' field is deprecated and will be removed in the next major version. It is no longer necessary to specify it""")
    def namespace_id(self) -> Optional[str]:
        """
        ID of the Messaging and Queuing namespace. This argument is deprecated.
        """
        return pulumi.get(self, "namespace_id")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[str]:
        """
        The ID of the project in which SQS is enabled, (defaults to provider `project_id`)
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        Region where SQS is enabled (defaults to provider `region`)
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class DatabaseAclAclRule(dict):
    def __init__(__self__, *,
                 ip: str,
                 description: Optional[str] = None):
        """
        :param str ip: The IP range to whitelist in [CIDR notation](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#CIDR_notation)
        :param str description: A text describing this rule. Default description: `IP allowed`
        """
        pulumi.set(__self__, "ip", ip)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        The IP range to whitelist in [CIDR notation](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#CIDR_notation)
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        A text describing this rule. Default description: `IP allowed`
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class DatabaseInstanceLoadBalancer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endpointId":
            suggest = "endpoint_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseInstanceLoadBalancer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseInstanceLoadBalancer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseInstanceLoadBalancer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint_id: Optional[str] = None,
                 hostname: Optional[str] = None,
                 ip: Optional[str] = None,
                 name: Optional[str] = None,
                 port: Optional[int] = None):
        """
        :param str endpoint_id: The ID of the endpoint.
        :param str hostname: Hostname of the endpoint.
        :param str ip: IPv4 address on the network.
        :param str name: The name of the Database Instance.
        :param int port: Port in the Private Network.
        """
        if endpoint_id is not None:
            pulumi.set(__self__, "endpoint_id", endpoint_id)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> Optional[str]:
        """
        The ID of the endpoint.
        """
        return pulumi.get(self, "endpoint_id")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        Hostname of the endpoint.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        """
        IPv4 address on the network.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the Database Instance.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port in the Private Network.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class DatabaseInstanceLogsPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxAgeRetention":
            suggest = "max_age_retention"
        elif key == "totalDiskRetention":
            suggest = "total_disk_retention"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseInstanceLogsPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseInstanceLogsPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseInstanceLogsPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_age_retention: Optional[int] = None,
                 total_disk_retention: Optional[int] = None):
        """
        :param int max_age_retention: The max age (in days) of remote logs to keep on the Database Instance
        :param int total_disk_retention: The max disk size of remote logs to keep on the Database Instance.
        """
        if max_age_retention is not None:
            pulumi.set(__self__, "max_age_retention", max_age_retention)
        if total_disk_retention is not None:
            pulumi.set(__self__, "total_disk_retention", total_disk_retention)

    @property
    @pulumi.getter(name="maxAgeRetention")
    def max_age_retention(self) -> Optional[int]:
        """
        The max age (in days) of remote logs to keep on the Database Instance
        """
        return pulumi.get(self, "max_age_retention")

    @property
    @pulumi.getter(name="totalDiskRetention")
    def total_disk_retention(self) -> Optional[int]:
        """
        The max disk size of remote logs to keep on the Database Instance.
        """
        return pulumi.get(self, "total_disk_retention")


@pulumi.output_type
class DatabaseInstancePrivateNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pnId":
            suggest = "pn_id"
        elif key == "enableIpam":
            suggest = "enable_ipam"
        elif key == "endpointId":
            suggest = "endpoint_id"
        elif key == "ipNet":
            suggest = "ip_net"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseInstancePrivateNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseInstancePrivateNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseInstancePrivateNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pn_id: str,
                 enable_ipam: Optional[bool] = None,
                 endpoint_id: Optional[str] = None,
                 hostname: Optional[str] = None,
                 ip: Optional[str] = None,
                 ip_net: Optional[str] = None,
                 name: Optional[str] = None,
                 port: Optional[int] = None,
                 zone: Optional[str] = None):
        """
        :param str pn_id: The private network ID
        :param bool enable_ipam: Whether or not the private network endpoint should be configured with IPAM
        :param str endpoint_id: The ID of the endpoint.
        :param str hostname: Hostname of the endpoint.
        :param str ip: IPv4 address on the network.
        :param str ip_net: The IP with the given mask within the private subnet
        :param str name: The name of the Database Instance.
        :param int port: Port in the Private Network.
        :param str zone: The zone you want to attach the resource to
        """
        pulumi.set(__self__, "pn_id", pn_id)
        if enable_ipam is not None:
            pulumi.set(__self__, "enable_ipam", enable_ipam)
        if endpoint_id is not None:
            pulumi.set(__self__, "endpoint_id", endpoint_id)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ip_net is not None:
            pulumi.set(__self__, "ip_net", ip_net)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if zone is not None:
            pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter(name="pnId")
    def pn_id(self) -> str:
        """
        The private network ID
        """
        return pulumi.get(self, "pn_id")

    @property
    @pulumi.getter(name="enableIpam")
    def enable_ipam(self) -> Optional[bool]:
        """
        Whether or not the private network endpoint should be configured with IPAM
        """
        return pulumi.get(self, "enable_ipam")

    @property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> Optional[str]:
        """
        The ID of the endpoint.
        """
        return pulumi.get(self, "endpoint_id")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        Hostname of the endpoint.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        """
        IPv4 address on the network.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="ipNet")
    def ip_net(self) -> Optional[str]:
        """
        The IP with the given mask within the private subnet
        """
        return pulumi.get(self, "ip_net")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the Database Instance.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port in the Private Network.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def zone(self) -> Optional[str]:
        """
        The zone you want to attach the resource to
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class DatabaseInstanceReadReplica(dict):
    def __init__(__self__, *,
                 ip: Optional[str] = None,
                 name: Optional[str] = None,
                 port: Optional[int] = None):
        """
        :param str ip: IPv4 address on the network.
        :param str name: The name of the Database Instance.
        :param int port: Port in the Private Network.
        """
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        """
        IPv4 address on the network.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the Database Instance.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port in the Private Network.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class DatabaseReadReplicaDirectAccess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endpointId":
            suggest = "endpoint_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseReadReplicaDirectAccess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseReadReplicaDirectAccess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseReadReplicaDirectAccess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint_id: Optional[str] = None,
                 hostname: Optional[str] = None,
                 ip: Optional[str] = None,
                 name: Optional[str] = None,
                 port: Optional[int] = None):
        """
        :param str endpoint_id: The ID of the endpoint of the Read Replica.
        :param str hostname: Hostname of the endpoint. Only one of IP and hostname may be set.
        :param str ip: IPv4 address of the endpoint (IP address). Only one of IP and hostname may be set.
        :param str name: Name of the endpoint.
        :param int port: TCP port of the endpoint.
        """
        if endpoint_id is not None:
            pulumi.set(__self__, "endpoint_id", endpoint_id)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> Optional[str]:
        """
        The ID of the endpoint of the Read Replica.
        """
        return pulumi.get(self, "endpoint_id")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        Hostname of the endpoint. Only one of IP and hostname may be set.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        """
        IPv4 address of the endpoint (IP address). Only one of IP and hostname may be set.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the endpoint.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        TCP port of the endpoint.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class DatabaseReadReplicaPrivateNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateNetworkId":
            suggest = "private_network_id"
        elif key == "enableIpam":
            suggest = "enable_ipam"
        elif key == "endpointId":
            suggest = "endpoint_id"
        elif key == "serviceIp":
            suggest = "service_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseReadReplicaPrivateNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseReadReplicaPrivateNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseReadReplicaPrivateNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 private_network_id: str,
                 enable_ipam: Optional[bool] = None,
                 endpoint_id: Optional[str] = None,
                 hostname: Optional[str] = None,
                 ip: Optional[str] = None,
                 name: Optional[str] = None,
                 port: Optional[int] = None,
                 service_ip: Optional[str] = None,
                 zone: Optional[str] = None):
        """
        :param str private_network_id: UUID of the Private Netork to be connected to the Read Replica.
        :param bool enable_ipam: If true, the IP network address within the private subnet is determined by the IP Address Management (IPAM) service.
               
               > **Important:** One of `service_ip` or `enable_ipam=true` must be set.
        :param str endpoint_id: The ID of the endpoint of the Read Replica.
        :param str hostname: Hostname of the endpoint. Only one of IP and hostname may be set.
        :param str ip: IPv4 address of the endpoint (IP address). Only one of IP and hostname may be set.
        :param str name: Name of the endpoint.
        :param int port: TCP port of the endpoint.
        :param str service_ip: The IP network address within the private subnet. This must be an IPv4 address with a CIDR notation. If not set, The IP network address within the private subnet is determined by the IP Address Management (IPAM) service.
        :param str zone: Private network zone
        """
        pulumi.set(__self__, "private_network_id", private_network_id)
        if enable_ipam is not None:
            pulumi.set(__self__, "enable_ipam", enable_ipam)
        if endpoint_id is not None:
            pulumi.set(__self__, "endpoint_id", endpoint_id)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if service_ip is not None:
            pulumi.set(__self__, "service_ip", service_ip)
        if zone is not None:
            pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter(name="privateNetworkId")
    def private_network_id(self) -> str:
        """
        UUID of the Private Netork to be connected to the Read Replica.
        """
        return pulumi.get(self, "private_network_id")

    @property
    @pulumi.getter(name="enableIpam")
    def enable_ipam(self) -> Optional[bool]:
        """
        If true, the IP network address within the private subnet is determined by the IP Address Management (IPAM) service.

        > **Important:** One of `service_ip` or `enable_ipam=true` must be set.
        """
        return pulumi.get(self, "enable_ipam")

    @property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> Optional[str]:
        """
        The ID of the endpoint of the Read Replica.
        """
        return pulumi.get(self, "endpoint_id")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        Hostname of the endpoint. Only one of IP and hostname may be set.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        """
        IPv4 address of the endpoint (IP address). Only one of IP and hostname may be set.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the endpoint.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        TCP port of the endpoint.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="serviceIp")
    def service_ip(self) -> Optional[str]:
        """
        The IP network address within the private subnet. This must be an IPv4 address with a CIDR notation. If not set, The IP network address within the private subnet is determined by the IP Address Management (IPAM) service.
        """
        return pulumi.get(self, "service_ip")

    @property
    @pulumi.getter
    def zone(self) -> Optional[str]:
        """
        Private network zone
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class DomainRecordGeoIp(dict):
    def __init__(__self__, *,
                 matches: Sequence['outputs.DomainRecordGeoIpMatch']):
        """
        :param Sequence['DomainRecordGeoIpMatchArgs'] matches: The list of matches
        """
        pulumi.set(__self__, "matches", matches)

    @property
    @pulumi.getter
    def matches(self) -> Sequence['outputs.DomainRecordGeoIpMatch']:
        """
        The list of matches
        """
        return pulumi.get(self, "matches")


@pulumi.output_type
class DomainRecordGeoIpMatch(dict):
    def __init__(__self__, *,
                 data: str,
                 continents: Optional[Sequence[str]] = None,
                 countries: Optional[Sequence[str]] = None):
        """
        :param str data: The content of the record (an IPv4 for an `A` record, a string for a `TXT` record, etc.).
        :param Sequence[str] continents: List of continents (eg: EU for Europe, NA for North America, AS for Asia...). List of all continents code: https://api.scaleway.com/domain-private/v2beta1/continents
        :param Sequence[str] countries: List of countries (eg: FR for France, US for the United States, GB for Great Britain...). List of all countries code: https://api.scaleway.com/domain-private/v2beta1/countries
        """
        pulumi.set(__self__, "data", data)
        if continents is not None:
            pulumi.set(__self__, "continents", continents)
        if countries is not None:
            pulumi.set(__self__, "countries", countries)

    @property
    @pulumi.getter
    def data(self) -> str:
        """
        The content of the record (an IPv4 for an `A` record, a string for a `TXT` record, etc.).
        """
        return pulumi.get(self, "data")

    @property
    @pulumi.getter
    def continents(self) -> Optional[Sequence[str]]:
        """
        List of continents (eg: EU for Europe, NA for North America, AS for Asia...). List of all continents code: https://api.scaleway.com/domain-private/v2beta1/continents
        """
        return pulumi.get(self, "continents")

    @property
    @pulumi.getter
    def countries(self) -> Optional[Sequence[str]]:
        """
        List of countries (eg: FR for France, US for the United States, GB for Great Britain...). List of all countries code: https://api.scaleway.com/domain-private/v2beta1/countries
        """
        return pulumi.get(self, "countries")


@pulumi.output_type
class DomainRecordHttpService(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mustContain":
            suggest = "must_contain"
        elif key == "userAgent":
            suggest = "user_agent"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainRecordHttpService. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainRecordHttpService.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainRecordHttpService.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ips: Sequence[str],
                 must_contain: str,
                 strategy: str,
                 url: str,
                 user_agent: Optional[str] = None):
        """
        :param Sequence[str] ips: IPs to check
        :param str must_contain: Text to search
        :param str strategy: Strategy to return an IP from the IPs list
        :param str url: URL to match the must_contain text to validate an IP
        :param str user_agent: User-agent used when checking the URL
        """
        pulumi.set(__self__, "ips", ips)
        pulumi.set(__self__, "must_contain", must_contain)
        pulumi.set(__self__, "strategy", strategy)
        pulumi.set(__self__, "url", url)
        if user_agent is not None:
            pulumi.set(__self__, "user_agent", user_agent)

    @property
    @pulumi.getter
    def ips(self) -> Sequence[str]:
        """
        IPs to check
        """
        return pulumi.get(self, "ips")

    @property
    @pulumi.getter(name="mustContain")
    def must_contain(self) -> str:
        """
        Text to search
        """
        return pulumi.get(self, "must_contain")

    @property
    @pulumi.getter
    def strategy(self) -> str:
        """
        Strategy to return an IP from the IPs list
        """
        return pulumi.get(self, "strategy")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        URL to match the must_contain text to validate an IP
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="userAgent")
    def user_agent(self) -> Optional[str]:
        """
        User-agent used when checking the URL
        """
        return pulumi.get(self, "user_agent")


@pulumi.output_type
class DomainRecordView(dict):
    def __init__(__self__, *,
                 data: str,
                 subnet: str):
        """
        :param str data: The content of the record (an IPv4 for an `A` record, a string for a `TXT` record, etc.).
        :param str subnet: The subnet of the view
        """
        pulumi.set(__self__, "data", data)
        pulumi.set(__self__, "subnet", subnet)

    @property
    @pulumi.getter
    def data(self) -> str:
        """
        The content of the record (an IPv4 for an `A` record, a string for a `TXT` record, etc.).
        """
        return pulumi.get(self, "data")

    @property
    @pulumi.getter
    def subnet(self) -> str:
        """
        The subnet of the view
        """
        return pulumi.get(self, "subnet")


@pulumi.output_type
class DomainRecordWeighted(dict):
    def __init__(__self__, *,
                 ip: str,
                 weight: int):
        """
        :param str ip: The weighted IP
        :param int weight: The weight of the IP
        """
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        The weighted IP
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def weight(self) -> int:
        """
        The weight of the IP
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class FunctionTriggerNats(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountId":
            suggest = "account_id"
        elif key == "projectId":
            suggest = "project_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionTriggerNats. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionTriggerNats.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionTriggerNats.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subject: str,
                 account_id: Optional[str] = None,
                 project_id: Optional[str] = None,
                 region: Optional[str] = None):
        """
        :param str subject: The subject to listen to.
        :param str account_id: unique identifier of the Messaging and Queuing NATS account.
        :param str project_id: THe ID of the project that contains the Messaging and Queuing NATS account (defaults to provider `project_id`)
        :param str region: Region where the Messaging and Queuing NATS account is enabled (defaults to provider `region`)
        """
        pulumi.set(__self__, "subject", subject)
        if account_id is not None:
            pulumi.set(__self__, "account_id", account_id)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def subject(self) -> str:
        """
        The subject to listen to.
        """
        return pulumi.get(self, "subject")

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> Optional[str]:
        """
        unique identifier of the Messaging and Queuing NATS account.
        """
        return pulumi.get(self, "account_id")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[str]:
        """
        THe ID of the project that contains the Messaging and Queuing NATS account (defaults to provider `project_id`)
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        Region where the Messaging and Queuing NATS account is enabled (defaults to provider `region`)
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class FunctionTriggerSqs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "namespaceId":
            suggest = "namespace_id"
        elif key == "projectId":
            suggest = "project_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionTriggerSqs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionTriggerSqs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionTriggerSqs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 queue: str,
                 namespace_id: Optional[str] = None,
                 project_id: Optional[str] = None,
                 region: Optional[str] = None):
        """
        :param str queue: The name of the SQS queue.
        :param str namespace_id: ID of the Messaging and Queuing namespace. This argument is deprecated.
        :param str project_id: The ID of the project in which SQS is enabled, (defaults to provider `project_id`)
        :param str region: Region where SQS is enabled (defaults to provider `region`)
        """
        pulumi.set(__self__, "queue", queue)
        if namespace_id is not None:
            pulumi.set(__self__, "namespace_id", namespace_id)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def queue(self) -> str:
        """
        The name of the SQS queue.
        """
        return pulumi.get(self, "queue")

    @property
    @pulumi.getter(name="namespaceId")
    @_utilities.deprecated("""The 'namespace_id' field is deprecated and will be removed in the next major version. It is no longer necessary to specify it""")
    def namespace_id(self) -> Optional[str]:
        """
        ID of the Messaging and Queuing namespace. This argument is deprecated.
        """
        return pulumi.get(self, "namespace_id")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[str]:
        """
        The ID of the project in which SQS is enabled, (defaults to provider `project_id`)
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        Region where SQS is enabled (defaults to provider `region`)
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class IamPolicyRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "permissionSetNames":
            suggest = "permission_set_names"
        elif key == "organizationId":
            suggest = "organization_id"
        elif key == "projectIds":
            suggest = "project_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IamPolicyRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IamPolicyRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IamPolicyRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 permission_set_names: Sequence[str],
                 condition: Optional[str] = None,
                 organization_id: Optional[str] = None,
                 project_ids: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] permission_set_names: Names of permission sets bind to the rule.
               
               **_TIP:_** You can use the Scaleway CLI to list the permissions details. e.g:
               
               ```shell
               scw IAM permission-set list
               ```
        :param str condition: The condition of the IAM policy.
        :param str organization_id: ID of organization scoped to the rule, this can be used to create a rule for all projects in an organization.
        :param Sequence[str] project_ids: List of project IDs scoped to the rule.
               
               > **Important** One `organization_id` or `project_ids` must be set per rule.
        """
        pulumi.set(__self__, "permission_set_names", permission_set_names)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if organization_id is not None:
            pulumi.set(__self__, "organization_id", organization_id)
        if project_ids is not None:
            pulumi.set(__self__, "project_ids", project_ids)

    @property
    @pulumi.getter(name="permissionSetNames")
    def permission_set_names(self) -> Sequence[str]:
        """
        Names of permission sets bind to the rule.

        **_TIP:_** You can use the Scaleway CLI to list the permissions details. e.g:

        ```shell
        scw IAM permission-set list
        ```
        """
        return pulumi.get(self, "permission_set_names")

    @property
    @pulumi.getter
    def condition(self) -> Optional[str]:
        """
        The condition of the IAM policy.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter(name="organizationId")
    def organization_id(self) -> Optional[str]:
        """
        ID of organization scoped to the rule, this can be used to create a rule for all projects in an organization.
        """
        return pulumi.get(self, "organization_id")

    @property
    @pulumi.getter(name="projectIds")
    def project_ids(self) -> Optional[Sequence[str]]:
        """
        List of project IDs scoped to the rule.

        > **Important** One `organization_id` or `project_ids` must be set per rule.
        """
        return pulumi.get(self, "project_ids")


@pulumi.output_type
class InferenceDeploymentPrivateEndpoint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableAuth":
            suggest = "disable_auth"
        elif key == "privateNetworkId":
            suggest = "private_network_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InferenceDeploymentPrivateEndpoint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InferenceDeploymentPrivateEndpoint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InferenceDeploymentPrivateEndpoint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disable_auth: Optional[bool] = None,
                 id: Optional[str] = None,
                 private_network_id: Optional[str] = None,
                 url: Optional[str] = None):
        """
        :param bool disable_auth: Disable the authentication on the endpoint.
        :param str id: (Optional) The id of the public endpoint.
        :param str private_network_id: The ID of the private network to use.
        :param str url: (Optional) The URL of the endpoint.
        """
        if disable_auth is not None:
            pulumi.set(__self__, "disable_auth", disable_auth)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if private_network_id is not None:
            pulumi.set(__self__, "private_network_id", private_network_id)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter(name="disableAuth")
    def disable_auth(self) -> Optional[bool]:
        """
        Disable the authentication on the endpoint.
        """
        return pulumi.get(self, "disable_auth")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        (Optional) The id of the public endpoint.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="privateNetworkId")
    def private_network_id(self) -> Optional[str]:
        """
        The ID of the private network to use.
        """
        return pulumi.get(self, "private_network_id")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        (Optional) The URL of the endpoint.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class InferenceDeploymentPublicEndpoint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableAuth":
            suggest = "disable_auth"
        elif key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InferenceDeploymentPublicEndpoint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InferenceDeploymentPublicEndpoint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InferenceDeploymentPublicEndpoint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disable_auth: Optional[bool] = None,
                 id: Optional[str] = None,
                 is_enabled: Optional[bool] = None,
                 url: Optional[str] = None):
        """
        :param bool disable_auth: Disable the authentication on the endpoint.
        :param str id: (Optional) The id of the public endpoint.
        :param bool is_enabled: Enable or disable public endpoint.
        :param str url: (Optional) The URL of the endpoint.
        """
        if disable_auth is not None:
            pulumi.set(__self__, "disable_auth", disable_auth)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter(name="disableAuth")
    def disable_auth(self) -> Optional[bool]:
        """
        Disable the authentication on the endpoint.
        """
        return pulumi.get(self, "disable_auth")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        (Optional) The id of the public endpoint.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        Enable or disable public endpoint.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        (Optional) The URL of the endpoint.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class InstanceImageAdditionalVolume(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "creationDate":
            suggest = "creation_date"
        elif key == "exportUri":
            suggest = "export_uri"
        elif key == "modificationDate":
            suggest = "modification_date"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceImageAdditionalVolume. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceImageAdditionalVolume.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceImageAdditionalVolume.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 creation_date: Optional[str] = None,
                 export_uri: Optional[str] = None,
                 id: Optional[str] = None,
                 modification_date: Optional[str] = None,
                 name: Optional[str] = None,
                 organization: Optional[str] = None,
                 project: Optional[str] = None,
                 server: Optional[Mapping[str, str]] = None,
                 size: Optional[int] = None,
                 state: Optional[str] = None,
                 tags: Optional[Sequence[str]] = None,
                 volume_type: Optional[str] = None,
                 zone: Optional[str] = None):
        """
        :param str creation_date: Date of the volume creation.
        :param str export_uri: The export URI of the volume.
        :param str id: ID of the server containing the volume.
        :param str modification_date: Date of volume latest update.
        :param str name: The name of the image. If not provided it will be randomly generated.
        :param str organization: The organization ID the volume is associated with.
        :param str project: ID of the project the volume is associated with
        :param Mapping[str, str] server: Description of the server containing the volume (in case the image is a backup from a server).
        :param int size: The size of the volume.
        :param str state: State of the volume.
        :param Sequence[str] tags: A list of tags to apply to the image.
        :param str volume_type: The type of volume, possible values are `l_ssd` and `b_ssd`.
        :param str zone: The zone in which the image should be created.
        """
        if creation_date is not None:
            pulumi.set(__self__, "creation_date", creation_date)
        if export_uri is not None:
            pulumi.set(__self__, "export_uri", export_uri)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if modification_date is not None:
            pulumi.set(__self__, "modification_date", modification_date)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if organization is not None:
            pulumi.set(__self__, "organization", organization)
        if project is not None:
            pulumi.set(__self__, "project", project)
        if server is not None:
            pulumi.set(__self__, "server", server)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)
        if zone is not None:
            pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter(name="creationDate")
    def creation_date(self) -> Optional[str]:
        """
        Date of the volume creation.
        """
        return pulumi.get(self, "creation_date")

    @property
    @pulumi.getter(name="exportUri")
    def export_uri(self) -> Optional[str]:
        """
        The export URI of the volume.
        """
        return pulumi.get(self, "export_uri")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the server containing the volume.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="modificationDate")
    def modification_date(self) -> Optional[str]:
        """
        Date of volume latest update.
        """
        return pulumi.get(self, "modification_date")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the image. If not provided it will be randomly generated.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def organization(self) -> Optional[str]:
        """
        The organization ID the volume is associated with.
        """
        return pulumi.get(self, "organization")

    @property
    @pulumi.getter
    def project(self) -> Optional[str]:
        """
        ID of the project the volume is associated with
        """
        return pulumi.get(self, "project")

    @property
    @pulumi.getter
    def server(self) -> Optional[Mapping[str, str]]:
        """
        Description of the server containing the volume (in case the image is a backup from a server).
        """
        return pulumi.get(self, "server")

    @property
    @pulumi.getter
    def size(self) -> Optional[int]:
        """
        The size of the volume.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        State of the volume.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        """
        A list of tags to apply to the image.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[str]:
        """
        The type of volume, possible values are `l_ssd` and `b_ssd`.
        """
        return pulumi.get(self, "volume_type")

    @property
    @pulumi.getter
    def zone(self) -> Optional[str]:
        """
        The zone in which the image should be created.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class InstanceSecurityGroupInboundRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipRange":
            suggest = "ip_range"
        elif key == "portRange":
            suggest = "port_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceSecurityGroupInboundRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceSecurityGroupInboundRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceSecurityGroupInboundRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: str,
                 ip: Optional[str] = None,
                 ip_range: Optional[str] = None,
                 port: Optional[int] = None,
                 port_range: Optional[str] = None,
                 protocol: Optional[str] = None):
        """
        :param str action: The action to take when rule match. Possible values are: `accept` or `drop`.
        :param str ip: The ip this rule apply to. If no `ip` nor `ip_range` are specified, rule will apply to all ip. Only one of `ip` and `ip_range` should be specified.
        :param str ip_range: The ip range (e.g `192.168.1.0/24`) this rule applies to. If no `ip` nor `ip_range` are specified, rule will apply to all ip. Only one of `ip` and `ip_range` should be specified.
        :param int port: The port this rule applies to. If no `port` nor `port_range` are specified, the rule will apply to all port. Only one of `port` and `port_range` should be specified.
        :param str port_range: Computed port range for this rule (e.g: 1-1024, 22-22)
        :param str protocol: The protocol this rule apply to. Possible values are: `TCP`, `UDP`, `ICMP` or `ANY`.
        """
        pulumi.set(__self__, "action", action)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ip_range is not None:
            pulumi.set(__self__, "ip_range", ip_range)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_range is not None:
            pulumi.set(__self__, "port_range", port_range)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        The action to take when rule match. Possible values are: `accept` or `drop`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    @_utilities.deprecated("""Ip address is deprecated. Please use ip_range instead""")
    def ip(self) -> Optional[str]:
        """
        The ip this rule apply to. If no `ip` nor `ip_range` are specified, rule will apply to all ip. Only one of `ip` and `ip_range` should be specified.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="ipRange")
    def ip_range(self) -> Optional[str]:
        """
        The ip range (e.g `192.168.1.0/24`) this rule applies to. If no `ip` nor `ip_range` are specified, rule will apply to all ip. Only one of `ip` and `ip_range` should be specified.
        """
        return pulumi.get(self, "ip_range")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port this rule applies to. If no `port` nor `port_range` are specified, the rule will apply to all port. Only one of `port` and `port_range` should be specified.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portRange")
    def port_range(self) -> Optional[str]:
        """
        Computed port range for this rule (e.g: 1-1024, 22-22)
        """
        return pulumi.get(self, "port_range")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        The protocol this rule apply to. Possible values are: `TCP`, `UDP`, `ICMP` or `ANY`.
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class InstanceSecurityGroupOutboundRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipRange":
            suggest = "ip_range"
        elif key == "portRange":
            suggest = "port_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceSecurityGroupOutboundRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceSecurityGroupOutboundRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceSecurityGroupOutboundRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: str,
                 ip: Optional[str] = None,
                 ip_range: Optional[str] = None,
                 port: Optional[int] = None,
                 port_range: Optional[str] = None,
                 protocol: Optional[str] = None):
        """
        :param str action: Action when rule match request (drop or accept)
        :param str ip: Ip address for this rule (e.g: 1.1.1.1). Only one of ip or ip_range should be provided
        :param str ip_range: Ip range for this rule (e.g: 192.168.1.0/24). Only one of ip or ip_range should be provided
        :param int port: Network port for this rule
        :param str port_range: Computed port range for this rule (e.g: 1-1024, 22-22)
        :param str protocol: Protocol for this rule (TCP, UDP, ICMP or ANY)
        """
        pulumi.set(__self__, "action", action)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ip_range is not None:
            pulumi.set(__self__, "ip_range", ip_range)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_range is not None:
            pulumi.set(__self__, "port_range", port_range)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        Action when rule match request (drop or accept)
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    @_utilities.deprecated("""Ip address is deprecated. Please use ip_range instead""")
    def ip(self) -> Optional[str]:
        """
        Ip address for this rule (e.g: 1.1.1.1). Only one of ip or ip_range should be provided
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="ipRange")
    def ip_range(self) -> Optional[str]:
        """
        Ip range for this rule (e.g: 192.168.1.0/24). Only one of ip or ip_range should be provided
        """
        return pulumi.get(self, "ip_range")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Network port for this rule
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portRange")
    def port_range(self) -> Optional[str]:
        """
        Computed port range for this rule (e.g: 1-1024, 22-22)
        """
        return pulumi.get(self, "port_range")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        Protocol for this rule (TCP, UDP, ICMP or ANY)
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class InstanceSecurityGroupRulesInboundRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipRange":
            suggest = "ip_range"
        elif key == "portRange":
            suggest = "port_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceSecurityGroupRulesInboundRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceSecurityGroupRulesInboundRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceSecurityGroupRulesInboundRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: str,
                 ip: Optional[str] = None,
                 ip_range: Optional[str] = None,
                 port: Optional[int] = None,
                 port_range: Optional[str] = None,
                 protocol: Optional[str] = None):
        """
        :param str action: The action to take when rule match. Possible values are: `accept` or `drop`.
        :param str ip: The ip this rule apply to. If no `ip` nor `ip_range` are specified, rule will apply to all ip. Only one of `ip` and `ip_range` should be specified.
        :param str ip_range: The ip range (e.g `192.168.1.0/24`) this rule applies to. If no `ip` nor `ip_range` are specified, rule will apply to all ip. Only one of `ip` and `ip_range` should be specified.
        :param int port: The port this rule apply to. If no port is specified, rule will apply to all port.
        :param str port_range: Computed port range for this rule (e.g: 1-1024, 22-22)
        :param str protocol: The protocol this rule apply to. Possible values are: `TCP`, `UDP`, `ICMP` or `ANY`.
        """
        pulumi.set(__self__, "action", action)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ip_range is not None:
            pulumi.set(__self__, "ip_range", ip_range)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_range is not None:
            pulumi.set(__self__, "port_range", port_range)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        The action to take when rule match. Possible values are: `accept` or `drop`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    @_utilities.deprecated("""Ip address is deprecated. Please use ip_range instead""")
    def ip(self) -> Optional[str]:
        """
        The ip this rule apply to. If no `ip` nor `ip_range` are specified, rule will apply to all ip. Only one of `ip` and `ip_range` should be specified.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="ipRange")
    def ip_range(self) -> Optional[str]:
        """
        The ip range (e.g `192.168.1.0/24`) this rule applies to. If no `ip` nor `ip_range` are specified, rule will apply to all ip. Only one of `ip` and `ip_range` should be specified.
        """
        return pulumi.get(self, "ip_range")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port this rule apply to. If no port is specified, rule will apply to all port.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portRange")
    def port_range(self) -> Optional[str]:
        """
        Computed port range for this rule (e.g: 1-1024, 22-22)
        """
        return pulumi.get(self, "port_range")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        The protocol this rule apply to. Possible values are: `TCP`, `UDP`, `ICMP` or `ANY`.
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class InstanceSecurityGroupRulesOutboundRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipRange":
            suggest = "ip_range"
        elif key == "portRange":
            suggest = "port_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceSecurityGroupRulesOutboundRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceSecurityGroupRulesOutboundRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceSecurityGroupRulesOutboundRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: str,
                 ip: Optional[str] = None,
                 ip_range: Optional[str] = None,
                 port: Optional[int] = None,
                 port_range: Optional[str] = None,
                 protocol: Optional[str] = None):
        """
        :param str action: Action when rule match request (drop or accept)
        :param str ip: Ip address for this rule (e.g: 1.1.1.1). Only one of ip or ip_range should be provided
        :param str ip_range: Ip range for this rule (e.g: 192.168.1.0/24). Only one of ip or ip_range should be provided
        :param int port: Network port for this rule
        :param str port_range: Computed port range for this rule (e.g: 1-1024, 22-22)
        :param str protocol: Protocol for this rule (TCP, UDP, ICMP or ANY)
        """
        pulumi.set(__self__, "action", action)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ip_range is not None:
            pulumi.set(__self__, "ip_range", ip_range)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_range is not None:
            pulumi.set(__self__, "port_range", port_range)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        Action when rule match request (drop or accept)
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    @_utilities.deprecated("""Ip address is deprecated. Please use ip_range instead""")
    def ip(self) -> Optional[str]:
        """
        Ip address for this rule (e.g: 1.1.1.1). Only one of ip or ip_range should be provided
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="ipRange")
    def ip_range(self) -> Optional[str]:
        """
        Ip range for this rule (e.g: 192.168.1.0/24). Only one of ip or ip_range should be provided
        """
        return pulumi.get(self, "ip_range")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Network port for this rule
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portRange")
    def port_range(self) -> Optional[str]:
        """
        Computed port range for this rule (e.g: 1-1024, 22-22)
        """
        return pulumi.get(self, "port_range")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        Protocol for this rule (TCP, UDP, ICMP or ANY)
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class InstanceServerPrivateNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pnId":
            suggest = "pn_id"
        elif key == "macAddress":
            suggest = "mac_address"
        elif key == "pnicId":
            suggest = "pnic_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceServerPrivateNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceServerPrivateNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceServerPrivateNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pn_id: str,
                 mac_address: Optional[str] = None,
                 pnic_id: Optional[str] = None,
                 status: Optional[str] = None,
                 zone: Optional[str] = None):
        """
        :param str pn_id: The Private Network ID
        :param str mac_address: MAC address of the NIC
        :param str pnic_id: The ID of the NIC
        :param str status: The private NIC state
        :param str zone: `zone`) The zone in which the server should be created.
        """
        pulumi.set(__self__, "pn_id", pn_id)
        if mac_address is not None:
            pulumi.set(__self__, "mac_address", mac_address)
        if pnic_id is not None:
            pulumi.set(__self__, "pnic_id", pnic_id)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if zone is not None:
            pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter(name="pnId")
    def pn_id(self) -> str:
        """
        The Private Network ID
        """
        return pulumi.get(self, "pn_id")

    @property
    @pulumi.getter(name="macAddress")
    def mac_address(self) -> Optional[str]:
        """
        MAC address of the NIC
        """
        return pulumi.get(self, "mac_address")

    @property
    @pulumi.getter(name="pnicId")
    def pnic_id(self) -> Optional[str]:
        """
        The ID of the NIC
        """
        return pulumi.get(self, "pnic_id")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        The private NIC state
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def zone(self) -> Optional[str]:
        """
        `zone`) The zone in which the server should be created.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class InstanceServerPublicIp(dict):
    def __init__(__self__, *,
                 address: Optional[str] = None,
                 id: Optional[str] = None):
        """
        :param str address: The address of the IP
        :param str id: The ID of the IP
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        """
        The address of the IP
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the IP
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class InstanceServerRootVolume(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "sbsIops":
            suggest = "sbs_iops"
        elif key == "sizeInGb":
            suggest = "size_in_gb"
        elif key == "volumeId":
            suggest = "volume_id"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceServerRootVolume. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceServerRootVolume.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceServerRootVolume.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 boot: Optional[bool] = None,
                 delete_on_termination: Optional[bool] = None,
                 name: Optional[str] = None,
                 sbs_iops: Optional[int] = None,
                 size_in_gb: Optional[int] = None,
                 volume_id: Optional[str] = None,
                 volume_type: Optional[str] = None):
        """
        :param bool boot: Set the volume where the boot the server
        :param bool delete_on_termination: Forces deletion of the root volume on instance termination.
        :param str name: The name of the server.
        :param int sbs_iops: Choose IOPS of your sbs volume, has to be used with `sbs_volume` for root volume type.
               
               > **Important:** Updates to `root_volume.size_in_gb` will be ignored after the creation of the server.
        :param int size_in_gb: Size of the root volume in gigabytes.
               To find the right size use [this endpoint](https://www.scaleway.com/en/developers/api/instance/#path-instances-list-all-instances) and
               check the `volumes_constraint.{min|max}_size` (in bytes) for your `commercial_type`.
               Updates to this field will recreate a new resource.
        :param str volume_id: The volume ID of the root volume of the server, allows you to create server with an existing volume. If empty, will be computed to a created volume ID.
        :param str volume_type: Volume type of root volume, can be `b_ssd`, `l_ssd` or `sbs_volume`, default value depends on server type
        """
        if boot is not None:
            pulumi.set(__self__, "boot", boot)
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if sbs_iops is not None:
            pulumi.set(__self__, "sbs_iops", sbs_iops)
        if size_in_gb is not None:
            pulumi.set(__self__, "size_in_gb", size_in_gb)
        if volume_id is not None:
            pulumi.set(__self__, "volume_id", volume_id)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @property
    @pulumi.getter
    def boot(self) -> Optional[bool]:
        """
        Set the volume where the boot the server
        """
        return pulumi.get(self, "boot")

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[bool]:
        """
        Forces deletion of the root volume on instance termination.
        """
        return pulumi.get(self, "delete_on_termination")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the server.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sbsIops")
    def sbs_iops(self) -> Optional[int]:
        """
        Choose IOPS of your sbs volume, has to be used with `sbs_volume` for root volume type.

        > **Important:** Updates to `root_volume.size_in_gb` will be ignored after the creation of the server.
        """
        return pulumi.get(self, "sbs_iops")

    @property
    @pulumi.getter(name="sizeInGb")
    def size_in_gb(self) -> Optional[int]:
        """
        Size of the root volume in gigabytes.
        To find the right size use [this endpoint](https://www.scaleway.com/en/developers/api/instance/#path-instances-list-all-instances) and
        check the `volumes_constraint.{min|max}_size` (in bytes) for your `commercial_type`.
        Updates to this field will recreate a new resource.
        """
        return pulumi.get(self, "size_in_gb")

    @property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> Optional[str]:
        """
        The volume ID of the root volume of the server, allows you to create server with an existing volume. If empty, will be computed to a created volume ID.
        """
        return pulumi.get(self, "volume_id")

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[str]:
        """
        Volume type of root volume, can be `b_ssd`, `l_ssd` or `sbs_volume`, default value depends on server type
        """
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class InstanceSnapshotImport(dict):
    def __init__(__self__, *,
                 bucket: str,
                 key: str):
        """
        :param str bucket: Bucket name containing [qcow2](https://en.wikipedia.org/wiki/Qcow) to import
        :param str key: Key of the object to import
               
               > **Note:** The type `unified` could be instantiated on both `l_ssd` and `b_ssd` volumes.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def bucket(self) -> str:
        """
        Bucket name containing [qcow2](https://en.wikipedia.org/wiki/Qcow) to import
        """
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key of the object to import

        > **Note:** The type `unified` could be instantiated on both `l_ssd` and `b_ssd` volumes.
        """
        return pulumi.get(self, "key")


@pulumi.output_type
class IotDeviceCertificate(dict):
    def __init__(__self__, *,
                 crt: Optional[str] = None,
                 key: Optional[str] = None):
        """
        :param str crt: X509 PEM encoded certificate of the device
        :param str key: The private key of the device, in case it is generated by Scaleway.
        """
        if crt is not None:
            pulumi.set(__self__, "crt", crt)
        if key is not None:
            pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def crt(self) -> Optional[str]:
        """
        X509 PEM encoded certificate of the device
        """
        return pulumi.get(self, "crt")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The private key of the device, in case it is generated by Scaleway.
        """
        return pulumi.get(self, "key")


@pulumi.output_type
class IotDeviceMessageFilters(dict):
    def __init__(__self__, *,
                 publish: Optional['outputs.IotDeviceMessageFiltersPublish'] = None,
                 subscribe: Optional['outputs.IotDeviceMessageFiltersSubscribe'] = None):
        """
        :param 'IotDeviceMessageFiltersPublishArgs' publish: Rules used to restrict topics the device can publish to.
        :param 'IotDeviceMessageFiltersSubscribeArgs' subscribe: Rules used to restrict topics the device can subscribe to.
        """
        if publish is not None:
            pulumi.set(__self__, "publish", publish)
        if subscribe is not None:
            pulumi.set(__self__, "subscribe", subscribe)

    @property
    @pulumi.getter
    def publish(self) -> Optional['outputs.IotDeviceMessageFiltersPublish']:
        """
        Rules used to restrict topics the device can publish to.
        """
        return pulumi.get(self, "publish")

    @property
    @pulumi.getter
    def subscribe(self) -> Optional['outputs.IotDeviceMessageFiltersSubscribe']:
        """
        Rules used to restrict topics the device can subscribe to.
        """
        return pulumi.get(self, "subscribe")


@pulumi.output_type
class IotDeviceMessageFiltersPublish(dict):
    def __init__(__self__, *,
                 policy: Optional[str] = None,
                 topics: Optional[Sequence[str]] = None):
        """
        :param str policy: Filtering policy (eg `accept` or `reject`)
        :param Sequence[str] topics: List of topics to match (eg `foo/bar/+/baz/#`)
        """
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if topics is not None:
            pulumi.set(__self__, "topics", topics)

    @property
    @pulumi.getter
    def policy(self) -> Optional[str]:
        """
        Filtering policy (eg `accept` or `reject`)
        """
        return pulumi.get(self, "policy")

    @property
    @pulumi.getter
    def topics(self) -> Optional[Sequence[str]]:
        """
        List of topics to match (eg `foo/bar/+/baz/#`)
        """
        return pulumi.get(self, "topics")


@pulumi.output_type
class IotDeviceMessageFiltersSubscribe(dict):
    def __init__(__self__, *,
                 policy: Optional[str] = None,
                 topics: Optional[Sequence[str]] = None):
        """
        :param str policy: Same as publish rules.
        :param Sequence[str] topics: Same as publish rules.
               
               - `certificate.crt` - (Optional) The certificate of the device, either generated by Scaleway or provided.
               
               > **Important:** Updates to `certificate.crt` will disconnect connected devices and the previous certificate will be deleted and won't be recoverable.
        """
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if topics is not None:
            pulumi.set(__self__, "topics", topics)

    @property
    @pulumi.getter
    def policy(self) -> Optional[str]:
        """
        Same as publish rules.
        """
        return pulumi.get(self, "policy")

    @property
    @pulumi.getter
    def topics(self) -> Optional[Sequence[str]]:
        """
        Same as publish rules.

        - `certificate.crt` - (Optional) The certificate of the device, either generated by Scaleway or provided.

        > **Important:** Updates to `certificate.crt` will disconnect connected devices and the previous certificate will be deleted and won't be recoverable.
        """
        return pulumi.get(self, "topics")


@pulumi.output_type
class IotRouteDatabase(dict):
    def __init__(__self__, *,
                 dbname: str,
                 host: str,
                 password: str,
                 port: int,
                 query: str,
                 username: str):
        """
        :param str dbname: The database name (e.g. `measurements`).
        :param str host: The database hostname. Can be an IP or a FQDN.
        :param str password: The database password.
        :param int port: The database port (e.g. `5432`)
        :param str query: The SQL query that will be executed when receiving a message ($TOPIC and $PAYLOAD variables are available, see documentation, e.g. `INSERT INTO mytable(date, topic, value) VALUES (NOW(), $TOPIC, $PAYLOAD)`).
        :param str username: The database username.
        """
        pulumi.set(__self__, "dbname", dbname)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "query", query)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def dbname(self) -> str:
        """
        The database name (e.g. `measurements`).
        """
        return pulumi.get(self, "dbname")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        The database hostname. Can be an IP or a FQDN.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The database password.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The database port (e.g. `5432`)
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The SQL query that will be executed when receiving a message ($TOPIC and $PAYLOAD variables are available, see documentation, e.g. `INSERT INTO mytable(date, topic, value) VALUES (NOW(), $TOPIC, $PAYLOAD)`).
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The database username.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class IotRouteRest(dict):
    def __init__(__self__, *,
                 headers: Mapping[str, str],
                 uri: str,
                 verb: str):
        """
        :param Mapping[str, str] headers: a map of the extra headers to send with the HTTP call (e.g. `X-Header = Value`).
        :param str uri: The URI of the Rest endpoint (e.g. `https://internal.mycompany.com/ingest/mqttdata`).
        :param str verb: The HTTP Verb used to call Rest URI (e.g. `post`).
        """
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "uri", uri)
        pulumi.set(__self__, "verb", verb)

    @property
    @pulumi.getter
    def headers(self) -> Mapping[str, str]:
        """
        a map of the extra headers to send with the HTTP call (e.g. `X-Header = Value`).
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter
    def uri(self) -> str:
        """
        The URI of the Rest endpoint (e.g. `https://internal.mycompany.com/ingest/mqttdata`).
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter
    def verb(self) -> str:
        """
        The HTTP Verb used to call Rest URI (e.g. `post`).
        """
        return pulumi.get(self, "verb")


@pulumi.output_type
class IotRouteS3(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "bucketRegion":
            suggest = "bucket_region"
        elif key == "objectPrefix":
            suggest = "object_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IotRouteS3. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IotRouteS3.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IotRouteS3.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: str,
                 bucket_region: str,
                 strategy: str,
                 object_prefix: Optional[str] = None):
        """
        :param str bucket_name: The name of the S3 route's destination bucket (e.g. `my-object-storage`).
        :param str bucket_region: The region of the S3 route's destination bucket (e.g. `fr-par`).
        :param str strategy: How the S3 route's objects will be created (e.g. `per_topic`). See [documentation](https://www.scaleway.com/en/docs/scaleway-iothub-route/#-Messages-Store-Strategies) for behaviour details.
        :param str object_prefix: The string to prefix object names with (e.g. `mykeyprefix-`).
        """
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "bucket_region", bucket_region)
        pulumi.set(__self__, "strategy", strategy)
        if object_prefix is not None:
            pulumi.set(__self__, "object_prefix", object_prefix)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> str:
        """
        The name of the S3 route's destination bucket (e.g. `my-object-storage`).
        """
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="bucketRegion")
    def bucket_region(self) -> str:
        """
        The region of the S3 route's destination bucket (e.g. `fr-par`).
        """
        return pulumi.get(self, "bucket_region")

    @property
    @pulumi.getter
    def strategy(self) -> str:
        """
        How the S3 route's objects will be created (e.g. `per_topic`). See [documentation](https://www.scaleway.com/en/docs/scaleway-iothub-route/#-Messages-Store-Strategies) for behaviour details.
        """
        return pulumi.get(self, "strategy")

    @property
    @pulumi.getter(name="objectPrefix")
    def object_prefix(self) -> Optional[str]:
        """
        The string to prefix object names with (e.g. `mykeyprefix-`).
        """
        return pulumi.get(self, "object_prefix")


@pulumi.output_type
class IpamIpCustomResource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "macAddress":
            suggest = "mac_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IpamIpCustomResource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IpamIpCustomResource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IpamIpCustomResource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mac_address: str,
                 name: Optional[str] = None):
        """
        :param str mac_address: The MAC address of the resource the IP is attached to.
        :param str name: The name of the resource the IP is attached to.
        """
        pulumi.set(__self__, "mac_address", mac_address)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="macAddress")
    def mac_address(self) -> str:
        """
        The MAC address of the resource the IP is attached to.
        """
        return pulumi.get(self, "mac_address")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the resource the IP is attached to.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class IpamIpResource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "macAddress":
            suggest = "mac_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IpamIpResource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IpamIpResource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IpamIpResource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: Optional[str] = None,
                 mac_address: Optional[str] = None,
                 name: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str id: The ID of the resource that the IP is attached to.
        :param str mac_address: The MAC address of the resource the IP is attached to.
        :param str name: The name of the resource the IP is attached to.
        :param str type: The type of resource the IP is attached to.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if mac_address is not None:
            pulumi.set(__self__, "mac_address", mac_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the resource that the IP is attached to.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="macAddress")
    def mac_address(self) -> Optional[str]:
        """
        The MAC address of the resource the IP is attached to.
        """
        return pulumi.get(self, "mac_address")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the resource the IP is attached to.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of resource the IP is attached to.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class IpamIpReverse(dict):
    def __init__(__self__, *,
                 address: Optional[str] = None,
                 hostname: Optional[str] = None):
        """
        :param str address: The IP corresponding to the hostname
        :param str hostname: The reverse domain name.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        """
        The IP corresponding to the hostname
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The reverse domain name.
        """
        return pulumi.get(self, "hostname")


@pulumi.output_type
class IpamIpSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateNetworkId":
            suggest = "private_network_id"
        elif key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IpamIpSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IpamIpSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IpamIpSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 private_network_id: Optional[str] = None,
                 subnet_id: Optional[str] = None,
                 zonal: Optional[str] = None):
        """
        :param str private_network_id: The Private Network of the IP (if the IP is a private IP).
        :param str subnet_id: The Private Network subnet of the IP (if the IP is a private IP).
        :param str zonal: The zone of the IP (if the IP is public and zoned, rather than private and/or regional)
        """
        if private_network_id is not None:
            pulumi.set(__self__, "private_network_id", private_network_id)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if zonal is not None:
            pulumi.set(__self__, "zonal", zonal)

    @property
    @pulumi.getter(name="privateNetworkId")
    def private_network_id(self) -> Optional[str]:
        """
        The Private Network of the IP (if the IP is a private IP).
        """
        return pulumi.get(self, "private_network_id")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        """
        The Private Network subnet of the IP (if the IP is a private IP).
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter
    def zonal(self) -> Optional[str]:
        """
        The zone of the IP (if the IP is public and zoned, rather than private and/or regional)
        """
        return pulumi.get(self, "zonal")


@pulumi.output_type
class JobDefinitionCron(dict):
    def __init__(__self__, *,
                 schedule: str,
                 timezone: str):
        """
        :param str schedule: Cron format string.
        :param str timezone: The timezone, must be a canonical TZ identifier as found in this [list](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones).
        """
        pulumi.set(__self__, "schedule", schedule)
        pulumi.set(__self__, "timezone", timezone)

    @property
    @pulumi.getter
    def schedule(self) -> str:
        """
        Cron format string.
        """
        return pulumi.get(self, "schedule")

    @property
    @pulumi.getter
    def timezone(self) -> str:
        """
        The timezone, must be a canonical TZ identifier as found in this [list](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones).
        """
        return pulumi.get(self, "timezone")


@pulumi.output_type
class KubernetesClusterAutoUpgrade(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maintenanceWindowDay":
            suggest = "maintenance_window_day"
        elif key == "maintenanceWindowStartHour":
            suggest = "maintenance_window_start_hour"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterAutoUpgrade. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterAutoUpgrade.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterAutoUpgrade.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable: bool,
                 maintenance_window_day: str,
                 maintenance_window_start_hour: int):
        """
        :param bool enable: Set to `true` to enable Kubernetes patch version auto upgrades.
               > **Important:** When enabling auto upgrades, the `version` field take a minor version like x.y (ie 1.18).
        :param str maintenance_window_day: The day of the auto upgrade maintenance window (`monday` to `sunday`, or `any`).
        :param int maintenance_window_start_hour: The start hour (UTC) of the 2-hour auto upgrade maintenance window (0 to 23).
        """
        pulumi.set(__self__, "enable", enable)
        pulumi.set(__self__, "maintenance_window_day", maintenance_window_day)
        pulumi.set(__self__, "maintenance_window_start_hour", maintenance_window_start_hour)

    @property
    @pulumi.getter
    def enable(self) -> bool:
        """
        Set to `true` to enable Kubernetes patch version auto upgrades.
        > **Important:** When enabling auto upgrades, the `version` field take a minor version like x.y (ie 1.18).
        """
        return pulumi.get(self, "enable")

    @property
    @pulumi.getter(name="maintenanceWindowDay")
    def maintenance_window_day(self) -> str:
        """
        The day of the auto upgrade maintenance window (`monday` to `sunday`, or `any`).
        """
        return pulumi.get(self, "maintenance_window_day")

    @property
    @pulumi.getter(name="maintenanceWindowStartHour")
    def maintenance_window_start_hour(self) -> int:
        """
        The start hour (UTC) of the 2-hour auto upgrade maintenance window (0 to 23).
        """
        return pulumi.get(self, "maintenance_window_start_hour")


@pulumi.output_type
class KubernetesClusterAutoscalerConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "balanceSimilarNodeGroups":
            suggest = "balance_similar_node_groups"
        elif key == "disableScaleDown":
            suggest = "disable_scale_down"
        elif key == "expendablePodsPriorityCutoff":
            suggest = "expendable_pods_priority_cutoff"
        elif key == "ignoreDaemonsetsUtilization":
            suggest = "ignore_daemonsets_utilization"
        elif key == "maxGracefulTerminationSec":
            suggest = "max_graceful_termination_sec"
        elif key == "scaleDownDelayAfterAdd":
            suggest = "scale_down_delay_after_add"
        elif key == "scaleDownUnneededTime":
            suggest = "scale_down_unneeded_time"
        elif key == "scaleDownUtilizationThreshold":
            suggest = "scale_down_utilization_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterAutoscalerConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterAutoscalerConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterAutoscalerConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 balance_similar_node_groups: Optional[bool] = None,
                 disable_scale_down: Optional[bool] = None,
                 estimator: Optional[str] = None,
                 expander: Optional[str] = None,
                 expendable_pods_priority_cutoff: Optional[int] = None,
                 ignore_daemonsets_utilization: Optional[bool] = None,
                 max_graceful_termination_sec: Optional[int] = None,
                 scale_down_delay_after_add: Optional[str] = None,
                 scale_down_unneeded_time: Optional[str] = None,
                 scale_down_utilization_threshold: Optional[float] = None):
        """
        :param bool balance_similar_node_groups: Detect similar node groups and balance the number of nodes between them.
        :param bool disable_scale_down: Disables the scale down feature of the autoscaler.
        :param str estimator: Type of resource estimator to be used in scale up.
        :param str expander: Type of node group expander to be used in scale up.
        :param int expendable_pods_priority_cutoff: Pods with priority below cutoff will be expendable. They can be killed without any consideration during scale down and they don't cause scale up. Pods with null priority (PodPriority disabled) are non expendable.
        :param bool ignore_daemonsets_utilization: Ignore DaemonSet pods when calculating resource utilization for scaling down.
        :param int max_graceful_termination_sec: Maximum number of seconds the cluster autoscaler waits for pod termination when trying to scale down a node
        :param str scale_down_delay_after_add: How long after scale up that scale down evaluation resumes.
        :param str scale_down_unneeded_time: How long a node should be unneeded before it is eligible for scale down.
        :param float scale_down_utilization_threshold: Node utilization level, defined as sum of requested resources divided by capacity, below which a node can be considered for scale down
        """
        if balance_similar_node_groups is not None:
            pulumi.set(__self__, "balance_similar_node_groups", balance_similar_node_groups)
        if disable_scale_down is not None:
            pulumi.set(__self__, "disable_scale_down", disable_scale_down)
        if estimator is not None:
            pulumi.set(__self__, "estimator", estimator)
        if expander is not None:
            pulumi.set(__self__, "expander", expander)
        if expendable_pods_priority_cutoff is not None:
            pulumi.set(__self__, "expendable_pods_priority_cutoff", expendable_pods_priority_cutoff)
        if ignore_daemonsets_utilization is not None:
            pulumi.set(__self__, "ignore_daemonsets_utilization", ignore_daemonsets_utilization)
        if max_graceful_termination_sec is not None:
            pulumi.set(__self__, "max_graceful_termination_sec", max_graceful_termination_sec)
        if scale_down_delay_after_add is not None:
            pulumi.set(__self__, "scale_down_delay_after_add", scale_down_delay_after_add)
        if scale_down_unneeded_time is not None:
            pulumi.set(__self__, "scale_down_unneeded_time", scale_down_unneeded_time)
        if scale_down_utilization_threshold is not None:
            pulumi.set(__self__, "scale_down_utilization_threshold", scale_down_utilization_threshold)

    @property
    @pulumi.getter(name="balanceSimilarNodeGroups")
    def balance_similar_node_groups(self) -> Optional[bool]:
        """
        Detect similar node groups and balance the number of nodes between them.
        """
        return pulumi.get(self, "balance_similar_node_groups")

    @property
    @pulumi.getter(name="disableScaleDown")
    def disable_scale_down(self) -> Optional[bool]:
        """
        Disables the scale down feature of the autoscaler.
        """
        return pulumi.get(self, "disable_scale_down")

    @property
    @pulumi.getter
    def estimator(self) -> Optional[str]:
        """
        Type of resource estimator to be used in scale up.
        """
        return pulumi.get(self, "estimator")

    @property
    @pulumi.getter
    def expander(self) -> Optional[str]:
        """
        Type of node group expander to be used in scale up.
        """
        return pulumi.get(self, "expander")

    @property
    @pulumi.getter(name="expendablePodsPriorityCutoff")
    def expendable_pods_priority_cutoff(self) -> Optional[int]:
        """
        Pods with priority below cutoff will be expendable. They can be killed without any consideration during scale down and they don't cause scale up. Pods with null priority (PodPriority disabled) are non expendable.
        """
        return pulumi.get(self, "expendable_pods_priority_cutoff")

    @property
    @pulumi.getter(name="ignoreDaemonsetsUtilization")
    def ignore_daemonsets_utilization(self) -> Optional[bool]:
        """
        Ignore DaemonSet pods when calculating resource utilization for scaling down.
        """
        return pulumi.get(self, "ignore_daemonsets_utilization")

    @property
    @pulumi.getter(name="maxGracefulTerminationSec")
    def max_graceful_termination_sec(self) -> Optional[int]:
        """
        Maximum number of seconds the cluster autoscaler waits for pod termination when trying to scale down a node
        """
        return pulumi.get(self, "max_graceful_termination_sec")

    @property
    @pulumi.getter(name="scaleDownDelayAfterAdd")
    def scale_down_delay_after_add(self) -> Optional[str]:
        """
        How long after scale up that scale down evaluation resumes.
        """
        return pulumi.get(self, "scale_down_delay_after_add")

    @property
    @pulumi.getter(name="scaleDownUnneededTime")
    def scale_down_unneeded_time(self) -> Optional[str]:
        """
        How long a node should be unneeded before it is eligible for scale down.
        """
        return pulumi.get(self, "scale_down_unneeded_time")

    @property
    @pulumi.getter(name="scaleDownUtilizationThreshold")
    def scale_down_utilization_threshold(self) -> Optional[float]:
        """
        Node utilization level, defined as sum of requested resources divided by capacity, below which a node can be considered for scale down
        """
        return pulumi.get(self, "scale_down_utilization_threshold")


@pulumi.output_type
class KubernetesClusterKubeconfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterCaCertificate":
            suggest = "cluster_ca_certificate"
        elif key == "configFile":
            suggest = "config_file"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterKubeconfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterKubeconfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterKubeconfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_ca_certificate: Optional[str] = None,
                 config_file: Optional[str] = None,
                 host: Optional[str] = None,
                 token: Optional[str] = None):
        """
        :param str cluster_ca_certificate: The CA certificate of the Kubernetes API server.
        :param str config_file: The raw kubeconfig file.
        :param str host: The URL of the Kubernetes API server.
        :param str token: The token to connect to the Kubernetes API server.
        """
        if cluster_ca_certificate is not None:
            pulumi.set(__self__, "cluster_ca_certificate", cluster_ca_certificate)
        if config_file is not None:
            pulumi.set(__self__, "config_file", config_file)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if token is not None:
            pulumi.set(__self__, "token", token)

    @property
    @pulumi.getter(name="clusterCaCertificate")
    def cluster_ca_certificate(self) -> Optional[str]:
        """
        The CA certificate of the Kubernetes API server.
        """
        return pulumi.get(self, "cluster_ca_certificate")

    @property
    @pulumi.getter(name="configFile")
    def config_file(self) -> Optional[str]:
        """
        The raw kubeconfig file.
        """
        return pulumi.get(self, "config_file")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        The URL of the Kubernetes API server.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def token(self) -> Optional[str]:
        """
        The token to connect to the Kubernetes API server.
        """
        return pulumi.get(self, "token")


@pulumi.output_type
class KubernetesClusterOpenIdConnectConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "issuerUrl":
            suggest = "issuer_url"
        elif key == "groupsClaims":
            suggest = "groups_claims"
        elif key == "groupsPrefix":
            suggest = "groups_prefix"
        elif key == "requiredClaims":
            suggest = "required_claims"
        elif key == "usernameClaim":
            suggest = "username_claim"
        elif key == "usernamePrefix":
            suggest = "username_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterOpenIdConnectConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterOpenIdConnectConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterOpenIdConnectConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 issuer_url: str,
                 groups_claims: Optional[Sequence[str]] = None,
                 groups_prefix: Optional[str] = None,
                 required_claims: Optional[Sequence[str]] = None,
                 username_claim: Optional[str] = None,
                 username_prefix: Optional[str] = None):
        """
        :param str client_id: A client id that all tokens must be issued for
        :param str issuer_url: URL of the provider which allows the API server to discover public signing keys
        :param Sequence[str] groups_claims: JWT claim to use as the user's group
        :param str groups_prefix: Prefix prepended to group claims
        :param Sequence[str] required_claims: Multiple key=value pairs that describes a required claim in the ID Token
        :param str username_claim: JWT claim to use as the user name
        :param str username_prefix: Prefix prepended to username
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "issuer_url", issuer_url)
        if groups_claims is not None:
            pulumi.set(__self__, "groups_claims", groups_claims)
        if groups_prefix is not None:
            pulumi.set(__self__, "groups_prefix", groups_prefix)
        if required_claims is not None:
            pulumi.set(__self__, "required_claims", required_claims)
        if username_claim is not None:
            pulumi.set(__self__, "username_claim", username_claim)
        if username_prefix is not None:
            pulumi.set(__self__, "username_prefix", username_prefix)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        A client id that all tokens must be issued for
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="issuerUrl")
    def issuer_url(self) -> str:
        """
        URL of the provider which allows the API server to discover public signing keys
        """
        return pulumi.get(self, "issuer_url")

    @property
    @pulumi.getter(name="groupsClaims")
    def groups_claims(self) -> Optional[Sequence[str]]:
        """
        JWT claim to use as the user's group
        """
        return pulumi.get(self, "groups_claims")

    @property
    @pulumi.getter(name="groupsPrefix")
    def groups_prefix(self) -> Optional[str]:
        """
        Prefix prepended to group claims
        """
        return pulumi.get(self, "groups_prefix")

    @property
    @pulumi.getter(name="requiredClaims")
    def required_claims(self) -> Optional[Sequence[str]]:
        """
        Multiple key=value pairs that describes a required claim in the ID Token
        """
        return pulumi.get(self, "required_claims")

    @property
    @pulumi.getter(name="usernameClaim")
    def username_claim(self) -> Optional[str]:
        """
        JWT claim to use as the user name
        """
        return pulumi.get(self, "username_claim")

    @property
    @pulumi.getter(name="usernamePrefix")
    def username_prefix(self) -> Optional[str]:
        """
        Prefix prepended to username
        """
        return pulumi.get(self, "username_prefix")


@pulumi.output_type
class KubernetesNodePoolNode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "publicIp":
            suggest = "public_ip"
        elif key == "publicIpV6":
            suggest = "public_ip_v6"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesNodePoolNode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesNodePoolNode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesNodePoolNode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[str] = None,
                 public_ip: Optional[str] = None,
                 public_ip_v6: Optional[str] = None,
                 status: Optional[str] = None):
        """
        :param str name: The name for the pool.
               > **Important:** Updates to this field will recreate a new resource.
        :param str public_ip: The public IPv4. (Deprecated, Please use the official Kubernetes provider and the kubernetes_nodes data source)
        :param str public_ip_v6: The public IPv6. (Deprecated, Please use the official Kubernetes provider and the kubernetes_nodes data source)
        :param str status: The status of the node.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if public_ip is not None:
            pulumi.set(__self__, "public_ip", public_ip)
        if public_ip_v6 is not None:
            pulumi.set(__self__, "public_ip_v6", public_ip_v6)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name for the pool.
        > **Important:** Updates to this field will recreate a new resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="publicIp")
    @_utilities.deprecated("""Please use the official Kubernetes provider and the kubernetes_nodes data source""")
    def public_ip(self) -> Optional[str]:
        """
        The public IPv4. (Deprecated, Please use the official Kubernetes provider and the kubernetes_nodes data source)
        """
        return pulumi.get(self, "public_ip")

    @property
    @pulumi.getter(name="publicIpV6")
    @_utilities.deprecated("""Please use the official Kubernetes provider and the kubernetes_nodes data source""")
    def public_ip_v6(self) -> Optional[str]:
        """
        The public IPv6. (Deprecated, Please use the official Kubernetes provider and the kubernetes_nodes data source)
        """
        return pulumi.get(self, "public_ip_v6")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        The status of the node.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class KubernetesNodePoolUpgradePolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxSurge":
            suggest = "max_surge"
        elif key == "maxUnavailable":
            suggest = "max_unavailable"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesNodePoolUpgradePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesNodePoolUpgradePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesNodePoolUpgradePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_surge: Optional[int] = None,
                 max_unavailable: Optional[int] = None):
        """
        :param int max_surge: The maximum number of nodes to be created during the upgrade
        :param int max_unavailable: The maximum number of nodes that can be not ready at the same time
        """
        if max_surge is not None:
            pulumi.set(__self__, "max_surge", max_surge)
        if max_unavailable is not None:
            pulumi.set(__self__, "max_unavailable", max_unavailable)

    @property
    @pulumi.getter(name="maxSurge")
    def max_surge(self) -> Optional[int]:
        """
        The maximum number of nodes to be created during the upgrade
        """
        return pulumi.get(self, "max_surge")

    @property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> Optional[int]:
        """
        The maximum number of nodes that can be not ready at the same time
        """
        return pulumi.get(self, "max_unavailable")


@pulumi.output_type
class LoadbalancerAclAction(dict):
    def __init__(__self__, *,
                 type: str,
                 redirects: Optional[Sequence['outputs.LoadbalancerAclActionRedirect']] = None):
        """
        :param str type: The action type. Possible values are: `allow` or `deny` or `redirect`.
        :param Sequence['LoadbalancerAclActionRedirectArgs'] redirects: Redirect parameters when using an ACL with `redirect` action.
        """
        pulumi.set(__self__, "type", type)
        if redirects is not None:
            pulumi.set(__self__, "redirects", redirects)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The action type. Possible values are: `allow` or `deny` or `redirect`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def redirects(self) -> Optional[Sequence['outputs.LoadbalancerAclActionRedirect']]:
        """
        Redirect parameters when using an ACL with `redirect` action.
        """
        return pulumi.get(self, "redirects")


@pulumi.output_type
class LoadbalancerAclActionRedirect(dict):
    def __init__(__self__, *,
                 code: Optional[int] = None,
                 target: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param int code: The HTTP redirect code to use. Valid values are `301`, `302`, `303`, `307` and `308`.
        :param str target: An URL can be used in case of a location redirect (e.g. `https://scaleway.com` will redirect to this same URL). A scheme name (e.g. `https`, `http`, `ftp`, `git`) will replace the request's original scheme.
        :param str type: The redirect type. Possible values are: `location` or `scheme`.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def code(self) -> Optional[int]:
        """
        The HTTP redirect code to use. Valid values are `301`, `302`, `303`, `307` and `308`.
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def target(self) -> Optional[str]:
        """
        An URL can be used in case of a location redirect (e.g. `https://scaleway.com` will redirect to this same URL). A scheme name (e.g. `https`, `http`, `ftp`, `git`) will replace the request's original scheme.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The redirect type. Possible values are: `location` or `scheme`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class LoadbalancerAclMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpFilter":
            suggest = "http_filter"
        elif key == "httpFilterOption":
            suggest = "http_filter_option"
        elif key == "httpFilterValues":
            suggest = "http_filter_values"
        elif key == "ipSubnets":
            suggest = "ip_subnets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadbalancerAclMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadbalancerAclMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadbalancerAclMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_filter: Optional[str] = None,
                 http_filter_option: Optional[str] = None,
                 http_filter_values: Optional[Sequence[str]] = None,
                 invert: Optional[bool] = None,
                 ip_subnets: Optional[Sequence[str]] = None):
        """
        :param str http_filter: The HTTP filter to match. This filter is supported only if your backend protocol has an HTTP forward protocol.
               It extracts the request's URL path, which starts at the first slash and ends before the question mark (without the host part).
               Possible values are: `acl_http_filter_none`, `path_begin`, `path_end`, `http_header_match` or `regex`.
        :param str http_filter_option: If you have `http_filter` at `http_header_match`, you can use this field to filter on the HTTP header's value.
        :param Sequence[str] http_filter_values: A list of possible values to match for the given HTTP filter.
               Keep in mind that in the case of `http_header_match` the HTTP header field name is case insensitive.
        :param bool invert: If set to `true`, the condition will be of type "unless".
        :param Sequence[str] ip_subnets: A list of IPs, or CIDR v4/v6 addresses of the session client, to match.
        """
        if http_filter is not None:
            pulumi.set(__self__, "http_filter", http_filter)
        if http_filter_option is not None:
            pulumi.set(__self__, "http_filter_option", http_filter_option)
        if http_filter_values is not None:
            pulumi.set(__self__, "http_filter_values", http_filter_values)
        if invert is not None:
            pulumi.set(__self__, "invert", invert)
        if ip_subnets is not None:
            pulumi.set(__self__, "ip_subnets", ip_subnets)

    @property
    @pulumi.getter(name="httpFilter")
    def http_filter(self) -> Optional[str]:
        """
        The HTTP filter to match. This filter is supported only if your backend protocol has an HTTP forward protocol.
        It extracts the request's URL path, which starts at the first slash and ends before the question mark (without the host part).
        Possible values are: `acl_http_filter_none`, `path_begin`, `path_end`, `http_header_match` or `regex`.
        """
        return pulumi.get(self, "http_filter")

    @property
    @pulumi.getter(name="httpFilterOption")
    def http_filter_option(self) -> Optional[str]:
        """
        If you have `http_filter` at `http_header_match`, you can use this field to filter on the HTTP header's value.
        """
        return pulumi.get(self, "http_filter_option")

    @property
    @pulumi.getter(name="httpFilterValues")
    def http_filter_values(self) -> Optional[Sequence[str]]:
        """
        A list of possible values to match for the given HTTP filter.
        Keep in mind that in the case of `http_header_match` the HTTP header field name is case insensitive.
        """
        return pulumi.get(self, "http_filter_values")

    @property
    @pulumi.getter
    def invert(self) -> Optional[bool]:
        """
        If set to `true`, the condition will be of type "unless".
        """
        return pulumi.get(self, "invert")

    @property
    @pulumi.getter(name="ipSubnets")
    def ip_subnets(self) -> Optional[Sequence[str]]:
        """
        A list of IPs, or CIDR v4/v6 addresses of the session client, to match.
        """
        return pulumi.get(self, "ip_subnets")


@pulumi.output_type
class LoadbalancerBackendHealthCheckHttp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostHeader":
            suggest = "host_header"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadbalancerBackendHealthCheckHttp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadbalancerBackendHealthCheckHttp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadbalancerBackendHealthCheckHttp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 uri: str,
                 code: Optional[int] = None,
                 host_header: Optional[str] = None,
                 method: Optional[str] = None):
        """
        :param str uri: The HTTP endpoint URL to call for HC requests
        :param int code: The expected HTTP status code
        :param str host_header: The HTTP host header to use for HC requests
        :param str method: The HTTP method to use for HC requests
        """
        pulumi.set(__self__, "uri", uri)
        if code is not None:
            pulumi.set(__self__, "code", code)
        if host_header is not None:
            pulumi.set(__self__, "host_header", host_header)
        if method is not None:
            pulumi.set(__self__, "method", method)

    @property
    @pulumi.getter
    def uri(self) -> str:
        """
        The HTTP endpoint URL to call for HC requests
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter
    def code(self) -> Optional[int]:
        """
        The expected HTTP status code
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter(name="hostHeader")
    def host_header(self) -> Optional[str]:
        """
        The HTTP host header to use for HC requests
        """
        return pulumi.get(self, "host_header")

    @property
    @pulumi.getter
    def method(self) -> Optional[str]:
        """
        The HTTP method to use for HC requests
        """
        return pulumi.get(self, "method")


@pulumi.output_type
class LoadbalancerBackendHealthCheckHttps(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostHeader":
            suggest = "host_header"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadbalancerBackendHealthCheckHttps. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadbalancerBackendHealthCheckHttps.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadbalancerBackendHealthCheckHttps.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 uri: str,
                 code: Optional[int] = None,
                 host_header: Optional[str] = None,
                 method: Optional[str] = None,
                 sni: Optional[str] = None):
        """
        :param str uri: The HTTPS endpoint URL to call for HC requests
        :param int code: The expected HTTP status code
        :param str host_header: The HTTP host header to use for HC requests
        :param str method: The HTTP method to use for HC requests
        :param str sni: The SNI to use for HC requests over SSL
        """
        pulumi.set(__self__, "uri", uri)
        if code is not None:
            pulumi.set(__self__, "code", code)
        if host_header is not None:
            pulumi.set(__self__, "host_header", host_header)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if sni is not None:
            pulumi.set(__self__, "sni", sni)

    @property
    @pulumi.getter
    def uri(self) -> str:
        """
        The HTTPS endpoint URL to call for HC requests
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter
    def code(self) -> Optional[int]:
        """
        The expected HTTP status code
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter(name="hostHeader")
    def host_header(self) -> Optional[str]:
        """
        The HTTP host header to use for HC requests
        """
        return pulumi.get(self, "host_header")

    @property
    @pulumi.getter
    def method(self) -> Optional[str]:
        """
        The HTTP method to use for HC requests
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def sni(self) -> Optional[str]:
        """
        The SNI to use for HC requests over SSL
        """
        return pulumi.get(self, "sni")


@pulumi.output_type
class LoadbalancerBackendHealthCheckTcp(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class LoadbalancerCertificateCustomCertificate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateChain":
            suggest = "certificate_chain"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadbalancerCertificateCustomCertificate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadbalancerCertificateCustomCertificate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadbalancerCertificateCustomCertificate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_chain: str):
        """
        :param str certificate_chain: The full PEM-formatted certificate chain
        """
        pulumi.set(__self__, "certificate_chain", certificate_chain)

    @property
    @pulumi.getter(name="certificateChain")
    def certificate_chain(self) -> str:
        """
        The full PEM-formatted certificate chain
        """
        return pulumi.get(self, "certificate_chain")


@pulumi.output_type
class LoadbalancerCertificateLetsencrypt(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "commonName":
            suggest = "common_name"
        elif key == "subjectAlternativeNames":
            suggest = "subject_alternative_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadbalancerCertificateLetsencrypt. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadbalancerCertificateLetsencrypt.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadbalancerCertificateLetsencrypt.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 common_name: str,
                 subject_alternative_names: Optional[Sequence[str]] = None):
        """
        :param str common_name: Main domain of the certificate
        :param Sequence[str] subject_alternative_names: The alternative domain names of the certificate
        """
        pulumi.set(__self__, "common_name", common_name)
        if subject_alternative_names is not None:
            pulumi.set(__self__, "subject_alternative_names", subject_alternative_names)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> str:
        """
        Main domain of the certificate
        """
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter(name="subjectAlternativeNames")
    def subject_alternative_names(self) -> Optional[Sequence[str]]:
        """
        The alternative domain names of the certificate
        """
        return pulumi.get(self, "subject_alternative_names")


@pulumi.output_type
class LoadbalancerFrontendAcl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "updatedAt":
            suggest = "updated_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadbalancerFrontendAcl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadbalancerFrontendAcl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadbalancerFrontendAcl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: 'outputs.LoadbalancerFrontendAclAction',
                 match: 'outputs.LoadbalancerFrontendAclMatch',
                 created_at: Optional[str] = None,
                 description: Optional[str] = None,
                 name: Optional[str] = None,
                 updated_at: Optional[str] = None):
        """
        :param 'LoadbalancerFrontendAclActionArgs' action: Action to undertake when an ACL filter matches.
        :param 'LoadbalancerFrontendAclMatchArgs' match: The ACL match rule. At least `ip_subnet` or `http_filter` and `http_filter_value` are required.
        :param str created_at: IsDate and time of ACL's creation (RFC 3339 format)
        :param str description: Description of the ACL
        :param str name: The ACL name. If not provided it will be randomly generated.
        :param str updated_at: IsDate and time of ACL's update (RFC 3339 format)
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "match", match)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)

    @property
    @pulumi.getter
    def action(self) -> 'outputs.LoadbalancerFrontendAclAction':
        """
        Action to undertake when an ACL filter matches.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def match(self) -> 'outputs.LoadbalancerFrontendAclMatch':
        """
        The ACL match rule. At least `ip_subnet` or `http_filter` and `http_filter_value` are required.
        """
        return pulumi.get(self, "match")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[str]:
        """
        IsDate and time of ACL's creation (RFC 3339 format)
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of the ACL
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The ACL name. If not provided it will be randomly generated.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[str]:
        """
        IsDate and time of ACL's update (RFC 3339 format)
        """
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class LoadbalancerFrontendAclAction(dict):
    def __init__(__self__, *,
                 type: str,
                 redirects: Optional[Sequence['outputs.LoadbalancerFrontendAclActionRedirect']] = None):
        """
        :param str type: The action type. Possible values are: `allow` or `deny` or `redirect`.
        :param Sequence['LoadbalancerFrontendAclActionRedirectArgs'] redirects: Redirect parameters when using an ACL with `redirect` action.
        """
        pulumi.set(__self__, "type", type)
        if redirects is not None:
            pulumi.set(__self__, "redirects", redirects)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The action type. Possible values are: `allow` or `deny` or `redirect`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def redirects(self) -> Optional[Sequence['outputs.LoadbalancerFrontendAclActionRedirect']]:
        """
        Redirect parameters when using an ACL with `redirect` action.
        """
        return pulumi.get(self, "redirects")


@pulumi.output_type
class LoadbalancerFrontendAclActionRedirect(dict):
    def __init__(__self__, *,
                 code: Optional[int] = None,
                 target: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param int code: The HTTP redirect code to use. Valid values are `301`, `302`, `303`, `307` and `308`.
        :param str target: A URL can be used in case of a location redirect (e.g. `https://scaleway.com` will redirect to this same URL). A scheme name (e.g. `https`, `http`, `ftp`, `git`) will replace the request's original scheme.
        :param str type: The redirect type. Possible values are: `location` or `scheme`.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def code(self) -> Optional[int]:
        """
        The HTTP redirect code to use. Valid values are `301`, `302`, `303`, `307` and `308`.
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def target(self) -> Optional[str]:
        """
        A URL can be used in case of a location redirect (e.g. `https://scaleway.com` will redirect to this same URL). A scheme name (e.g. `https`, `http`, `ftp`, `git`) will replace the request's original scheme.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The redirect type. Possible values are: `location` or `scheme`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class LoadbalancerFrontendAclMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpFilter":
            suggest = "http_filter"
        elif key == "httpFilterOption":
            suggest = "http_filter_option"
        elif key == "httpFilterValues":
            suggest = "http_filter_values"
        elif key == "ipSubnets":
            suggest = "ip_subnets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadbalancerFrontendAclMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadbalancerFrontendAclMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadbalancerFrontendAclMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_filter: Optional[str] = None,
                 http_filter_option: Optional[str] = None,
                 http_filter_values: Optional[Sequence[str]] = None,
                 invert: Optional[bool] = None,
                 ip_subnets: Optional[Sequence[str]] = None):
        """
        :param str http_filter: The HTTP filter to match. This filter is supported only if your backend protocol has an HTTP forward protocol.
               It extracts the request's URL path, which starts at the first slash and ends before the question mark (without the host part).
               Possible values are: `acl_http_filter_none`, `path_begin`, `path_end`, `http_header_match` or `regex`.
        :param str http_filter_option: If you have `http_filter` at `http_header_match`, you can use this field to filter on the HTTP header's value.
        :param Sequence[str] http_filter_values: A list of possible values to match for the given HTTP filter.
               Keep in mind that in the case of `http_header_match` the HTTP header field name is case insensitive.
        :param bool invert: If set to `true`, the condition will be of type "unless".
        :param Sequence[str] ip_subnets: A list of IPs, or CIDR v4/v6 addresses of the session client, to match.
        """
        if http_filter is not None:
            pulumi.set(__self__, "http_filter", http_filter)
        if http_filter_option is not None:
            pulumi.set(__self__, "http_filter_option", http_filter_option)
        if http_filter_values is not None:
            pulumi.set(__self__, "http_filter_values", http_filter_values)
        if invert is not None:
            pulumi.set(__self__, "invert", invert)
        if ip_subnets is not None:
            pulumi.set(__self__, "ip_subnets", ip_subnets)

    @property
    @pulumi.getter(name="httpFilter")
    def http_filter(self) -> Optional[str]:
        """
        The HTTP filter to match. This filter is supported only if your backend protocol has an HTTP forward protocol.
        It extracts the request's URL path, which starts at the first slash and ends before the question mark (without the host part).
        Possible values are: `acl_http_filter_none`, `path_begin`, `path_end`, `http_header_match` or `regex`.
        """
        return pulumi.get(self, "http_filter")

    @property
    @pulumi.getter(name="httpFilterOption")
    def http_filter_option(self) -> Optional[str]:
        """
        If you have `http_filter` at `http_header_match`, you can use this field to filter on the HTTP header's value.
        """
        return pulumi.get(self, "http_filter_option")

    @property
    @pulumi.getter(name="httpFilterValues")
    def http_filter_values(self) -> Optional[Sequence[str]]:
        """
        A list of possible values to match for the given HTTP filter.
        Keep in mind that in the case of `http_header_match` the HTTP header field name is case insensitive.
        """
        return pulumi.get(self, "http_filter_values")

    @property
    @pulumi.getter
    def invert(self) -> Optional[bool]:
        """
        If set to `true`, the condition will be of type "unless".
        """
        return pulumi.get(self, "invert")

    @property
    @pulumi.getter(name="ipSubnets")
    def ip_subnets(self) -> Optional[Sequence[str]]:
        """
        A list of IPs, or CIDR v4/v6 addresses of the session client, to match.
        """
        return pulumi.get(self, "ip_subnets")


@pulumi.output_type
class LoadbalancerPrivateNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateNetworkId":
            suggest = "private_network_id"
        elif key == "dhcpConfig":
            suggest = "dhcp_config"
        elif key == "ipamIds":
            suggest = "ipam_ids"
        elif key == "staticConfig":
            suggest = "static_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadbalancerPrivateNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadbalancerPrivateNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadbalancerPrivateNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 private_network_id: str,
                 dhcp_config: Optional[bool] = None,
                 ipam_ids: Optional[str] = None,
                 static_config: Optional[str] = None,
                 status: Optional[str] = None,
                 zone: Optional[str] = None):
        """
        :param str private_network_id: (Required) The ID of the Private Network to attach to.
        :param bool dhcp_config: (Deprecated) Please use `ipam_ids`. Set to `true` if you want to let DHCP assign IP addresses. See below.
        :param str ipam_ids: (Optional) IPAM ID of a pre-reserved IP address to assign to the Load Balancer on this Private Network.
        :param str static_config: (Deprecated) Please use `ipam_ids`. Define a local ip address of your choice for the load balancer instance.
        :param str status: The status of private network connection
        :param str zone: `zone`) The zone of the Load Balancer.
        """
        pulumi.set(__self__, "private_network_id", private_network_id)
        if dhcp_config is not None:
            pulumi.set(__self__, "dhcp_config", dhcp_config)
        if ipam_ids is not None:
            pulumi.set(__self__, "ipam_ids", ipam_ids)
        if static_config is not None:
            pulumi.set(__self__, "static_config", static_config)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if zone is not None:
            pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter(name="privateNetworkId")
    def private_network_id(self) -> str:
        """
        (Required) The ID of the Private Network to attach to.
        """
        return pulumi.get(self, "private_network_id")

    @property
    @pulumi.getter(name="dhcpConfig")
    @_utilities.deprecated("""dhcp_config field is deprecated, please use `private_network_id` or `ipam_ids` instead""")
    def dhcp_config(self) -> Optional[bool]:
        """
        (Deprecated) Please use `ipam_ids`. Set to `true` if you want to let DHCP assign IP addresses. See below.
        """
        return pulumi.get(self, "dhcp_config")

    @property
    @pulumi.getter(name="ipamIds")
    def ipam_ids(self) -> Optional[str]:
        """
        (Optional) IPAM ID of a pre-reserved IP address to assign to the Load Balancer on this Private Network.
        """
        return pulumi.get(self, "ipam_ids")

    @property
    @pulumi.getter(name="staticConfig")
    @_utilities.deprecated("""static_config field is deprecated, please use `private_network_id` or `ipam_ids` instead""")
    def static_config(self) -> Optional[str]:
        """
        (Deprecated) Please use `ipam_ids`. Define a local ip address of your choice for the load balancer instance.
        """
        return pulumi.get(self, "static_config")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        The status of private network connection
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def zone(self) -> Optional[str]:
        """
        `zone`) The zone of the Load Balancer.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class MnqSnsCredentialsPermissions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "canManage":
            suggest = "can_manage"
        elif key == "canPublish":
            suggest = "can_publish"
        elif key == "canReceive":
            suggest = "can_receive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MnqSnsCredentialsPermissions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MnqSnsCredentialsPermissions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MnqSnsCredentialsPermissions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 can_manage: Optional[bool] = None,
                 can_publish: Optional[bool] = None,
                 can_receive: Optional[bool] = None):
        """
        :param bool can_manage: . Defines whether the user can manage the associated resource(s).
        :param bool can_publish: . Defines whether the user can publish messages to the service.
        :param bool can_receive: . Defines whether the user can receive messages from the service.
        """
        if can_manage is not None:
            pulumi.set(__self__, "can_manage", can_manage)
        if can_publish is not None:
            pulumi.set(__self__, "can_publish", can_publish)
        if can_receive is not None:
            pulumi.set(__self__, "can_receive", can_receive)

    @property
    @pulumi.getter(name="canManage")
    def can_manage(self) -> Optional[bool]:
        """
        . Defines whether the user can manage the associated resource(s).
        """
        return pulumi.get(self, "can_manage")

    @property
    @pulumi.getter(name="canPublish")
    def can_publish(self) -> Optional[bool]:
        """
        . Defines whether the user can publish messages to the service.
        """
        return pulumi.get(self, "can_publish")

    @property
    @pulumi.getter(name="canReceive")
    def can_receive(self) -> Optional[bool]:
        """
        . Defines whether the user can receive messages from the service.
        """
        return pulumi.get(self, "can_receive")


@pulumi.output_type
class MnqSqsCredentialsPermissions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "canManage":
            suggest = "can_manage"
        elif key == "canPublish":
            suggest = "can_publish"
        elif key == "canReceive":
            suggest = "can_receive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MnqSqsCredentialsPermissions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MnqSqsCredentialsPermissions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MnqSqsCredentialsPermissions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 can_manage: Optional[bool] = None,
                 can_publish: Optional[bool] = None,
                 can_receive: Optional[bool] = None):
        """
        :param bool can_manage: . Defines whether the user can manage the associated resource(s).
        :param bool can_publish: . Defines whether the user can publish messages to the service.
        :param bool can_receive: . Defines whether the user can receive messages from the service.
        """
        if can_manage is not None:
            pulumi.set(__self__, "can_manage", can_manage)
        if can_publish is not None:
            pulumi.set(__self__, "can_publish", can_publish)
        if can_receive is not None:
            pulumi.set(__self__, "can_receive", can_receive)

    @property
    @pulumi.getter(name="canManage")
    def can_manage(self) -> Optional[bool]:
        """
        . Defines whether the user can manage the associated resource(s).
        """
        return pulumi.get(self, "can_manage")

    @property
    @pulumi.getter(name="canPublish")
    def can_publish(self) -> Optional[bool]:
        """
        . Defines whether the user can publish messages to the service.
        """
        return pulumi.get(self, "can_publish")

    @property
    @pulumi.getter(name="canReceive")
    def can_receive(self) -> Optional[bool]:
        """
        . Defines whether the user can receive messages from the service.
        """
        return pulumi.get(self, "can_receive")


@pulumi.output_type
class MongoDbInstancePublicNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsRecord":
            suggest = "dns_record"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MongoDbInstancePublicNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MongoDbInstancePublicNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MongoDbInstancePublicNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dns_record: Optional[str] = None,
                 id: Optional[str] = None,
                 port: Optional[int] = None):
        """
        :param str dns_record: The DNS record of your endpoint
        :param str id: The ID of the MongoDB® instance.
        :param int port: TCP port of the endpoint
        """
        if dns_record is not None:
            pulumi.set(__self__, "dns_record", dns_record)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter(name="dnsRecord")
    def dns_record(self) -> Optional[str]:
        """
        The DNS record of your endpoint
        """
        return pulumi.get(self, "dns_record")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the MongoDB® instance.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        TCP port of the endpoint
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class ObjectBucketAclAccessControlPolicy(dict):
    def __init__(__self__, *,
                 owner: 'outputs.ObjectBucketAclAccessControlPolicyOwner',
                 grants: Optional[Sequence['outputs.ObjectBucketAclAccessControlPolicyGrant']] = None):
        """
        :param 'ObjectBucketAclAccessControlPolicyOwnerArgs' owner: Configuration block of the bucket project owner's display organization ID.
        """
        pulumi.set(__self__, "owner", owner)
        if grants is not None:
            pulumi.set(__self__, "grants", grants)

    @property
    @pulumi.getter
    def owner(self) -> 'outputs.ObjectBucketAclAccessControlPolicyOwner':
        """
        Configuration block of the bucket project owner's display organization ID.
        """
        return pulumi.get(self, "owner")

    @property
    @pulumi.getter
    def grants(self) -> Optional[Sequence['outputs.ObjectBucketAclAccessControlPolicyGrant']]:
        return pulumi.get(self, "grants")


@pulumi.output_type
class ObjectBucketAclAccessControlPolicyGrant(dict):
    def __init__(__self__, *,
                 permission: str,
                 grantee: Optional['outputs.ObjectBucketAclAccessControlPolicyGrantGrantee'] = None):
        """
        :param str permission: Logging permissions assigned to the grantee for the bucket.
        :param 'ObjectBucketAclAccessControlPolicyGrantGranteeArgs' grantee: Configuration block for the project being granted permissions.
        """
        pulumi.set(__self__, "permission", permission)
        if grantee is not None:
            pulumi.set(__self__, "grantee", grantee)

    @property
    @pulumi.getter
    def permission(self) -> str:
        """
        Logging permissions assigned to the grantee for the bucket.
        """
        return pulumi.get(self, "permission")

    @property
    @pulumi.getter
    def grantee(self) -> Optional['outputs.ObjectBucketAclAccessControlPolicyGrantGrantee']:
        """
        Configuration block for the project being granted permissions.
        """
        return pulumi.get(self, "grantee")


@pulumi.output_type
class ObjectBucketAclAccessControlPolicyGrantGrantee(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ObjectBucketAclAccessControlPolicyGrantGrantee. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ObjectBucketAclAccessControlPolicyGrantGrantee.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ObjectBucketAclAccessControlPolicyGrantGrantee.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 type: str,
                 display_name: Optional[str] = None):
        """
        :param str id: The `region`, `bucket` and `acl` separated by (`/`).
        :param str type: Type of grantee. Valid values: `CanonicalUser`
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "type", type)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The `region`, `bucket` and `acl` separated by (`/`).
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of grantee. Valid values: `CanonicalUser`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        return pulumi.get(self, "display_name")


@pulumi.output_type
class ObjectBucketAclAccessControlPolicyOwner(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ObjectBucketAclAccessControlPolicyOwner. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ObjectBucketAclAccessControlPolicyOwner.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ObjectBucketAclAccessControlPolicyOwner.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 display_name: Optional[str] = None):
        """
        :param str id: The `region`, `bucket` and `acl` separated by (`/`).
        :param str display_name: The project ID of the grantee.
        """
        pulumi.set(__self__, "id", id)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The `region`, `bucket` and `acl` separated by (`/`).
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        The project ID of the grantee.
        """
        return pulumi.get(self, "display_name")


@pulumi.output_type
class ObjectBucketCorsRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedMethods":
            suggest = "allowed_methods"
        elif key == "allowedOrigins":
            suggest = "allowed_origins"
        elif key == "allowedHeaders":
            suggest = "allowed_headers"
        elif key == "exposeHeaders":
            suggest = "expose_headers"
        elif key == "maxAgeSeconds":
            suggest = "max_age_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ObjectBucketCorsRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ObjectBucketCorsRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ObjectBucketCorsRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_methods: Sequence[str],
                 allowed_origins: Sequence[str],
                 allowed_headers: Optional[Sequence[str]] = None,
                 expose_headers: Optional[Sequence[str]] = None,
                 max_age_seconds: Optional[int] = None):
        """
        :param Sequence[str] allowed_methods: Specifies which methods are allowed (`GET`, `PUT`, `POST`, `DELETE` or `HEAD`).
        :param Sequence[str] allowed_origins: Specifies which origins are allowed.
        :param Sequence[str] allowed_headers: Specifies which headers are allowed.
        :param Sequence[str] expose_headers: Specifies header exposure in the response.
        :param int max_age_seconds: Specifies time in seconds that the browser can cache the response for a preflight request.
        """
        pulumi.set(__self__, "allowed_methods", allowed_methods)
        pulumi.set(__self__, "allowed_origins", allowed_origins)
        if allowed_headers is not None:
            pulumi.set(__self__, "allowed_headers", allowed_headers)
        if expose_headers is not None:
            pulumi.set(__self__, "expose_headers", expose_headers)
        if max_age_seconds is not None:
            pulumi.set(__self__, "max_age_seconds", max_age_seconds)

    @property
    @pulumi.getter(name="allowedMethods")
    def allowed_methods(self) -> Sequence[str]:
        """
        Specifies which methods are allowed (`GET`, `PUT`, `POST`, `DELETE` or `HEAD`).
        """
        return pulumi.get(self, "allowed_methods")

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Sequence[str]:
        """
        Specifies which origins are allowed.
        """
        return pulumi.get(self, "allowed_origins")

    @property
    @pulumi.getter(name="allowedHeaders")
    def allowed_headers(self) -> Optional[Sequence[str]]:
        """
        Specifies which headers are allowed.
        """
        return pulumi.get(self, "allowed_headers")

    @property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[Sequence[str]]:
        """
        Specifies header exposure in the response.
        """
        return pulumi.get(self, "expose_headers")

    @property
    @pulumi.getter(name="maxAgeSeconds")
    def max_age_seconds(self) -> Optional[int]:
        """
        Specifies time in seconds that the browser can cache the response for a preflight request.
        """
        return pulumi.get(self, "max_age_seconds")


@pulumi.output_type
class ObjectBucketLifecycleRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "abortIncompleteMultipartUploadDays":
            suggest = "abort_incomplete_multipart_upload_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ObjectBucketLifecycleRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ObjectBucketLifecycleRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ObjectBucketLifecycleRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 abort_incomplete_multipart_upload_days: Optional[int] = None,
                 expiration: Optional['outputs.ObjectBucketLifecycleRuleExpiration'] = None,
                 id: Optional[str] = None,
                 prefix: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 transitions: Optional[Sequence['outputs.ObjectBucketLifecycleRuleTransition']] = None):
        """
        :param bool enabled: The element value can be either Enabled or Disabled. If a rule is disabled, Scaleway Object Storage does not perform any of the actions defined in the rule.
        :param int abort_incomplete_multipart_upload_days: Specifies the number of days after initiating a multipart upload when the multipart upload must be completed.
               
               > **Important:** Avoid using `prefix` for `AbortIncompleteMultipartUpload`, as any incomplete multipart upload will be billed
        :param 'ObjectBucketLifecycleRuleExpirationArgs' expiration: Specifies a period in the object's expire
        :param str id: Unique identifier for the rule. Must be less than or equal to 255 characters in length.
        :param str prefix: Object key prefix identifying one or more objects to which the rule applies.
        :param Mapping[str, str] tags: Specifies object tags key and value.
        :param Sequence['ObjectBucketLifecycleRuleTransitionArgs'] transitions: Define when objects transition to another storage class
        """
        pulumi.set(__self__, "enabled", enabled)
        if abort_incomplete_multipart_upload_days is not None:
            pulumi.set(__self__, "abort_incomplete_multipart_upload_days", abort_incomplete_multipart_upload_days)
        if expiration is not None:
            pulumi.set(__self__, "expiration", expiration)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if transitions is not None:
            pulumi.set(__self__, "transitions", transitions)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        The element value can be either Enabled or Disabled. If a rule is disabled, Scaleway Object Storage does not perform any of the actions defined in the rule.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="abortIncompleteMultipartUploadDays")
    def abort_incomplete_multipart_upload_days(self) -> Optional[int]:
        """
        Specifies the number of days after initiating a multipart upload when the multipart upload must be completed.

        > **Important:** Avoid using `prefix` for `AbortIncompleteMultipartUpload`, as any incomplete multipart upload will be billed
        """
        return pulumi.get(self, "abort_incomplete_multipart_upload_days")

    @property
    @pulumi.getter
    def expiration(self) -> Optional['outputs.ObjectBucketLifecycleRuleExpiration']:
        """
        Specifies a period in the object's expire
        """
        return pulumi.get(self, "expiration")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier for the rule. Must be less than or equal to 255 characters in length.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        """
        Object key prefix identifying one or more objects to which the rule applies.
        """
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Specifies object tags key and value.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def transitions(self) -> Optional[Sequence['outputs.ObjectBucketLifecycleRuleTransition']]:
        """
        Define when objects transition to another storage class
        """
        return pulumi.get(self, "transitions")


@pulumi.output_type
class ObjectBucketLifecycleRuleExpiration(dict):
    def __init__(__self__, *,
                 days: int):
        """
        :param int days: Specifies the number of days after object creation when the specific rule action takes effect.
        """
        pulumi.set(__self__, "days", days)

    @property
    @pulumi.getter
    def days(self) -> int:
        """
        Specifies the number of days after object creation when the specific rule action takes effect.
        """
        return pulumi.get(self, "days")


@pulumi.output_type
class ObjectBucketLifecycleRuleTransition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageClass":
            suggest = "storage_class"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ObjectBucketLifecycleRuleTransition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ObjectBucketLifecycleRuleTransition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ObjectBucketLifecycleRuleTransition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 storage_class: str,
                 days: Optional[int] = None):
        """
        :param str storage_class: Specifies the Scaleway [storage class](https://www.scaleway.com/en/docs/storage/object/concepts/#storage-class) `STANDARD`, `GLACIER`, `ONEZONE_IA`  to which you want the object to transition.
               
               
               > **Important:**  If versioning is enabled, this rule only deletes the current version of an object.
               > **Important:**  If versioning is enabled, this rule only deletes the current version of an object.
               
               
               > **Important:**  `ONEZONE_IA` is only available in `fr-par` region. The storage class `GLACIER` is not available in `pl-waw` region.
               > **Important:**  `ONEZONE_IA` is only available in `fr-par` region. The storage class `GLACIER` is not available in `pl-waw` region.
        :param int days: Specifies the number of days after object creation when the specific rule action takes effect.
        """
        pulumi.set(__self__, "storage_class", storage_class)
        if days is not None:
            pulumi.set(__self__, "days", days)

    @property
    @pulumi.getter(name="storageClass")
    def storage_class(self) -> str:
        """
        Specifies the Scaleway [storage class](https://www.scaleway.com/en/docs/storage/object/concepts/#storage-class) `STANDARD`, `GLACIER`, `ONEZONE_IA`  to which you want the object to transition.


        > **Important:**  If versioning is enabled, this rule only deletes the current version of an object.
        > **Important:**  If versioning is enabled, this rule only deletes the current version of an object.


        > **Important:**  `ONEZONE_IA` is only available in `fr-par` region. The storage class `GLACIER` is not available in `pl-waw` region.
        > **Important:**  `ONEZONE_IA` is only available in `fr-par` region. The storage class `GLACIER` is not available in `pl-waw` region.
        """
        return pulumi.get(self, "storage_class")

    @property
    @pulumi.getter
    def days(self) -> Optional[int]:
        """
        Specifies the number of days after object creation when the specific rule action takes effect.
        """
        return pulumi.get(self, "days")


@pulumi.output_type
class ObjectBucketLockConfigurationRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultRetention":
            suggest = "default_retention"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ObjectBucketLockConfigurationRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ObjectBucketLockConfigurationRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ObjectBucketLockConfigurationRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_retention: 'outputs.ObjectBucketLockConfigurationRuleDefaultRetention'):
        """
        :param 'ObjectBucketLockConfigurationRuleDefaultRetentionArgs' default_retention: The default retention for the lock.
        """
        pulumi.set(__self__, "default_retention", default_retention)

    @property
    @pulumi.getter(name="defaultRetention")
    def default_retention(self) -> 'outputs.ObjectBucketLockConfigurationRuleDefaultRetention':
        """
        The default retention for the lock.
        """
        return pulumi.get(self, "default_retention")


@pulumi.output_type
class ObjectBucketLockConfigurationRuleDefaultRetention(dict):
    def __init__(__self__, *,
                 mode: str,
                 days: Optional[int] = None,
                 years: Optional[int] = None):
        """
        :param str mode: The default object lock retention mode you want to apply to new objects placed in the specified bucket. Valid values are `GOVERNANCE` or `COMPLIANCE`. Refer to the [dedicated documentation](https://www.scaleway.com/en/docs/storage/object/api-cli/object-lock/#retention-modes) for more information on retention modes.
        :param int days: The number of days you want to specify for the default retention period.
        :param int years: The number of years you want to specify for the default retention period.
        """
        pulumi.set(__self__, "mode", mode)
        if days is not None:
            pulumi.set(__self__, "days", days)
        if years is not None:
            pulumi.set(__self__, "years", years)

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        The default object lock retention mode you want to apply to new objects placed in the specified bucket. Valid values are `GOVERNANCE` or `COMPLIANCE`. Refer to the [dedicated documentation](https://www.scaleway.com/en/docs/storage/object/api-cli/object-lock/#retention-modes) for more information on retention modes.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def days(self) -> Optional[int]:
        """
        The number of days you want to specify for the default retention period.
        """
        return pulumi.get(self, "days")

    @property
    @pulumi.getter
    def years(self) -> Optional[int]:
        """
        The number of years you want to specify for the default retention period.
        """
        return pulumi.get(self, "years")


@pulumi.output_type
class ObjectBucketVersioning(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        """
        :param bool enabled: Enable versioning. Once you version-enable a bucket, it can never return to an unversioned state. You can, however, suspend versioning on that bucket.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Enable versioning. Once you version-enable a bucket, it can never return to an unversioned state. You can, however, suspend versioning on that bucket.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ObjectBucketWebsiteConfigurationErrorDocument(dict):
    def __init__(__self__, *,
                 key: str):
        """
        :param str key: The object key name to use when a 4XX class error occurs.
        """
        pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The object key name to use when a 4XX class error occurs.
        """
        return pulumi.get(self, "key")


@pulumi.output_type
class ObjectBucketWebsiteConfigurationIndexDocument(dict):
    def __init__(__self__, *,
                 suffix: str):
        """
        :param str suffix: A suffix that is appended to a request targeting a specific directory on the website endpoint.
               
               > **Important:** The suffix must not be empty and must not include a slash character. The routing is not supported.
        """
        pulumi.set(__self__, "suffix", suffix)

    @property
    @pulumi.getter
    def suffix(self) -> str:
        """
        A suffix that is appended to a request targeting a specific directory on the website endpoint.

        > **Important:** The suffix must not be empty and must not include a slash character. The routing is not supported.
        """
        return pulumi.get(self, "suffix")


@pulumi.output_type
class RedisClusterAcl(dict):
    def __init__(__self__, *,
                 ip: str,
                 description: Optional[str] = None,
                 id: Optional[str] = None):
        """
        :param str ip: The IP range to whitelist
               in [CIDR notation](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#CIDR_notation)
        :param str description: A text describing this rule. Default description: `Allow IP`
               
               > The `acl` conflict with `private_network`. Only one should be specified.
        :param str id: (Required) The UUID of the endpoint.
        """
        pulumi.set(__self__, "ip", ip)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        The IP range to whitelist
        in [CIDR notation](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#CIDR_notation)
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        A text describing this rule. Default description: `Allow IP`

        > The `acl` conflict with `private_network`. Only one should be specified.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        (Required) The UUID of the endpoint.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class RedisClusterPrivateNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endpointId":
            suggest = "endpoint_id"
        elif key == "serviceIps":
            suggest = "service_ips"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RedisClusterPrivateNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RedisClusterPrivateNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RedisClusterPrivateNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 endpoint_id: Optional[str] = None,
                 service_ips: Optional[Sequence[str]] = None,
                 zone: Optional[str] = None):
        """
        :param str id: The UUID of the Private Network resource.
        :param str endpoint_id: The ID of the endpoint.
        :param Sequence[str] service_ips: Endpoint IPv4 addresses in [CIDR notation](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#CIDR_notation). You must provide at least one IP per node.
               Keep in mind that in cluster mode you cannot edit your Private Network after its creation so if you want to be able to
               scale your cluster horizontally (adding nodes) later, you should provide more IPs than nodes.
               If not set, the IP network address within the private subnet is determined by the IP Address Management (IPAM) service.
               
               > The `private_network` conflicts with `acl`. Only one should be specified.
               
               > **Important:** The way to use Private Networks differs whether you are using Redis™ in Standalone or cluster mode.
               
               - Standalone mode (`cluster_size` = 1) : you can attach as many Private Networks as you want (each must be a separate
               block). If you detach your only Private Network, your cluster won't be reachable until you define a new Private or
               Public Network. You can modify your `private_network` and its specs, you can have both a Private and Public Network side
               by side.
               
               - Cluster mode (`cluster_size` > 2) : you can define a single Private Network as you create your cluster, you won't be
               able to edit or detach it afterward, unless you create another cluster. This also means that, if you are using a static
               configuration (`service_ips`), you won't be able to scale your cluster horizontally (add more nodes) since it would
               require updating the Private Network to add IPs.
               Your `service_ips` must be listed as follows:
        :param str zone: `zone`) The zone in which the
               Redis™ cluster should be created.
        """
        pulumi.set(__self__, "id", id)
        if endpoint_id is not None:
            pulumi.set(__self__, "endpoint_id", endpoint_id)
        if service_ips is not None:
            pulumi.set(__self__, "service_ips", service_ips)
        if zone is not None:
            pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The UUID of the Private Network resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> Optional[str]:
        """
        The ID of the endpoint.
        """
        return pulumi.get(self, "endpoint_id")

    @property
    @pulumi.getter(name="serviceIps")
    def service_ips(self) -> Optional[Sequence[str]]:
        """
        Endpoint IPv4 addresses in [CIDR notation](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#CIDR_notation). You must provide at least one IP per node.
        Keep in mind that in cluster mode you cannot edit your Private Network after its creation so if you want to be able to
        scale your cluster horizontally (adding nodes) later, you should provide more IPs than nodes.
        If not set, the IP network address within the private subnet is determined by the IP Address Management (IPAM) service.

        > The `private_network` conflicts with `acl`. Only one should be specified.

        > **Important:** The way to use Private Networks differs whether you are using Redis™ in Standalone or cluster mode.

        - Standalone mode (`cluster_size` = 1) : you can attach as many Private Networks as you want (each must be a separate
        block). If you detach your only Private Network, your cluster won't be reachable until you define a new Private or
        Public Network. You can modify your `private_network` and its specs, you can have both a Private and Public Network side
        by side.

        - Cluster mode (`cluster_size` > 2) : you can define a single Private Network as you create your cluster, you won't be
        able to edit or detach it afterward, unless you create another cluster. This also means that, if you are using a static
        configuration (`service_ips`), you won't be able to scale your cluster horizontally (add more nodes) since it would
        require updating the Private Network to add IPs.
        Your `service_ips` must be listed as follows:
        """
        return pulumi.get(self, "service_ips")

    @property
    @pulumi.getter
    def zone(self) -> Optional[str]:
        """
        `zone`) The zone in which the
        Redis™ cluster should be created.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class RedisClusterPublicNetwork(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 ips: Optional[Sequence[str]] = None,
                 port: Optional[int] = None):
        """
        :param str id: (Required) The UUID of the endpoint.
        :param Sequence[str] ips: Lis of IPv4 address of the endpoint (IP address).
        :param int port: TCP port of the endpoint.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        (Required) The UUID of the endpoint.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def ips(self) -> Optional[Sequence[str]]:
        """
        Lis of IPv4 address of the endpoint (IP address).
        """
        return pulumi.get(self, "ips")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        TCP port of the endpoint.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class SecretEphemeralPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "expiresOnceAccessed":
            suggest = "expires_once_accessed"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretEphemeralPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretEphemeralPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretEphemeralPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: str,
                 expires_once_accessed: Optional[bool] = None,
                 ttl: Optional[str] = None):
        """
        :param str action: Action to perform when the version of a secret expires. Available values can be found in [SDK constants](https://pkg.go.dev/github.com/scaleway/scaleway-sdk-go@master/api/secret/v1beta1#pkg-constants).
        :param bool expires_once_accessed: True if the secret version expires after a single user access.
        :param str ttl: Time frame, from one second and up to one year, during which the secret's versions are valid. Has to be specified in [Go Duration format](https://pkg.go.dev/time#ParseDuration) (ex: "30m", "24h").
        """
        pulumi.set(__self__, "action", action)
        if expires_once_accessed is not None:
            pulumi.set(__self__, "expires_once_accessed", expires_once_accessed)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        Action to perform when the version of a secret expires. Available values can be found in [SDK constants](https://pkg.go.dev/github.com/scaleway/scaleway-sdk-go@master/api/secret/v1beta1#pkg-constants).
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="expiresOnceAccessed")
    def expires_once_accessed(self) -> Optional[bool]:
        """
        True if the secret version expires after a single user access.
        """
        return pulumi.get(self, "expires_once_accessed")

    @property
    @pulumi.getter
    def ttl(self) -> Optional[str]:
        """
        Time frame, from one second and up to one year, during which the secret's versions are valid. Has to be specified in [Go Duration format](https://pkg.go.dev/time#ParseDuration) (ex: "30m", "24h").
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class TemDomainReputation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "previousScore":
            suggest = "previous_score"
        elif key == "previousScoredAt":
            suggest = "previous_scored_at"
        elif key == "scoredAt":
            suggest = "scored_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemDomainReputation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemDomainReputation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemDomainReputation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 previous_score: Optional[int] = None,
                 previous_scored_at: Optional[str] = None,
                 score: Optional[int] = None,
                 scored_at: Optional[str] = None,
                 status: Optional[str] = None):
        """
        :param int previous_score: The previously-calculated domain's reputation score.
        :param str previous_scored_at: The time and date the previous reputation score was calculated.
        :param int score: A range from 0 to 100 that determines your domain's reputation score.
        :param str scored_at: The time and date the score was calculated.
        :param str status: The status of the domain's reputation.
        """
        if previous_score is not None:
            pulumi.set(__self__, "previous_score", previous_score)
        if previous_scored_at is not None:
            pulumi.set(__self__, "previous_scored_at", previous_scored_at)
        if score is not None:
            pulumi.set(__self__, "score", score)
        if scored_at is not None:
            pulumi.set(__self__, "scored_at", scored_at)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="previousScore")
    def previous_score(self) -> Optional[int]:
        """
        The previously-calculated domain's reputation score.
        """
        return pulumi.get(self, "previous_score")

    @property
    @pulumi.getter(name="previousScoredAt")
    def previous_scored_at(self) -> Optional[str]:
        """
        The time and date the previous reputation score was calculated.
        """
        return pulumi.get(self, "previous_scored_at")

    @property
    @pulumi.getter
    def score(self) -> Optional[int]:
        """
        A range from 0 to 100 that determines your domain's reputation score.
        """
        return pulumi.get(self, "score")

    @property
    @pulumi.getter(name="scoredAt")
    def scored_at(self) -> Optional[str]:
        """
        The time and date the score was calculated.
        """
        return pulumi.get(self, "scored_at")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        The status of the domain's reputation.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class VpcGatewayNetworkIpamConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipamIpId":
            suggest = "ipam_ip_id"
        elif key == "pushDefaultRoute":
            suggest = "push_default_route"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcGatewayNetworkIpamConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcGatewayNetworkIpamConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcGatewayNetworkIpamConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ipam_ip_id: Optional[str] = None,
                 push_default_route: Optional[bool] = None):
        """
        :param str ipam_ip_id: Use this IPAM-booked IP ID as the Gateway's IP in this Private Network.
        :param bool push_default_route: Defines whether to enable the default route on the GatewayNetwork.
        """
        if ipam_ip_id is not None:
            pulumi.set(__self__, "ipam_ip_id", ipam_ip_id)
        if push_default_route is not None:
            pulumi.set(__self__, "push_default_route", push_default_route)

    @property
    @pulumi.getter(name="ipamIpId")
    def ipam_ip_id(self) -> Optional[str]:
        """
        Use this IPAM-booked IP ID as the Gateway's IP in this Private Network.
        """
        return pulumi.get(self, "ipam_ip_id")

    @property
    @pulumi.getter(name="pushDefaultRoute")
    def push_default_route(self) -> Optional[bool]:
        """
        Defines whether to enable the default route on the GatewayNetwork.
        """
        return pulumi.get(self, "push_default_route")


@pulumi.output_type
class VpcPrivateNetworkIpv4Subnet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "prefixLength":
            suggest = "prefix_length"
        elif key == "subnetMask":
            suggest = "subnet_mask"
        elif key == "updatedAt":
            suggest = "updated_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcPrivateNetworkIpv4Subnet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcPrivateNetworkIpv4Subnet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcPrivateNetworkIpv4Subnet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: Optional[str] = None,
                 created_at: Optional[str] = None,
                 id: Optional[str] = None,
                 prefix_length: Optional[int] = None,
                 subnet: Optional[str] = None,
                 subnet_mask: Optional[str] = None,
                 updated_at: Optional[str] = None):
        """
        :param str address: The network address of the subnet in hexadecimal notation, e.g., '2001:db8::' for a '2001:db8::/64' subnet.
        :param str created_at: The date and time of the creation of the subnet.
        :param str id: The subnet ID.
        :param int prefix_length: The length of the network prefix, e.g., 64 for a 'ffff:ffff:ffff:ffff::' mask.
        :param str subnet: The subnet CIDR.
        :param str subnet_mask: The subnet mask expressed in dotted decimal notation, e.g., '255.255.255.0' for a /24 subnet
        :param str updated_at: The date and time of the last update of the subnet.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if subnet is not None:
            pulumi.set(__self__, "subnet", subnet)
        if subnet_mask is not None:
            pulumi.set(__self__, "subnet_mask", subnet_mask)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        """
        The network address of the subnet in hexadecimal notation, e.g., '2001:db8::' for a '2001:db8::/64' subnet.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[str]:
        """
        The date and time of the creation of the subnet.
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The subnet ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[int]:
        """
        The length of the network prefix, e.g., 64 for a 'ffff:ffff:ffff:ffff::' mask.
        """
        return pulumi.get(self, "prefix_length")

    @property
    @pulumi.getter
    def subnet(self) -> Optional[str]:
        """
        The subnet CIDR.
        """
        return pulumi.get(self, "subnet")

    @property
    @pulumi.getter(name="subnetMask")
    def subnet_mask(self) -> Optional[str]:
        """
        The subnet mask expressed in dotted decimal notation, e.g., '255.255.255.0' for a /24 subnet
        """
        return pulumi.get(self, "subnet_mask")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[str]:
        """
        The date and time of the last update of the subnet.
        """
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class VpcPrivateNetworkIpv6Subnet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "prefixLength":
            suggest = "prefix_length"
        elif key == "subnetMask":
            suggest = "subnet_mask"
        elif key == "updatedAt":
            suggest = "updated_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcPrivateNetworkIpv6Subnet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcPrivateNetworkIpv6Subnet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcPrivateNetworkIpv6Subnet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: Optional[str] = None,
                 created_at: Optional[str] = None,
                 id: Optional[str] = None,
                 prefix_length: Optional[int] = None,
                 subnet: Optional[str] = None,
                 subnet_mask: Optional[str] = None,
                 updated_at: Optional[str] = None):
        """
        :param str address: The network address of the subnet in hexadecimal notation, e.g., '2001:db8::' for a '2001:db8::/64' subnet.
        :param str created_at: The date and time of the creation of the subnet.
        :param str id: The subnet ID.
        :param int prefix_length: The length of the network prefix, e.g., 64 for a 'ffff:ffff:ffff:ffff::' mask.
        :param str subnet: The subnet CIDR.
        :param str subnet_mask: The subnet mask expressed in dotted decimal notation, e.g., '255.255.255.0' for a /24 subnet
        :param str updated_at: The date and time of the last update of the subnet.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if subnet is not None:
            pulumi.set(__self__, "subnet", subnet)
        if subnet_mask is not None:
            pulumi.set(__self__, "subnet_mask", subnet_mask)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        """
        The network address of the subnet in hexadecimal notation, e.g., '2001:db8::' for a '2001:db8::/64' subnet.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[str]:
        """
        The date and time of the creation of the subnet.
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The subnet ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[int]:
        """
        The length of the network prefix, e.g., 64 for a 'ffff:ffff:ffff:ffff::' mask.
        """
        return pulumi.get(self, "prefix_length")

    @property
    @pulumi.getter
    def subnet(self) -> Optional[str]:
        """
        The subnet CIDR.
        """
        return pulumi.get(self, "subnet")

    @property
    @pulumi.getter(name="subnetMask")
    def subnet_mask(self) -> Optional[str]:
        """
        The subnet mask expressed in dotted decimal notation, e.g., '255.255.255.0' for a /24 subnet
        """
        return pulumi.get(self, "subnet_mask")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[str]:
        """
        The date and time of the last update of the subnet.
        """
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class WebhostingCpanelUrl(dict):
    def __init__(__self__, *,
                 dashboard: Optional[str] = None,
                 webmail: Optional[str] = None):
        """
        :param str dashboard: The URL of the Dashboard.
        :param str webmail: The URL of the Webmail interface.
        """
        if dashboard is not None:
            pulumi.set(__self__, "dashboard", dashboard)
        if webmail is not None:
            pulumi.set(__self__, "webmail", webmail)

    @property
    @pulumi.getter
    def dashboard(self) -> Optional[str]:
        """
        The URL of the Dashboard.
        """
        return pulumi.get(self, "dashboard")

    @property
    @pulumi.getter
    def webmail(self) -> Optional[str]:
        """
        The URL of the Webmail interface.
        """
        return pulumi.get(self, "webmail")


@pulumi.output_type
class WebhostingOption(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str id: The option ID.
        :param str name: The option name.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The option ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The option name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetBaremetalOfferCpuResult(dict):
    def __init__(__self__, *,
                 core_count: int,
                 frequency: int,
                 name: str,
                 thread_count: int):
        """
        :param int core_count: Number of core on this CPU.
        :param int frequency: Frequency of the memory in MHz.
        :param str name: The offer name. Only one of `name` and `offer_id` should be specified.
        :param int thread_count: Number of thread on this CPU.
        """
        pulumi.set(__self__, "core_count", core_count)
        pulumi.set(__self__, "frequency", frequency)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "thread_count", thread_count)

    @property
    @pulumi.getter(name="coreCount")
    def core_count(self) -> int:
        """
        Number of core on this CPU.
        """
        return pulumi.get(self, "core_count")

    @property
    @pulumi.getter
    def frequency(self) -> int:
        """
        Frequency of the memory in MHz.
        """
        return pulumi.get(self, "frequency")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The offer name. Only one of `name` and `offer_id` should be specified.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="threadCount")
    def thread_count(self) -> int:
        """
        Number of thread on this CPU.
        """
        return pulumi.get(self, "thread_count")


@pulumi.output_type
class GetBaremetalOfferDiskResult(dict):
    def __init__(__self__, *,
                 capacity: int,
                 type: str):
        """
        :param int capacity: Capacity of the memory in GB.
        :param str type: Type of memory.
        """
        pulumi.set(__self__, "capacity", capacity)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def capacity(self) -> int:
        """
        Capacity of the memory in GB.
        """
        return pulumi.get(self, "capacity")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of memory.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetBaremetalOfferMemoryResult(dict):
    def __init__(__self__, *,
                 capacity: int,
                 frequency: int,
                 is_ecc: bool,
                 type: str):
        """
        :param int capacity: Capacity of the memory in GB.
        :param int frequency: Frequency of the memory in MHz.
        :param bool is_ecc: True if error-correcting code is available on this memory.
        :param str type: Type of memory.
        """
        pulumi.set(__self__, "capacity", capacity)
        pulumi.set(__self__, "frequency", frequency)
        pulumi.set(__self__, "is_ecc", is_ecc)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def capacity(self) -> int:
        """
        Capacity of the memory in GB.
        """
        return pulumi.get(self, "capacity")

    @property
    @pulumi.getter
    def frequency(self) -> int:
        """
        Frequency of the memory in MHz.
        """
        return pulumi.get(self, "frequency")

    @property
    @pulumi.getter(name="isEcc")
    def is_ecc(self) -> bool:
        """
        True if error-correcting code is available on this memory.
        """
        return pulumi.get(self, "is_ecc")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of memory.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetBaremetalServerIpResult(dict):
    def __init__(__self__, *,
                 address: str,
                 id: str,
                 reverse: str,
                 version: str):
        """
        :param str address: The IPv6 address
        :param str id: The ID of the server.
        :param str reverse: The Reverse of the IPv6
        :param str version: The version of the IPv6
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "reverse", reverse)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        The IPv6 address
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the server.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def reverse(self) -> str:
        """
        The Reverse of the IPv6
        """
        return pulumi.get(self, "reverse")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        The version of the IPv6
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetBaremetalServerIpv4Result(dict):
    def __init__(__self__, *,
                 address: str,
                 id: str,
                 reverse: str,
                 version: str):
        """
        :param str address: The IPv6 address
        :param str id: The ID of the server.
        :param str reverse: The Reverse of the IPv6
        :param str version: The version of the IPv6
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "reverse", reverse)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        The IPv6 address
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the server.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def reverse(self) -> str:
        """
        The Reverse of the IPv6
        """
        return pulumi.get(self, "reverse")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        The version of the IPv6
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetBaremetalServerIpv6Result(dict):
    def __init__(__self__, *,
                 address: str,
                 id: str,
                 reverse: str,
                 version: str):
        """
        :param str address: The IPv6 address
        :param str id: The ID of the server.
        :param str reverse: The Reverse of the IPv6
        :param str version: The version of the IPv6
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "reverse", reverse)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        The IPv6 address
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the server.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def reverse(self) -> str:
        """
        The Reverse of the IPv6
        """
        return pulumi.get(self, "reverse")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        The version of the IPv6
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetBaremetalServerOptionResult(dict):
    def __init__(__self__, *,
                 expires_at: str,
                 id: str,
                 name: str):
        """
        :param str expires_at: Auto expire the option after this date
        :param str id: The ID of the server.
        :param str name: The server name. Only one of `name` and `server_id` should be specified.
        """
        pulumi.set(__self__, "expires_at", expires_at)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> str:
        """
        Auto expire the option after this date
        """
        return pulumi.get(self, "expires_at")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the server.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The server name. Only one of `name` and `server_id` should be specified.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetBaremetalServerPrivateNetworkResult(dict):
    def __init__(__self__, *,
                 created_at: str,
                 id: str,
                 ipam_ip_ids: Sequence[str],
                 status: str,
                 updated_at: str,
                 vlan: int):
        """
        :param str created_at: The date and time of the creation of the private network
        :param str id: The ID of the server.
        :param Sequence[str] ipam_ip_ids: List of IPAM IP IDs to attach to the server
        :param str status: The private network status
        :param str updated_at: The date and time of the last update of the private network
        :param int vlan: The VLAN ID associated to the private network
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ipam_ip_ids", ipam_ip_ids)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "updated_at", updated_at)
        pulumi.set(__self__, "vlan", vlan)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        The date and time of the creation of the private network
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the server.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="ipamIpIds")
    def ipam_ip_ids(self) -> Sequence[str]:
        """
        List of IPAM IP IDs to attach to the server
        """
        return pulumi.get(self, "ipam_ip_ids")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The private network status
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> str:
        """
        The date and time of the last update of the private network
        """
        return pulumi.get(self, "updated_at")

    @property
    @pulumi.getter
    def vlan(self) -> int:
        """
        The VLAN ID associated to the private network
        """
        return pulumi.get(self, "vlan")


@pulumi.output_type
class GetBillingConsumptionsConsumptionResult(dict):
    def __init__(__self__, *,
                 billed_quantity: str,
                 category_name: str,
                 product_name: str,
                 project_id: str,
                 sku: str,
                 unit: str,
                 value: str):
        """
        :param str billed_quantity: The consumed quantity.
        :param str category_name: The name of the consumption category.
        :param str product_name: The product name.
        :param str project_id: `project_id`) The ID of the project the consumption list is associated with.
        :param str sku: The unique identifier of the product.
        :param str unit: The unit of consumed quantity.
        :param str value: The monetary value of the consumption.
        """
        pulumi.set(__self__, "billed_quantity", billed_quantity)
        pulumi.set(__self__, "category_name", category_name)
        pulumi.set(__self__, "product_name", product_name)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "sku", sku)
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="billedQuantity")
    def billed_quantity(self) -> str:
        """
        The consumed quantity.
        """
        return pulumi.get(self, "billed_quantity")

    @property
    @pulumi.getter(name="categoryName")
    def category_name(self) -> str:
        """
        The name of the consumption category.
        """
        return pulumi.get(self, "category_name")

    @property
    @pulumi.getter(name="productName")
    def product_name(self) -> str:
        """
        The product name.
        """
        return pulumi.get(self, "product_name")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        `project_id`) The ID of the project the consumption list is associated with.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def sku(self) -> str:
        """
        The unique identifier of the product.
        """
        return pulumi.get(self, "sku")

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        The unit of consumed quantity.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The monetary value of the consumption.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetBillingInvoicesInvoiceResult(dict):
    def __init__(__self__, *,
                 billing_period: str,
                 due_date: str,
                 id: str,
                 invoice_type: str,
                 issued_date: str,
                 number: int,
                 organization_name: str,
                 seller_name: str,
                 start_date: str,
                 state: str,
                 stop_date: str,
                 total_discount: str,
                 total_tax: str,
                 total_taxed: str,
                 total_undiscount: str,
                 total_untaxed: str):
        """
        :param str billing_period: The billing period of the invoice in the YYYY-MM format.
        :param str due_date: The payment time limit, set according to the Organization's payment conditions (RFC 3339 format).
        :param str id: The associated invoice ID.
        :param str invoice_type: Invoices with the given type are listed. Valid values are `periodic` and `purchase`.
        :param str issued_date: The date when the invoice was sent to the customer (RFC 3339 format).
        :param int number: The invoice number.
        :param str organization_name: The organization name.
        :param str seller_name: The name of the seller (Scaleway).
        :param str start_date: The start date of the billing period (RFC 3339 format).
        :param str state: The state of the invoice.
        :param str stop_date: The end date of the billing period (RFC 3339 format).
        :param str total_discount: The total discount amount of the invoice.
        :param str total_tax: The total tax amount of the invoice.
        :param str total_taxed: The total amount, taxed.
        :param str total_undiscount: The total amount of the invoice before applying the discount.
        :param str total_untaxed: The total amount, untaxed.
        """
        pulumi.set(__self__, "billing_period", billing_period)
        pulumi.set(__self__, "due_date", due_date)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "invoice_type", invoice_type)
        pulumi.set(__self__, "issued_date", issued_date)
        pulumi.set(__self__, "number", number)
        pulumi.set(__self__, "organization_name", organization_name)
        pulumi.set(__self__, "seller_name", seller_name)
        pulumi.set(__self__, "start_date", start_date)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "stop_date", stop_date)
        pulumi.set(__self__, "total_discount", total_discount)
        pulumi.set(__self__, "total_tax", total_tax)
        pulumi.set(__self__, "total_taxed", total_taxed)
        pulumi.set(__self__, "total_undiscount", total_undiscount)
        pulumi.set(__self__, "total_untaxed", total_untaxed)

    @property
    @pulumi.getter(name="billingPeriod")
    def billing_period(self) -> str:
        """
        The billing period of the invoice in the YYYY-MM format.
        """
        return pulumi.get(self, "billing_period")

    @property
    @pulumi.getter(name="dueDate")
    def due_date(self) -> str:
        """
        The payment time limit, set according to the Organization's payment conditions (RFC 3339 format).
        """
        return pulumi.get(self, "due_date")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The associated invoice ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="invoiceType")
    def invoice_type(self) -> str:
        """
        Invoices with the given type are listed. Valid values are `periodic` and `purchase`.
        """
        return pulumi.get(self, "invoice_type")

    @property
    @pulumi.getter(name="issuedDate")
    def issued_date(self) -> str:
        """
        The date when the invoice was sent to the customer (RFC 3339 format).
        """
        return pulumi.get(self, "issued_date")

    @property
    @pulumi.getter
    def number(self) -> int:
        """
        The invoice number.
        """
        return pulumi.get(self, "number")

    @property
    @pulumi.getter(name="organizationName")
    def organization_name(self) -> str:
        """
        The organization name.
        """
        return pulumi.get(self, "organization_name")

    @property
    @pulumi.getter(name="sellerName")
    def seller_name(self) -> str:
        """
        The name of the seller (Scaleway).
        """
        return pulumi.get(self, "seller_name")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> str:
        """
        The start date of the billing period (RFC 3339 format).
        """
        return pulumi.get(self, "start_date")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The state of the invoice.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="stopDate")
    def stop_date(self) -> str:
        """
        The end date of the billing period (RFC 3339 format).
        """
        return pulumi.get(self, "stop_date")

    @property
    @pulumi.getter(name="totalDiscount")
    def total_discount(self) -> str:
        """
        The total discount amount of the invoice.
        """
        return pulumi.get(self, "total_discount")

    @property
    @pulumi.getter(name="totalTax")
    def total_tax(self) -> str:
        """
        The total tax amount of the invoice.
        """
        return pulumi.get(self, "total_tax")

    @property
    @pulumi.getter(name="totalTaxed")
    def total_taxed(self) -> str:
        """
        The total amount, taxed.
        """
        return pulumi.get(self, "total_taxed")

    @property
    @pulumi.getter(name="totalUndiscount")
    def total_undiscount(self) -> str:
        """
        The total amount of the invoice before applying the discount.
        """
        return pulumi.get(self, "total_undiscount")

    @property
    @pulumi.getter(name="totalUntaxed")
    def total_untaxed(self) -> str:
        """
        The total amount, untaxed.
        """
        return pulumi.get(self, "total_untaxed")


@pulumi.output_type
class GetCockpitEndpointResult(dict):
    def __init__(__self__, *,
                 alertmanager_url: str,
                 grafana_url: str,
                 logs_url: str,
                 metrics_url: str,
                 traces_url: str):
        """
        :param str alertmanager_url: (Deprecated) URL for the [Alert manager](https://www.scaleway.com/en/docs/observability/cockpit/concepts/#alert-manager).
        :param str grafana_url: (Deprecated) URL for Grafana.
        :param str logs_url: (Deprecated) URL for [logs](https://www.scaleway.com/en/docs/observability/cockpit/concepts/#logs) to retrieve in the [Data sources tab](https://console.scaleway.com/cockpit/dataSource) of the Scaleway console.
        :param str metrics_url: (Deprecated) URL for [metrics](https://www.scaleway.com/en/docs/observability/cockpit/concepts/#metric) to retrieve in the [Data sources tab](https://console.scaleway.com/cockpit/dataSource) of the Scaleway console.
        :param str traces_url: The traces URL
        """
        pulumi.set(__self__, "alertmanager_url", alertmanager_url)
        pulumi.set(__self__, "grafana_url", grafana_url)
        pulumi.set(__self__, "logs_url", logs_url)
        pulumi.set(__self__, "metrics_url", metrics_url)
        pulumi.set(__self__, "traces_url", traces_url)

    @property
    @pulumi.getter(name="alertmanagerUrl")
    def alertmanager_url(self) -> str:
        """
        (Deprecated) URL for the [Alert manager](https://www.scaleway.com/en/docs/observability/cockpit/concepts/#alert-manager).
        """
        return pulumi.get(self, "alertmanager_url")

    @property
    @pulumi.getter(name="grafanaUrl")
    def grafana_url(self) -> str:
        """
        (Deprecated) URL for Grafana.
        """
        return pulumi.get(self, "grafana_url")

    @property
    @pulumi.getter(name="logsUrl")
    def logs_url(self) -> str:
        """
        (Deprecated) URL for [logs](https://www.scaleway.com/en/docs/observability/cockpit/concepts/#logs) to retrieve in the [Data sources tab](https://console.scaleway.com/cockpit/dataSource) of the Scaleway console.
        """
        return pulumi.get(self, "logs_url")

    @property
    @pulumi.getter(name="metricsUrl")
    def metrics_url(self) -> str:
        """
        (Deprecated) URL for [metrics](https://www.scaleway.com/en/docs/observability/cockpit/concepts/#metric) to retrieve in the [Data sources tab](https://console.scaleway.com/cockpit/dataSource) of the Scaleway console.
        """
        return pulumi.get(self, "metrics_url")

    @property
    @pulumi.getter(name="tracesUrl")
    def traces_url(self) -> str:
        """
        The traces URL
        """
        return pulumi.get(self, "traces_url")


@pulumi.output_type
class GetCockpitPushUrlResult(dict):
    def __init__(__self__, *,
                 push_logs_url: str,
                 push_metrics_url: str):
        """
        :param str push_logs_url: Push URL for logs (Grafana Loki)
        :param str push_metrics_url: Push URL for metrics (Grafana Mimir)
        """
        pulumi.set(__self__, "push_logs_url", push_logs_url)
        pulumi.set(__self__, "push_metrics_url", push_metrics_url)

    @property
    @pulumi.getter(name="pushLogsUrl")
    def push_logs_url(self) -> str:
        """
        Push URL for logs (Grafana Loki)
        """
        return pulumi.get(self, "push_logs_url")

    @property
    @pulumi.getter(name="pushMetricsUrl")
    def push_metrics_url(self) -> str:
        """
        Push URL for metrics (Grafana Mimir)
        """
        return pulumi.get(self, "push_metrics_url")


@pulumi.output_type
class GetDatabaseAclAclRuleResult(dict):
    def __init__(__self__, *,
                 description: str,
                 ip: str):
        """
        :param str description: A simple text describing this rule
        :param str ip: The ip range to whitelist in [CIDR notation](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#CIDR_notation)
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        A simple text describing this rule
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        The ip range to whitelist in [CIDR notation](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#CIDR_notation)
        """
        return pulumi.get(self, "ip")


@pulumi.output_type
class GetDatabaseInstanceLoadBalancerResult(dict):
    def __init__(__self__, *,
                 endpoint_id: str,
                 hostname: str,
                 ip: str,
                 name: str,
                 port: int):
        """
        :param str endpoint_id: The endpoint ID
        :param str hostname: The hostname of your endpoint
        :param str ip: The IP of your load balancer service
        :param str name: The name of the RDB instance.
        :param int port: The port of your load balancer service
        """
        pulumi.set(__self__, "endpoint_id", endpoint_id)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> str:
        """
        The endpoint ID
        """
        return pulumi.get(self, "endpoint_id")

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The hostname of your endpoint
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        The IP of your load balancer service
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the RDB instance.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port of your load balancer service
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class GetDatabaseInstanceLogsPolicyResult(dict):
    def __init__(__self__, *,
                 max_age_retention: int,
                 total_disk_retention: int):
        """
        :param int max_age_retention: The max age (in days) of remote logs to keep on the Database Instance
        :param int total_disk_retention: The max disk size of remote logs to keep on the Database Instance.
        """
        pulumi.set(__self__, "max_age_retention", max_age_retention)
        pulumi.set(__self__, "total_disk_retention", total_disk_retention)

    @property
    @pulumi.getter(name="maxAgeRetention")
    def max_age_retention(self) -> int:
        """
        The max age (in days) of remote logs to keep on the Database Instance
        """
        return pulumi.get(self, "max_age_retention")

    @property
    @pulumi.getter(name="totalDiskRetention")
    def total_disk_retention(self) -> int:
        """
        The max disk size of remote logs to keep on the Database Instance.
        """
        return pulumi.get(self, "total_disk_retention")


@pulumi.output_type
class GetDatabaseInstancePrivateNetworkResult(dict):
    def __init__(__self__, *,
                 enable_ipam: bool,
                 endpoint_id: str,
                 hostname: str,
                 ip: str,
                 ip_net: str,
                 name: str,
                 pn_id: str,
                 port: int,
                 zone: str):
        """
        :param bool enable_ipam: Whether or not the private network endpoint should be configured with IPAM
        :param str endpoint_id: The endpoint ID
        :param str hostname: The hostname of your endpoint
        :param str ip: The IP of your Instance within the private service
        :param str ip_net: The IP with the given mask within the private subnet
        :param str name: The name of the RDB instance.
        :param str pn_id: The private network ID
        :param int port: The port of your private service
        :param str zone: The zone you want to attach the resource to
        """
        pulumi.set(__self__, "enable_ipam", enable_ipam)
        pulumi.set(__self__, "endpoint_id", endpoint_id)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "ip_net", ip_net)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "pn_id", pn_id)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter(name="enableIpam")
    def enable_ipam(self) -> bool:
        """
        Whether or not the private network endpoint should be configured with IPAM
        """
        return pulumi.get(self, "enable_ipam")

    @property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> str:
        """
        The endpoint ID
        """
        return pulumi.get(self, "endpoint_id")

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The hostname of your endpoint
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        The IP of your Instance within the private service
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="ipNet")
    def ip_net(self) -> str:
        """
        The IP with the given mask within the private subnet
        """
        return pulumi.get(self, "ip_net")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the RDB instance.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="pnId")
    def pn_id(self) -> str:
        """
        The private network ID
        """
        return pulumi.get(self, "pn_id")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port of your private service
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def zone(self) -> str:
        """
        The zone you want to attach the resource to
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class GetDatabaseInstanceReadReplicaResult(dict):
    def __init__(__self__, *,
                 ip: str,
                 name: str,
                 port: int):
        """
        :param str ip: IP of the replica
        :param str name: The name of the RDB instance.
        :param int port: Port of the replica
        """
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        IP of the replica
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the RDB instance.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Port of the replica
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class GetDomainRecordGeoIpResult(dict):
    def __init__(__self__, *,
                 matches: Sequence['outputs.GetDomainRecordGeoIpMatchResult']):
        """
        :param Sequence['GetDomainRecordGeoIpMatchArgs'] matches: The list of matches
        """
        pulumi.set(__self__, "matches", matches)

    @property
    @pulumi.getter
    def matches(self) -> Sequence['outputs.GetDomainRecordGeoIpMatchResult']:
        """
        The list of matches
        """
        return pulumi.get(self, "matches")


@pulumi.output_type
class GetDomainRecordGeoIpMatchResult(dict):
    def __init__(__self__, *,
                 continents: Sequence[str],
                 countries: Sequence[str],
                 data: str):
        """
        :param Sequence[str] continents: List of continents (eg: EU for Europe, NA for North America, AS for Asia...). List of all continents code: https://api.scaleway.com/domain-private/v2beta1/continents
        :param Sequence[str] countries: List of countries (eg: FR for France, US for the United States, GB for Great Britain...). List of all countries code: https://api.scaleway.com/domain-private/v2beta1/countries
        :param str data: The content of the record (e.g., an IPv4 address for an `A` record or a string for a `TXT` record). Cannot be used with `record_id`.
        """
        pulumi.set(__self__, "continents", continents)
        pulumi.set(__self__, "countries", countries)
        pulumi.set(__self__, "data", data)

    @property
    @pulumi.getter
    def continents(self) -> Sequence[str]:
        """
        List of continents (eg: EU for Europe, NA for North America, AS for Asia...). List of all continents code: https://api.scaleway.com/domain-private/v2beta1/continents
        """
        return pulumi.get(self, "continents")

    @property
    @pulumi.getter
    def countries(self) -> Sequence[str]:
        """
        List of countries (eg: FR for France, US for the United States, GB for Great Britain...). List of all countries code: https://api.scaleway.com/domain-private/v2beta1/countries
        """
        return pulumi.get(self, "countries")

    @property
    @pulumi.getter
    def data(self) -> str:
        """
        The content of the record (e.g., an IPv4 address for an `A` record or a string for a `TXT` record). Cannot be used with `record_id`.
        """
        return pulumi.get(self, "data")


@pulumi.output_type
class GetDomainRecordHttpServiceResult(dict):
    def __init__(__self__, *,
                 ips: Sequence[str],
                 must_contain: str,
                 strategy: str,
                 url: str,
                 user_agent: str):
        """
        :param Sequence[str] ips: IPs to check
        :param str must_contain: Text to search
        :param str strategy: Strategy to return an IP from the IPs list
        :param str url: URL to match the must_contain text to validate an IP
        :param str user_agent: User-agent used when checking the URL
        """
        pulumi.set(__self__, "ips", ips)
        pulumi.set(__self__, "must_contain", must_contain)
        pulumi.set(__self__, "strategy", strategy)
        pulumi.set(__self__, "url", url)
        pulumi.set(__self__, "user_agent", user_agent)

    @property
    @pulumi.getter
    def ips(self) -> Sequence[str]:
        """
        IPs to check
        """
        return pulumi.get(self, "ips")

    @property
    @pulumi.getter(name="mustContain")
    def must_contain(self) -> str:
        """
        Text to search
        """
        return pulumi.get(self, "must_contain")

    @property
    @pulumi.getter
    def strategy(self) -> str:
        """
        Strategy to return an IP from the IPs list
        """
        return pulumi.get(self, "strategy")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        URL to match the must_contain text to validate an IP
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="userAgent")
    def user_agent(self) -> str:
        """
        User-agent used when checking the URL
        """
        return pulumi.get(self, "user_agent")


@pulumi.output_type
class GetDomainRecordViewResult(dict):
    def __init__(__self__, *,
                 data: str,
                 subnet: str):
        """
        :param str data: The content of the record (e.g., an IPv4 address for an `A` record or a string for a `TXT` record). Cannot be used with `record_id`.
        :param str subnet: The subnet of the view
        """
        pulumi.set(__self__, "data", data)
        pulumi.set(__self__, "subnet", subnet)

    @property
    @pulumi.getter
    def data(self) -> str:
        """
        The content of the record (e.g., an IPv4 address for an `A` record or a string for a `TXT` record). Cannot be used with `record_id`.
        """
        return pulumi.get(self, "data")

    @property
    @pulumi.getter
    def subnet(self) -> str:
        """
        The subnet of the view
        """
        return pulumi.get(self, "subnet")


@pulumi.output_type
class GetDomainRecordWeightedResult(dict):
    def __init__(__self__, *,
                 ip: str,
                 weight: int):
        """
        :param str ip: The weighted IP
        :param int weight: The weight of the IP
        """
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        The weighted IP
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def weight(self) -> int:
        """
        The weight of the IP
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class GetFlexibleIpsIpResult(dict):
    def __init__(__self__, *,
                 created_at: str,
                 description: str,
                 id: str,
                 ip_address: str,
                 mac_addresses: Sequence['outputs.GetFlexibleIpsIpMacAddressResult'],
                 organization_id: str,
                 project_id: str,
                 reverse: str,
                 status: str,
                 tags: Sequence[str],
                 updated_at: str,
                 zone: str):
        """
        :param str created_at: The date on which the flexible IP was created (RFC 3339 format).
        :param str description: The description of the flexible IP.
        :param str id: The MAC address ID.
        :param Sequence['GetFlexibleIpsIpMacAddressArgs'] mac_addresses: The MAC address of the Virtual MAC.
        :param str organization_id: (Defaults to provider `organization_id`) The ID of the organization the IP is in.
        :param str project_id: (Defaults to provider `project_id`) The ID of the project the IP is in.
        :param str reverse: The reverse domain associated with this IP.
        :param str status: The status of virtual MAC.
        :param Sequence[str] tags: List of tags used as filter. IPs with these exact tags are listed.
        :param str updated_at: The date on which the flexible IP was last updated (RFC 3339 format).
        :param str zone: `zone`) The zone in which IPs exist.
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "mac_addresses", mac_addresses)
        pulumi.set(__self__, "organization_id", organization_id)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "reverse", reverse)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "updated_at", updated_at)
        pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        The date on which the flexible IP was created (RFC 3339 format).
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the flexible IP.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The MAC address ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter(name="macAddresses")
    def mac_addresses(self) -> Sequence['outputs.GetFlexibleIpsIpMacAddressResult']:
        """
        The MAC address of the Virtual MAC.
        """
        return pulumi.get(self, "mac_addresses")

    @property
    @pulumi.getter(name="organizationId")
    def organization_id(self) -> str:
        """
        (Defaults to provider `organization_id`) The ID of the organization the IP is in.
        """
        return pulumi.get(self, "organization_id")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        (Defaults to provider `project_id`) The ID of the project the IP is in.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def reverse(self) -> str:
        """
        The reverse domain associated with this IP.
        """
        return pulumi.get(self, "reverse")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The status of virtual MAC.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def tags(self) -> Sequence[str]:
        """
        List of tags used as filter. IPs with these exact tags are listed.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> str:
        """
        The date on which the flexible IP was last updated (RFC 3339 format).
        """
        return pulumi.get(self, "updated_at")

    @property
    @pulumi.getter
    def zone(self) -> str:
        """
        `zone`) The zone in which IPs exist.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class GetFlexibleIpsIpMacAddressResult(dict):
    def __init__(__self__, *,
                 created_at: str,
                 id: str,
                 mac_address: str,
                 mac_type: str,
                 status: str,
                 updated_at: str,
                 zone: str):
        """
        :param str created_at: The date on which the flexible IP was created (RFC 3339 format).
        :param str id: The MAC address ID.
        :param str mac_address: The MAC address of the Virtual MAC.
        :param str mac_type: The type of virtual MAC.
        :param str status: The status of virtual MAC.
        :param str updated_at: The date on which the flexible IP was last updated (RFC 3339 format).
        :param str zone: `zone`) The zone in which IPs exist.
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "mac_address", mac_address)
        pulumi.set(__self__, "mac_type", mac_type)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "updated_at", updated_at)
        pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        The date on which the flexible IP was created (RFC 3339 format).
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The MAC address ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="macAddress")
    def mac_address(self) -> str:
        """
        The MAC address of the Virtual MAC.
        """
        return pulumi.get(self, "mac_address")

    @property
    @pulumi.getter(name="macType")
    def mac_type(self) -> str:
        """
        The type of virtual MAC.
        """
        return pulumi.get(self, "mac_type")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The status of virtual MAC.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> str:
        """
        The date on which the flexible IP was last updated (RFC 3339 format).
        """
        return pulumi.get(self, "updated_at")

    @property
    @pulumi.getter
    def zone(self) -> str:
        """
        `zone`) The zone in which IPs exist.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class GetInstanceSecurityGroupInboundRuleResult(dict):
    def __init__(__self__, *,
                 action: str,
                 ip: str,
                 ip_range: str,
                 port: int,
                 port_range: str,
                 protocol: str):
        """
        :param str action: The action to take when rule match. Possible values are: `accept` or `drop`.
        :param str ip: The ip this rule apply to.
        :param str ip_range: The ip range (e.g `192.168.1.0/24`) this rule apply to.
        :param int port: The port this rule apply to. If no port is specified, rule will apply to all port.
        :param str port_range: The port range (e.g `22-23`) this rule applies to.
               If no `port` nor `port_range` are specified, rule will apply to all port.
               Only one of `port` and `port_range` should be specified.
        :param str protocol: The protocol this rule apply to. Possible values are: `TCP`, `UDP`, `ICMP` or `ANY`.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "ip_range", ip_range)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "port_range", port_range)
        pulumi.set(__self__, "protocol", protocol)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        The action to take when rule match. Possible values are: `accept` or `drop`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        The ip this rule apply to.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="ipRange")
    def ip_range(self) -> str:
        """
        The ip range (e.g `192.168.1.0/24`) this rule apply to.
        """
        return pulumi.get(self, "ip_range")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port this rule apply to. If no port is specified, rule will apply to all port.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portRange")
    def port_range(self) -> str:
        """
        The port range (e.g `22-23`) this rule applies to.
        If no `port` nor `port_range` are specified, rule will apply to all port.
        Only one of `port` and `port_range` should be specified.
        """
        return pulumi.get(self, "port_range")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        The protocol this rule apply to. Possible values are: `TCP`, `UDP`, `ICMP` or `ANY`.
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class GetInstanceSecurityGroupOutboundRuleResult(dict):
    def __init__(__self__, *,
                 action: str,
                 ip: str,
                 ip_range: str,
                 port: int,
                 port_range: str,
                 protocol: str):
        """
        :param str action: The action to take when rule match. Possible values are: `accept` or `drop`.
        :param str ip: The ip this rule apply to.
        :param str ip_range: The ip range (e.g `192.168.1.0/24`) this rule apply to.
        :param int port: The port this rule apply to. If no port is specified, rule will apply to all port.
        :param str port_range: The port range (e.g `22-23`) this rule applies to.
               If no `port` nor `port_range` are specified, rule will apply to all port.
               Only one of `port` and `port_range` should be specified.
        :param str protocol: The protocol this rule apply to. Possible values are: `TCP`, `UDP`, `ICMP` or `ANY`.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "ip_range", ip_range)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "port_range", port_range)
        pulumi.set(__self__, "protocol", protocol)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        The action to take when rule match. Possible values are: `accept` or `drop`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        The ip this rule apply to.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="ipRange")
    def ip_range(self) -> str:
        """
        The ip range (e.g `192.168.1.0/24`) this rule apply to.
        """
        return pulumi.get(self, "ip_range")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port this rule apply to. If no port is specified, rule will apply to all port.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portRange")
    def port_range(self) -> str:
        """
        The port range (e.g `22-23`) this rule applies to.
        If no `port` nor `port_range` are specified, rule will apply to all port.
        Only one of `port` and `port_range` should be specified.
        """
        return pulumi.get(self, "port_range")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        The protocol this rule apply to. Possible values are: `TCP`, `UDP`, `ICMP` or `ANY`.
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class GetInstanceServerPrivateNetworkResult(dict):
    def __init__(__self__, *,
                 mac_address: str,
                 pn_id: str,
                 pnic_id: str,
                 status: str,
                 zone: str):
        """
        :param str mac_address: MAC address of the NIC
        :param str pn_id: The Private Network ID
        :param str pnic_id: The ID of the NIC
        :param str status: The private NIC state
        :param str zone: `zone`) The zone in which the server exists.
        """
        pulumi.set(__self__, "mac_address", mac_address)
        pulumi.set(__self__, "pn_id", pn_id)
        pulumi.set(__self__, "pnic_id", pnic_id)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter(name="macAddress")
    def mac_address(self) -> str:
        """
        MAC address of the NIC
        """
        return pulumi.get(self, "mac_address")

    @property
    @pulumi.getter(name="pnId")
    def pn_id(self) -> str:
        """
        The Private Network ID
        """
        return pulumi.get(self, "pn_id")

    @property
    @pulumi.getter(name="pnicId")
    def pnic_id(self) -> str:
        """
        The ID of the NIC
        """
        return pulumi.get(self, "pnic_id")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The private NIC state
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def zone(self) -> str:
        """
        `zone`) The zone in which the server exists.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class GetInstanceServerPublicIpResult(dict):
    def __init__(__self__, *,
                 address: str,
                 id: str):
        """
        :param str address: The address of the IP
        :param str id: The ID of the IP
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        The address of the IP
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the IP
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetInstanceServerRootVolumeResult(dict):
    def __init__(__self__, *,
                 boot: bool,
                 delete_on_termination: bool,
                 name: str,
                 sbs_iops: int,
                 size_in_gb: int,
                 volume_id: str,
                 volume_type: str):
        """
        :param bool boot: Set the volume where the boot the server
        :param bool delete_on_termination: Forces deletion of the root volume on instance termination.
        :param str name: The server name. Only one of `name` and `server_id` should be specified.
        :param int sbs_iops: SBS Volume IOPS, only with volume_type as sbs_volume
        :param int size_in_gb: Size of the root volume in gigabytes.
        :param str volume_id: The volume ID of the root volume of the server.
        :param str volume_type: Volume type of the root volume
        """
        pulumi.set(__self__, "boot", boot)
        pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "sbs_iops", sbs_iops)
        pulumi.set(__self__, "size_in_gb", size_in_gb)
        pulumi.set(__self__, "volume_id", volume_id)
        pulumi.set(__self__, "volume_type", volume_type)

    @property
    @pulumi.getter
    def boot(self) -> bool:
        """
        Set the volume where the boot the server
        """
        return pulumi.get(self, "boot")

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> bool:
        """
        Forces deletion of the root volume on instance termination.
        """
        return pulumi.get(self, "delete_on_termination")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The server name. Only one of `name` and `server_id` should be specified.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sbsIops")
    def sbs_iops(self) -> int:
        """
        SBS Volume IOPS, only with volume_type as sbs_volume
        """
        return pulumi.get(self, "sbs_iops")

    @property
    @pulumi.getter(name="sizeInGb")
    def size_in_gb(self) -> int:
        """
        Size of the root volume in gigabytes.
        """
        return pulumi.get(self, "size_in_gb")

    @property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> str:
        """
        The volume ID of the root volume of the server.
        """
        return pulumi.get(self, "volume_id")

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> str:
        """
        Volume type of the root volume
        """
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class GetInstanceServersServerResult(dict):
    def __init__(__self__, *,
                 boot_type: str,
                 bootscript_id: str,
                 enable_dynamic_ip: bool,
                 enable_ipv6: bool,
                 id: str,
                 image: str,
                 ipv6_address: str,
                 ipv6_gateway: str,
                 ipv6_prefix_length: int,
                 name: str,
                 organization_id: str,
                 placement_group_id: str,
                 placement_group_policy_respected: bool,
                 private_ip: str,
                 project_id: str,
                 public_ip: str,
                 public_ips: Sequence['outputs.GetInstanceServersServerPublicIpResult'],
                 routed_ip_enabled: bool,
                 security_group_id: str,
                 state: str,
                 tags: Sequence[str],
                 type: str,
                 zone: str):
        """
        :param str boot_type: The boot Type of the server. Possible values are: `local`, `bootscript` or `rescue`.
        :param bool enable_dynamic_ip: If true a dynamic IP will be attached to the server.
        :param bool enable_ipv6: Determines if IPv6 is enabled for the server.
        :param str id: The ID of the IP
        :param str image: The UUID or the label of the base image used by the server.
        :param str ipv6_address: The default ipv6 address routed to the server. ( Only set when enable_ipv6 is set to true )
        :param str ipv6_gateway: The ipv6 gateway address. ( Only set when enable_ipv6 is set to true )
        :param int ipv6_prefix_length: The prefix length of the ipv6 subnet routed to the server. ( Only set when enable_ipv6 is set to true )
        :param str name: The server name used as filter. Servers with a name like it are listed.
        :param str organization_id: The organization ID the server is associated with.
        :param str placement_group_id: The [placement group](https://developers.scaleway.com/en/products/instance/api/#placement-groups-d8f653) the server is attached to.
        :param str private_ip: The Scaleway internal IP address of the server.
        :param str project_id: The ID of the project the server is associated with.
        :param str public_ip: The public IP address of the server.
        :param Sequence['GetInstanceServersServerPublicIpArgs'] public_ips: The list of public IPs of the server
        :param bool routed_ip_enabled: True if the server support routed ip only.
        :param str security_group_id: The [security group](https://developers.scaleway.com/en/products/instance/api/#security-groups-8d7f89) the server is attached to.
        :param str state: The state of the server. Possible values are: `started`, `stopped` or `standby`.
        :param Sequence[str] tags: List of tags used as filter. Servers with these exact tags are listed.
        :param str type: The commercial type of the server.
        :param str zone: `zone`) The zone in which servers exist.
        """
        pulumi.set(__self__, "boot_type", boot_type)
        pulumi.set(__self__, "bootscript_id", bootscript_id)
        pulumi.set(__self__, "enable_dynamic_ip", enable_dynamic_ip)
        pulumi.set(__self__, "enable_ipv6", enable_ipv6)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "image", image)
        pulumi.set(__self__, "ipv6_address", ipv6_address)
        pulumi.set(__self__, "ipv6_gateway", ipv6_gateway)
        pulumi.set(__self__, "ipv6_prefix_length", ipv6_prefix_length)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "organization_id", organization_id)
        pulumi.set(__self__, "placement_group_id", placement_group_id)
        pulumi.set(__self__, "placement_group_policy_respected", placement_group_policy_respected)
        pulumi.set(__self__, "private_ip", private_ip)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "public_ip", public_ip)
        pulumi.set(__self__, "public_ips", public_ips)
        pulumi.set(__self__, "routed_ip_enabled", routed_ip_enabled)
        pulumi.set(__self__, "security_group_id", security_group_id)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter(name="bootType")
    def boot_type(self) -> str:
        """
        The boot Type of the server. Possible values are: `local`, `bootscript` or `rescue`.
        """
        return pulumi.get(self, "boot_type")

    @property
    @pulumi.getter(name="bootscriptId")
    @_utilities.deprecated("""bootscript are not supported""")
    def bootscript_id(self) -> str:
        return pulumi.get(self, "bootscript_id")

    @property
    @pulumi.getter(name="enableDynamicIp")
    def enable_dynamic_ip(self) -> bool:
        """
        If true a dynamic IP will be attached to the server.
        """
        return pulumi.get(self, "enable_dynamic_ip")

    @property
    @pulumi.getter(name="enableIpv6")
    def enable_ipv6(self) -> bool:
        """
        Determines if IPv6 is enabled for the server.
        """
        return pulumi.get(self, "enable_ipv6")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the IP
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def image(self) -> str:
        """
        The UUID or the label of the base image used by the server.
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> str:
        """
        The default ipv6 address routed to the server. ( Only set when enable_ipv6 is set to true )
        """
        return pulumi.get(self, "ipv6_address")

    @property
    @pulumi.getter(name="ipv6Gateway")
    def ipv6_gateway(self) -> str:
        """
        The ipv6 gateway address. ( Only set when enable_ipv6 is set to true )
        """
        return pulumi.get(self, "ipv6_gateway")

    @property
    @pulumi.getter(name="ipv6PrefixLength")
    def ipv6_prefix_length(self) -> int:
        """
        The prefix length of the ipv6 subnet routed to the server. ( Only set when enable_ipv6 is set to true )
        """
        return pulumi.get(self, "ipv6_prefix_length")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The server name used as filter. Servers with a name like it are listed.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="organizationId")
    def organization_id(self) -> str:
        """
        The organization ID the server is associated with.
        """
        return pulumi.get(self, "organization_id")

    @property
    @pulumi.getter(name="placementGroupId")
    def placement_group_id(self) -> str:
        """
        The [placement group](https://developers.scaleway.com/en/products/instance/api/#placement-groups-d8f653) the server is attached to.
        """
        return pulumi.get(self, "placement_group_id")

    @property
    @pulumi.getter(name="placementGroupPolicyRespected")
    def placement_group_policy_respected(self) -> bool:
        return pulumi.get(self, "placement_group_policy_respected")

    @property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> str:
        """
        The Scaleway internal IP address of the server.
        """
        return pulumi.get(self, "private_ip")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        The ID of the project the server is associated with.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter(name="publicIp")
    @_utilities.deprecated("""Use public_ips instead""")
    def public_ip(self) -> str:
        """
        The public IP address of the server.
        """
        return pulumi.get(self, "public_ip")

    @property
    @pulumi.getter(name="publicIps")
    def public_ips(self) -> Sequence['outputs.GetInstanceServersServerPublicIpResult']:
        """
        The list of public IPs of the server
        """
        return pulumi.get(self, "public_ips")

    @property
    @pulumi.getter(name="routedIpEnabled")
    def routed_ip_enabled(self) -> bool:
        """
        True if the server support routed ip only.
        """
        return pulumi.get(self, "routed_ip_enabled")

    @property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> str:
        """
        The [security group](https://developers.scaleway.com/en/products/instance/api/#security-groups-8d7f89) the server is attached to.
        """
        return pulumi.get(self, "security_group_id")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The state of the server. Possible values are: `started`, `stopped` or `standby`.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def tags(self) -> Sequence[str]:
        """
        List of tags used as filter. Servers with these exact tags are listed.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The commercial type of the server.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def zone(self) -> str:
        """
        `zone`) The zone in which servers exist.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class GetInstanceServersServerPublicIpResult(dict):
    def __init__(__self__, *,
                 address: str,
                 id: str):
        """
        :param str address: The address of the IP
        :param str id: The ID of the IP
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        The address of the IP
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the IP
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetInstanceSnapshotImportResult(dict):
    def __init__(__self__, *,
                 bucket: str,
                 key: str):
        """
        :param str bucket: Bucket containing qcow
        :param str key: Key of the qcow file in the specified bucket
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def bucket(self) -> str:
        """
        Bucket containing qcow
        """
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key of the qcow file in the specified bucket
        """
        return pulumi.get(self, "key")


@pulumi.output_type
class GetIotDeviceCertificateResult(dict):
    def __init__(__self__, *,
                 crt: str,
                 key: str):
        """
        :param str crt: X509 PEM encoded certificate of the device
        :param str key: X509 PEM encoded key of the device
        """
        pulumi.set(__self__, "crt", crt)
        pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def crt(self) -> str:
        """
        X509 PEM encoded certificate of the device
        """
        return pulumi.get(self, "crt")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        X509 PEM encoded key of the device
        """
        return pulumi.get(self, "key")


@pulumi.output_type
class GetIotDeviceMessageFilterResult(dict):
    def __init__(__self__, *,
                 publishes: Sequence['outputs.GetIotDeviceMessageFilterPublishResult'],
                 subscribes: Sequence['outputs.GetIotDeviceMessageFilterSubscribeResult']):
        """
        :param Sequence['GetIotDeviceMessageFilterPublishArgs'] publishes: Rule to restrict topics the device can publish to
        :param Sequence['GetIotDeviceMessageFilterSubscribeArgs'] subscribes: Rule to restrict topics the device can subscribe to
        """
        pulumi.set(__self__, "publishes", publishes)
        pulumi.set(__self__, "subscribes", subscribes)

    @property
    @pulumi.getter
    def publishes(self) -> Sequence['outputs.GetIotDeviceMessageFilterPublishResult']:
        """
        Rule to restrict topics the device can publish to
        """
        return pulumi.get(self, "publishes")

    @property
    @pulumi.getter
    def subscribes(self) -> Sequence['outputs.GetIotDeviceMessageFilterSubscribeResult']:
        """
        Rule to restrict topics the device can subscribe to
        """
        return pulumi.get(self, "subscribes")


@pulumi.output_type
class GetIotDeviceMessageFilterPublishResult(dict):
    def __init__(__self__, *,
                 policy: str,
                 topics: Sequence[str]):
        """
        :param str policy: Publish message filter policy
        :param Sequence[str] topics: List of topics in the set
        """
        pulumi.set(__self__, "policy", policy)
        pulumi.set(__self__, "topics", topics)

    @property
    @pulumi.getter
    def policy(self) -> str:
        """
        Publish message filter policy
        """
        return pulumi.get(self, "policy")

    @property
    @pulumi.getter
    def topics(self) -> Sequence[str]:
        """
        List of topics in the set
        """
        return pulumi.get(self, "topics")


@pulumi.output_type
class GetIotDeviceMessageFilterSubscribeResult(dict):
    def __init__(__self__, *,
                 policy: str,
                 topics: Sequence[str]):
        """
        :param str policy: Subscribe message filter policy
        :param Sequence[str] topics: List of topics in the set
        """
        pulumi.set(__self__, "policy", policy)
        pulumi.set(__self__, "topics", topics)

    @property
    @pulumi.getter
    def policy(self) -> str:
        """
        Subscribe message filter policy
        """
        return pulumi.get(self, "policy")

    @property
    @pulumi.getter
    def topics(self) -> Sequence[str]:
        """
        List of topics in the set
        """
        return pulumi.get(self, "topics")


@pulumi.output_type
class GetIpamIpResourceResult(dict):
    def __init__(__self__, *,
                 type: str,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str type: The type of the resource the IP is attached to. [Documentation](https://pkg.go.dev/github.com/scaleway/scaleway-sdk-go@master/api/ipam/v1#pkg-constants) with type list.
        :param str id: The ID of the resource that the IP is attached to.
        :param str name: The name of the resource the IP is attached to.
        """
        pulumi.set(__self__, "type", type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the resource the IP is attached to. [Documentation](https://pkg.go.dev/github.com/scaleway/scaleway-sdk-go@master/api/ipam/v1#pkg-constants) with type list.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the resource that the IP is attached to.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the resource the IP is attached to.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetIpamIpsIpResult(dict):
    def __init__(__self__, *,
                 address: str,
                 created_at: str,
                 id: str,
                 project_id: str,
                 region: str,
                 resources: Sequence['outputs.GetIpamIpsIpResourceResult'],
                 tags: Sequence[str],
                 updated_at: str,
                 zone: str):
        """
        :param str address: The Scaleway internal IP address of the resource.
        :param str created_at: The date and time of the creation of the IP.
        :param str id: The ID of the resource.
        :param str project_id: The ID of the Project to filter for.
        :param str region: The region to filter for.
        :param Sequence['GetIpamIpsIpResourceArgs'] resources: Filter for a resource attached to the IP, using resource ID, type or name.
        :param Sequence[str] tags: The IP tags to filter for.
        :param str updated_at: The date and time of the last update of the IP.
        :param str zone: The zone of the IP.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "resources", resources)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "updated_at", updated_at)
        pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        The Scaleway internal IP address of the resource.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        The date and time of the creation of the IP.
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        The ID of the Project to filter for.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        The region to filter for.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter
    def resources(self) -> Sequence['outputs.GetIpamIpsIpResourceResult']:
        """
        Filter for a resource attached to the IP, using resource ID, type or name.
        """
        return pulumi.get(self, "resources")

    @property
    @pulumi.getter
    def tags(self) -> Sequence[str]:
        """
        The IP tags to filter for.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> str:
        """
        The date and time of the last update of the IP.
        """
        return pulumi.get(self, "updated_at")

    @property
    @pulumi.getter
    def zone(self) -> str:
        """
        The zone of the IP.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class GetIpamIpsIpResourceResult(dict):
    def __init__(__self__, *,
                 id: str,
                 mac_address: str,
                 name: str,
                 type: str):
        """
        :param str id: The ID of the attached resource.
        :param str mac_address: The linked MAC address to filter for.
        :param str name: The name of the attached resource.
        :param str type: The type of the attached resource. [Documentation](https://pkg.go.dev/github.com/scaleway/scaleway-sdk-go@master/api/ipam/v1#pkg-constants) with type list.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "mac_address", mac_address)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the attached resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="macAddress")
    def mac_address(self) -> str:
        """
        The linked MAC address to filter for.
        """
        return pulumi.get(self, "mac_address")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the attached resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the attached resource. [Documentation](https://pkg.go.dev/github.com/scaleway/scaleway-sdk-go@master/api/ipam/v1#pkg-constants) with type list.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetIpamIpsResourceResult(dict):
    def __init__(__self__, *,
                 type: str,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str type: The type of the attached resource. [Documentation](https://pkg.go.dev/github.com/scaleway/scaleway-sdk-go@master/api/ipam/v1#pkg-constants) with type list.
        :param str id: The ID of the attached resource.
        :param str name: The name of the attached resource.
        """
        pulumi.set(__self__, "type", type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the attached resource. [Documentation](https://pkg.go.dev/github.com/scaleway/scaleway-sdk-go@master/api/ipam/v1#pkg-constants) with type list.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the attached resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the attached resource.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetKubernetesClusterAutoUpgradeResult(dict):
    def __init__(__self__, *,
                 enable: bool,
                 maintenance_window_day: str,
                 maintenance_window_start_hour: int):
        """
        :param bool enable: True if Kubernetes patch version auto upgrades is enabled.
        :param str maintenance_window_day: The day of the auto upgrade maintenance window (`monday` to `sunday`, or `any`).
        :param int maintenance_window_start_hour: The start hour (UTC) of the 2-hour auto upgrade maintenance window (0 to 23).
        """
        pulumi.set(__self__, "enable", enable)
        pulumi.set(__self__, "maintenance_window_day", maintenance_window_day)
        pulumi.set(__self__, "maintenance_window_start_hour", maintenance_window_start_hour)

    @property
    @pulumi.getter
    def enable(self) -> bool:
        """
        True if Kubernetes patch version auto upgrades is enabled.
        """
        return pulumi.get(self, "enable")

    @property
    @pulumi.getter(name="maintenanceWindowDay")
    def maintenance_window_day(self) -> str:
        """
        The day of the auto upgrade maintenance window (`monday` to `sunday`, or `any`).
        """
        return pulumi.get(self, "maintenance_window_day")

    @property
    @pulumi.getter(name="maintenanceWindowStartHour")
    def maintenance_window_start_hour(self) -> int:
        """
        The start hour (UTC) of the 2-hour auto upgrade maintenance window (0 to 23).
        """
        return pulumi.get(self, "maintenance_window_start_hour")


@pulumi.output_type
class GetKubernetesClusterAutoscalerConfigResult(dict):
    def __init__(__self__, *,
                 balance_similar_node_groups: bool,
                 disable_scale_down: bool,
                 estimator: str,
                 expander: str,
                 expendable_pods_priority_cutoff: int,
                 ignore_daemonsets_utilization: bool,
                 max_graceful_termination_sec: int,
                 scale_down_delay_after_add: str,
                 scale_down_unneeded_time: str,
                 scale_down_utilization_threshold: float):
        """
        :param bool balance_similar_node_groups: True if detecting similar node groups and balance the number of nodes between them is enabled.
        :param bool disable_scale_down: True if the scale down feature of the autoscaler is disabled.
        :param str estimator: The type of resource estimator used in scale up.
        :param str expander: The type of node group expander be used in scale up.
        :param int expendable_pods_priority_cutoff: Pods with priority below cutoff will be expendable. They can be killed without any consideration during scale down and they don't cause scale up. Pods with null priority (PodPriority disabled) are non expendable.
        :param bool ignore_daemonsets_utilization: True if ignoring DaemonSet pods when calculating resource utilization for scaling down is enabled.
        :param int max_graceful_termination_sec: Maximum number of seconds the cluster autoscaler waits for pod termination when trying to scale down a node
        :param str scale_down_delay_after_add: The duration after scale up that scale down evaluation resumes.
        :param str scale_down_unneeded_time: The duration a node should be unneeded before it is eligible for scale down.
        :param float scale_down_utilization_threshold: Node utilization level, defined as sum of requested resources divided by capacity, below which a node can be considered for scale down
        """
        pulumi.set(__self__, "balance_similar_node_groups", balance_similar_node_groups)
        pulumi.set(__self__, "disable_scale_down", disable_scale_down)
        pulumi.set(__self__, "estimator", estimator)
        pulumi.set(__self__, "expander", expander)
        pulumi.set(__self__, "expendable_pods_priority_cutoff", expendable_pods_priority_cutoff)
        pulumi.set(__self__, "ignore_daemonsets_utilization", ignore_daemonsets_utilization)
        pulumi.set(__self__, "max_graceful_termination_sec", max_graceful_termination_sec)
        pulumi.set(__self__, "scale_down_delay_after_add", scale_down_delay_after_add)
        pulumi.set(__self__, "scale_down_unneeded_time", scale_down_unneeded_time)
        pulumi.set(__self__, "scale_down_utilization_threshold", scale_down_utilization_threshold)

    @property
    @pulumi.getter(name="balanceSimilarNodeGroups")
    def balance_similar_node_groups(self) -> bool:
        """
        True if detecting similar node groups and balance the number of nodes between them is enabled.
        """
        return pulumi.get(self, "balance_similar_node_groups")

    @property
    @pulumi.getter(name="disableScaleDown")
    def disable_scale_down(self) -> bool:
        """
        True if the scale down feature of the autoscaler is disabled.
        """
        return pulumi.get(self, "disable_scale_down")

    @property
    @pulumi.getter
    def estimator(self) -> str:
        """
        The type of resource estimator used in scale up.
        """
        return pulumi.get(self, "estimator")

    @property
    @pulumi.getter
    def expander(self) -> str:
        """
        The type of node group expander be used in scale up.
        """
        return pulumi.get(self, "expander")

    @property
    @pulumi.getter(name="expendablePodsPriorityCutoff")
    def expendable_pods_priority_cutoff(self) -> int:
        """
        Pods with priority below cutoff will be expendable. They can be killed without any consideration during scale down and they don't cause scale up. Pods with null priority (PodPriority disabled) are non expendable.
        """
        return pulumi.get(self, "expendable_pods_priority_cutoff")

    @property
    @pulumi.getter(name="ignoreDaemonsetsUtilization")
    def ignore_daemonsets_utilization(self) -> bool:
        """
        True if ignoring DaemonSet pods when calculating resource utilization for scaling down is enabled.
        """
        return pulumi.get(self, "ignore_daemonsets_utilization")

    @property
    @pulumi.getter(name="maxGracefulTerminationSec")
    def max_graceful_termination_sec(self) -> int:
        """
        Maximum number of seconds the cluster autoscaler waits for pod termination when trying to scale down a node
        """
        return pulumi.get(self, "max_graceful_termination_sec")

    @property
    @pulumi.getter(name="scaleDownDelayAfterAdd")
    def scale_down_delay_after_add(self) -> str:
        """
        The duration after scale up that scale down evaluation resumes.
        """
        return pulumi.get(self, "scale_down_delay_after_add")

    @property
    @pulumi.getter(name="scaleDownUnneededTime")
    def scale_down_unneeded_time(self) -> str:
        """
        The duration a node should be unneeded before it is eligible for scale down.
        """
        return pulumi.get(self, "scale_down_unneeded_time")

    @property
    @pulumi.getter(name="scaleDownUtilizationThreshold")
    def scale_down_utilization_threshold(self) -> float:
        """
        Node utilization level, defined as sum of requested resources divided by capacity, below which a node can be considered for scale down
        """
        return pulumi.get(self, "scale_down_utilization_threshold")


@pulumi.output_type
class GetKubernetesClusterKubeconfigResult(dict):
    def __init__(__self__, *,
                 cluster_ca_certificate: str,
                 config_file: str,
                 host: str,
                 token: str):
        """
        :param str cluster_ca_certificate: The CA certificate of the Kubernetes API server.
        :param str config_file: The raw kubeconfig file.
        :param str host: The URL of the Kubernetes API server.
        :param str token: The token to connect to the Kubernetes API server.
        """
        pulumi.set(__self__, "cluster_ca_certificate", cluster_ca_certificate)
        pulumi.set(__self__, "config_file", config_file)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "token", token)

    @property
    @pulumi.getter(name="clusterCaCertificate")
    def cluster_ca_certificate(self) -> str:
        """
        The CA certificate of the Kubernetes API server.
        """
        return pulumi.get(self, "cluster_ca_certificate")

    @property
    @pulumi.getter(name="configFile")
    def config_file(self) -> str:
        """
        The raw kubeconfig file.
        """
        return pulumi.get(self, "config_file")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        The URL of the Kubernetes API server.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def token(self) -> str:
        """
        The token to connect to the Kubernetes API server.
        """
        return pulumi.get(self, "token")


@pulumi.output_type
class GetKubernetesClusterOpenIdConnectConfigResult(dict):
    def __init__(__self__, *,
                 client_id: str,
                 groups_claims: Sequence[str],
                 groups_prefix: str,
                 issuer_url: str,
                 required_claims: Sequence[str],
                 username_claim: str,
                 username_prefix: str):
        """
        :param str client_id: A client id that all tokens must be issued for
        :param Sequence[str] groups_claims: JWT claim to use as the user's group
        :param str groups_prefix: Prefix prepended to group claims
        :param str issuer_url: URL of the provider which allows the API server to discover public signing keys
        :param Sequence[str] required_claims: Multiple key=value pairs that describes a required claim in the ID Token
        :param str username_claim: JWT claim to use as the user name
        :param str username_prefix: Prefix prepended to username
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "groups_claims", groups_claims)
        pulumi.set(__self__, "groups_prefix", groups_prefix)
        pulumi.set(__self__, "issuer_url", issuer_url)
        pulumi.set(__self__, "required_claims", required_claims)
        pulumi.set(__self__, "username_claim", username_claim)
        pulumi.set(__self__, "username_prefix", username_prefix)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        A client id that all tokens must be issued for
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="groupsClaims")
    def groups_claims(self) -> Sequence[str]:
        """
        JWT claim to use as the user's group
        """
        return pulumi.get(self, "groups_claims")

    @property
    @pulumi.getter(name="groupsPrefix")
    def groups_prefix(self) -> str:
        """
        Prefix prepended to group claims
        """
        return pulumi.get(self, "groups_prefix")

    @property
    @pulumi.getter(name="issuerUrl")
    def issuer_url(self) -> str:
        """
        URL of the provider which allows the API server to discover public signing keys
        """
        return pulumi.get(self, "issuer_url")

    @property
    @pulumi.getter(name="requiredClaims")
    def required_claims(self) -> Sequence[str]:
        """
        Multiple key=value pairs that describes a required claim in the ID Token
        """
        return pulumi.get(self, "required_claims")

    @property
    @pulumi.getter(name="usernameClaim")
    def username_claim(self) -> str:
        """
        JWT claim to use as the user name
        """
        return pulumi.get(self, "username_claim")

    @property
    @pulumi.getter(name="usernamePrefix")
    def username_prefix(self) -> str:
        """
        Prefix prepended to username
        """
        return pulumi.get(self, "username_prefix")


@pulumi.output_type
class GetKubernetesNodePoolNodeResult(dict):
    def __init__(__self__, *,
                 name: str,
                 public_ip: str,
                 public_ip_v6: str,
                 status: str):
        """
        :param str name: The pool name. Only one of `name` and `pool_id` should be specified. `cluster_id` should be specified with `name`.
        :param str public_ip: The public IPv4.
        :param str public_ip_v6: The public IPv6.
        :param str status: The status of the node.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "public_ip", public_ip)
        pulumi.set(__self__, "public_ip_v6", public_ip_v6)
        pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The pool name. Only one of `name` and `pool_id` should be specified. `cluster_id` should be specified with `name`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> str:
        """
        The public IPv4.
        """
        return pulumi.get(self, "public_ip")

    @property
    @pulumi.getter(name="publicIpV6")
    def public_ip_v6(self) -> str:
        """
        The public IPv6.
        """
        return pulumi.get(self, "public_ip_v6")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The status of the node.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetKubernetesNodePoolUpgradePolicyResult(dict):
    def __init__(__self__, *,
                 max_surge: int,
                 max_unavailable: int):
        """
        :param int max_surge: The maximum number of nodes to be created during the upgrade
        :param int max_unavailable: The maximum number of nodes that can be not ready at the same time
        """
        pulumi.set(__self__, "max_surge", max_surge)
        pulumi.set(__self__, "max_unavailable", max_unavailable)

    @property
    @pulumi.getter(name="maxSurge")
    def max_surge(self) -> int:
        """
        The maximum number of nodes to be created during the upgrade
        """
        return pulumi.get(self, "max_surge")

    @property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> int:
        """
        The maximum number of nodes that can be not ready at the same time
        """
        return pulumi.get(self, "max_unavailable")


@pulumi.output_type
class GetLbAclsAclResult(dict):
    def __init__(__self__, *,
                 actions: Sequence['outputs.GetLbAclsAclActionResult'],
                 created_at: str,
                 description: str,
                 frontend_id: str,
                 id: str,
                 index: int,
                 matches: Sequence['outputs.GetLbAclsAclMatchResult'],
                 name: str,
                 update_at: str):
        """
        :param Sequence['GetLbAclsAclActionArgs'] actions: The action to be undertaken when an ACL filter matches.
        :param str created_at: The date on which the ACL was created (RFC 3339 format).
        :param str description: The description of the ACL resource.
        :param str frontend_id: The frontend ID this ACL is attached to. ACLs with a matching frontend ID are listed.
               > **Important:** LB frontend IDs are zoned, which means they are of the form `{zone}/{id}`, e.g. `fr-par-1/11111111-1111-1111-1111-111111111111`
        :param str id: The associated ACL ID.
               > **Important:** LB ACLs' IDs are zoned, which means they are of the form `{zone}/{id}`, e.g. `fr-par-1/11111111-1111-1111-1111-111111111111`
        :param int index: The priority of this ACL in the ordered list.
        :param Sequence['GetLbAclsAclMatchArgs'] matches: The ACL match rule.
        :param str name: The ACL name to filter for. ACLs with a matching name are listed.
        :param str update_at: The date on which the ACL was last updated (RFC 3339 format).
        """
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "frontend_id", frontend_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "index", index)
        pulumi.set(__self__, "matches", matches)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "update_at", update_at)

    @property
    @pulumi.getter
    def actions(self) -> Sequence['outputs.GetLbAclsAclActionResult']:
        """
        The action to be undertaken when an ACL filter matches.
        """
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        The date on which the ACL was created (RFC 3339 format).
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the ACL resource.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="frontendId")
    def frontend_id(self) -> str:
        """
        The frontend ID this ACL is attached to. ACLs with a matching frontend ID are listed.
        > **Important:** LB frontend IDs are zoned, which means they are of the form `{zone}/{id}`, e.g. `fr-par-1/11111111-1111-1111-1111-111111111111`
        """
        return pulumi.get(self, "frontend_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The associated ACL ID.
        > **Important:** LB ACLs' IDs are zoned, which means they are of the form `{zone}/{id}`, e.g. `fr-par-1/11111111-1111-1111-1111-111111111111`
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def index(self) -> int:
        """
        The priority of this ACL in the ordered list.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def matches(self) -> Sequence['outputs.GetLbAclsAclMatchResult']:
        """
        The ACL match rule.
        """
        return pulumi.get(self, "matches")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The ACL name to filter for. ACLs with a matching name are listed.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="updateAt")
    def update_at(self) -> str:
        """
        The date on which the ACL was last updated (RFC 3339 format).
        """
        return pulumi.get(self, "update_at")


@pulumi.output_type
class GetLbAclsAclActionResult(dict):
    def __init__(__self__, *,
                 redirects: Sequence['outputs.GetLbAclsAclActionRedirectResult'],
                 type: str):
        """
        :param Sequence['GetLbAclsAclActionRedirectArgs'] redirects: Redirect parameters when using an ACL with `redirect` action.
        :param str type: The redirect type.
        """
        pulumi.set(__self__, "redirects", redirects)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def redirects(self) -> Sequence['outputs.GetLbAclsAclActionRedirectResult']:
        """
        Redirect parameters when using an ACL with `redirect` action.
        """
        return pulumi.get(self, "redirects")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The redirect type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetLbAclsAclActionRedirectResult(dict):
    def __init__(__self__, *,
                 code: int,
                 target: str,
                 type: str):
        """
        :param int code: The HTTP redirect code to use.
        :param str target: The URL used in case of a location redirect, or the scheme name that replaces the request's original scheme.
        :param str type: The redirect type.
        """
        pulumi.set(__self__, "code", code)
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def code(self) -> int:
        """
        The HTTP redirect code to use.
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        The URL used in case of a location redirect, or the scheme name that replaces the request's original scheme.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The redirect type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetLbAclsAclMatchResult(dict):
    def __init__(__self__, *,
                 http_filter: str,
                 http_filter_option: str,
                 http_filter_values: Sequence[str],
                 invert: bool,
                 ip_subnets: Sequence[str]):
        """
        :param str http_filter: The HTTP filter to match.
        :param str http_filter_option: A list of possible values for the HTTP filter based on the HTTP header.
        :param Sequence[str] http_filter_values: The possible values to match for a given HTTP filter.
        :param bool invert: The condition will be of type "unless" if invert is set to `true`
        :param Sequence[str] ip_subnets: A list of IPs, or CIDR v4/v6 addresses of the session client, to match.
        """
        pulumi.set(__self__, "http_filter", http_filter)
        pulumi.set(__self__, "http_filter_option", http_filter_option)
        pulumi.set(__self__, "http_filter_values", http_filter_values)
        pulumi.set(__self__, "invert", invert)
        pulumi.set(__self__, "ip_subnets", ip_subnets)

    @property
    @pulumi.getter(name="httpFilter")
    def http_filter(self) -> str:
        """
        The HTTP filter to match.
        """
        return pulumi.get(self, "http_filter")

    @property
    @pulumi.getter(name="httpFilterOption")
    def http_filter_option(self) -> str:
        """
        A list of possible values for the HTTP filter based on the HTTP header.
        """
        return pulumi.get(self, "http_filter_option")

    @property
    @pulumi.getter(name="httpFilterValues")
    def http_filter_values(self) -> Sequence[str]:
        """
        The possible values to match for a given HTTP filter.
        """
        return pulumi.get(self, "http_filter_values")

    @property
    @pulumi.getter
    def invert(self) -> bool:
        """
        The condition will be of type "unless" if invert is set to `true`
        """
        return pulumi.get(self, "invert")

    @property
    @pulumi.getter(name="ipSubnets")
    def ip_subnets(self) -> Sequence[str]:
        """
        A list of IPs, or CIDR v4/v6 addresses of the session client, to match.
        """
        return pulumi.get(self, "ip_subnets")


@pulumi.output_type
class GetLbBackendHealthCheckHttpResult(dict):
    def __init__(__self__, *,
                 code: int,
                 host_header: str,
                 method: str,
                 sni: str,
                 uri: str):
        """
        :param int code: The expected HTTP status code
        :param str host_header: The HTTP host header to use for HC requests
        :param str method: The HTTP method to use for HC requests
        :param str sni: The SNI to use for HC requests over SSL
        :param str uri: The HTTPS endpoint URL to call for HC requests
        """
        pulumi.set(__self__, "code", code)
        pulumi.set(__self__, "host_header", host_header)
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "sni", sni)
        pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def code(self) -> int:
        """
        The expected HTTP status code
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter(name="hostHeader")
    def host_header(self) -> str:
        """
        The HTTP host header to use for HC requests
        """
        return pulumi.get(self, "host_header")

    @property
    @pulumi.getter
    def method(self) -> str:
        """
        The HTTP method to use for HC requests
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def sni(self) -> str:
        """
        The SNI to use for HC requests over SSL
        """
        return pulumi.get(self, "sni")

    @property
    @pulumi.getter
    def uri(self) -> str:
        """
        The HTTPS endpoint URL to call for HC requests
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class GetLbBackendHealthCheckTcpResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetLbBackendsBackendResult(dict):
    def __init__(__self__, *,
                 created_at: str,
                 failover_host: str,
                 forward_port: int,
                 forward_port_algorithm: str,
                 forward_protocol: str,
                 health_check_delay: str,
                 health_check_http: Sequence['outputs.GetLbBackendsBackendHealthCheckHttpResult'],
                 health_check_https: Sequence['outputs.GetLbBackendsBackendHealthCheckHttpResult'],
                 health_check_max_retries: int,
                 health_check_port: int,
                 health_check_tcps: Sequence['outputs.GetLbBackendsBackendHealthCheckTcpResult'],
                 health_check_timeout: str,
                 id: str,
                 ignore_ssl_server_verify: bool,
                 lb_id: str,
                 name: str,
                 on_marked_down_action: str,
                 proxy_protocol: str,
                 server_ips: Sequence[str],
                 ssl_bridging: bool,
                 sticky_sessions: str,
                 sticky_sessions_cookie_name: str,
                 timeout_connect: str,
                 timeout_server: str,
                 timeout_tunnel: str,
                 update_at: str):
        """
        :param str created_at: The date on which the backend was created (RFC 3339 format).
        :param str failover_host: Scaleway S3 bucket website to be served if all backend servers are down.
        :param int forward_port: User sessions will be forwarded to this backend server port.
        :param str forward_port_algorithm: Load balancing algorithm.
        :param str forward_protocol: Backend protocol.
        :param str health_check_delay: Interval between two health check requests.
        :param Sequence['GetLbBackendsBackendHealthCheckHttpArgs'] health_check_http: This block enables HTTP health checks.
        :param Sequence['GetLbBackendsBackendHealthCheckHttpArgs'] health_check_https: This block enables HTTPS health checks.
        :param int health_check_max_retries: Number of allowed failed health check requests before the backend server is marked as down.
        :param int health_check_port: Port the health check requests will be sent to.
        :param Sequence['GetLbBackendsBackendHealthCheckTcpArgs'] health_check_tcps: This block enables TCP health checks.
        :param str health_check_timeout: Timeout before a health check request is considered failed.
        :param str id: The associated backend ID.
        :param bool ignore_ssl_server_verify: Specifies whether the Load Balancer should check the backend server’s certificate before initiating a connection.
        :param str lb_id: The Load Balancer ID this backend is attached to. Backends with a matching ID are listed.
        :param str name: The backend name to filter for. Backends with a matching name are listed.
        :param str on_marked_down_action: Modify what occurs when a backend server is marked down.
        :param str proxy_protocol: The type of PROXY protocol.
        :param Sequence[str] server_ips: List of backend server IP addresses.
        :param bool ssl_bridging: Enables SSL between Load Balancer and backend servers.
        :param str sticky_sessions: Enables cookie-based session persistence.
        :param str sticky_sessions_cookie_name: Cookie name for sticky sessions.
        :param str timeout_connect: Maximum initial server connection establishment time.
        :param str timeout_server: Maximum server connection inactivity time.
        :param str timeout_tunnel: Maximum tunnel inactivity time.
        :param str update_at: The date on which the backend was last updated (RFC 3339 format).
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "failover_host", failover_host)
        pulumi.set(__self__, "forward_port", forward_port)
        pulumi.set(__self__, "forward_port_algorithm", forward_port_algorithm)
        pulumi.set(__self__, "forward_protocol", forward_protocol)
        pulumi.set(__self__, "health_check_delay", health_check_delay)
        pulumi.set(__self__, "health_check_http", health_check_http)
        pulumi.set(__self__, "health_check_https", health_check_https)
        pulumi.set(__self__, "health_check_max_retries", health_check_max_retries)
        pulumi.set(__self__, "health_check_port", health_check_port)
        pulumi.set(__self__, "health_check_tcps", health_check_tcps)
        pulumi.set(__self__, "health_check_timeout", health_check_timeout)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ignore_ssl_server_verify", ignore_ssl_server_verify)
        pulumi.set(__self__, "lb_id", lb_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "on_marked_down_action", on_marked_down_action)
        pulumi.set(__self__, "proxy_protocol", proxy_protocol)
        pulumi.set(__self__, "server_ips", server_ips)
        pulumi.set(__self__, "ssl_bridging", ssl_bridging)
        pulumi.set(__self__, "sticky_sessions", sticky_sessions)
        pulumi.set(__self__, "sticky_sessions_cookie_name", sticky_sessions_cookie_name)
        pulumi.set(__self__, "timeout_connect", timeout_connect)
        pulumi.set(__self__, "timeout_server", timeout_server)
        pulumi.set(__self__, "timeout_tunnel", timeout_tunnel)
        pulumi.set(__self__, "update_at", update_at)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        The date on which the backend was created (RFC 3339 format).
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="failoverHost")
    def failover_host(self) -> str:
        """
        Scaleway S3 bucket website to be served if all backend servers are down.
        """
        return pulumi.get(self, "failover_host")

    @property
    @pulumi.getter(name="forwardPort")
    def forward_port(self) -> int:
        """
        User sessions will be forwarded to this backend server port.
        """
        return pulumi.get(self, "forward_port")

    @property
    @pulumi.getter(name="forwardPortAlgorithm")
    def forward_port_algorithm(self) -> str:
        """
        Load balancing algorithm.
        """
        return pulumi.get(self, "forward_port_algorithm")

    @property
    @pulumi.getter(name="forwardProtocol")
    def forward_protocol(self) -> str:
        """
        Backend protocol.
        """
        return pulumi.get(self, "forward_protocol")

    @property
    @pulumi.getter(name="healthCheckDelay")
    def health_check_delay(self) -> str:
        """
        Interval between two health check requests.
        """
        return pulumi.get(self, "health_check_delay")

    @property
    @pulumi.getter(name="healthCheckHttp")
    def health_check_http(self) -> Sequence['outputs.GetLbBackendsBackendHealthCheckHttpResult']:
        """
        This block enables HTTP health checks.
        """
        return pulumi.get(self, "health_check_http")

    @property
    @pulumi.getter(name="healthCheckHttps")
    def health_check_https(self) -> Sequence['outputs.GetLbBackendsBackendHealthCheckHttpResult']:
        """
        This block enables HTTPS health checks.
        """
        return pulumi.get(self, "health_check_https")

    @property
    @pulumi.getter(name="healthCheckMaxRetries")
    def health_check_max_retries(self) -> int:
        """
        Number of allowed failed health check requests before the backend server is marked as down.
        """
        return pulumi.get(self, "health_check_max_retries")

    @property
    @pulumi.getter(name="healthCheckPort")
    def health_check_port(self) -> int:
        """
        Port the health check requests will be sent to.
        """
        return pulumi.get(self, "health_check_port")

    @property
    @pulumi.getter(name="healthCheckTcps")
    def health_check_tcps(self) -> Sequence['outputs.GetLbBackendsBackendHealthCheckTcpResult']:
        """
        This block enables TCP health checks.
        """
        return pulumi.get(self, "health_check_tcps")

    @property
    @pulumi.getter(name="healthCheckTimeout")
    def health_check_timeout(self) -> str:
        """
        Timeout before a health check request is considered failed.
        """
        return pulumi.get(self, "health_check_timeout")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The associated backend ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="ignoreSslServerVerify")
    def ignore_ssl_server_verify(self) -> bool:
        """
        Specifies whether the Load Balancer should check the backend server’s certificate before initiating a connection.
        """
        return pulumi.get(self, "ignore_ssl_server_verify")

    @property
    @pulumi.getter(name="lbId")
    def lb_id(self) -> str:
        """
        The Load Balancer ID this backend is attached to. Backends with a matching ID are listed.
        """
        return pulumi.get(self, "lb_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The backend name to filter for. Backends with a matching name are listed.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="onMarkedDownAction")
    def on_marked_down_action(self) -> str:
        """
        Modify what occurs when a backend server is marked down.
        """
        return pulumi.get(self, "on_marked_down_action")

    @property
    @pulumi.getter(name="proxyProtocol")
    def proxy_protocol(self) -> str:
        """
        The type of PROXY protocol.
        """
        return pulumi.get(self, "proxy_protocol")

    @property
    @pulumi.getter(name="serverIps")
    def server_ips(self) -> Sequence[str]:
        """
        List of backend server IP addresses.
        """
        return pulumi.get(self, "server_ips")

    @property
    @pulumi.getter(name="sslBridging")
    def ssl_bridging(self) -> bool:
        """
        Enables SSL between Load Balancer and backend servers.
        """
        return pulumi.get(self, "ssl_bridging")

    @property
    @pulumi.getter(name="stickySessions")
    def sticky_sessions(self) -> str:
        """
        Enables cookie-based session persistence.
        """
        return pulumi.get(self, "sticky_sessions")

    @property
    @pulumi.getter(name="stickySessionsCookieName")
    def sticky_sessions_cookie_name(self) -> str:
        """
        Cookie name for sticky sessions.
        """
        return pulumi.get(self, "sticky_sessions_cookie_name")

    @property
    @pulumi.getter(name="timeoutConnect")
    def timeout_connect(self) -> str:
        """
        Maximum initial server connection establishment time.
        """
        return pulumi.get(self, "timeout_connect")

    @property
    @pulumi.getter(name="timeoutServer")
    def timeout_server(self) -> str:
        """
        Maximum server connection inactivity time.
        """
        return pulumi.get(self, "timeout_server")

    @property
    @pulumi.getter(name="timeoutTunnel")
    def timeout_tunnel(self) -> str:
        """
        Maximum tunnel inactivity time.
        """
        return pulumi.get(self, "timeout_tunnel")

    @property
    @pulumi.getter(name="updateAt")
    def update_at(self) -> str:
        """
        The date on which the backend was last updated (RFC 3339 format).
        """
        return pulumi.get(self, "update_at")


@pulumi.output_type
class GetLbBackendsBackendHealthCheckHttpResult(dict):
    def __init__(__self__, *,
                 code: int,
                 host_header: str,
                 method: str,
                 sni: str,
                 uri: str):
        """
        :param int code: The expected HTTP status code.
        :param str host_header: The HTTP host header to use for health check requests.
        :param str method: The HTTP method to use for health check requests.
        :param str sni: The SNI to use for HC requests over SSL.
        :param str uri: The HTTPS endpoint URL to call for health check requests.
        """
        pulumi.set(__self__, "code", code)
        pulumi.set(__self__, "host_header", host_header)
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "sni", sni)
        pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def code(self) -> int:
        """
        The expected HTTP status code.
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter(name="hostHeader")
    def host_header(self) -> str:
        """
        The HTTP host header to use for health check requests.
        """
        return pulumi.get(self, "host_header")

    @property
    @pulumi.getter
    def method(self) -> str:
        """
        The HTTP method to use for health check requests.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def sni(self) -> str:
        """
        The SNI to use for HC requests over SSL.
        """
        return pulumi.get(self, "sni")

    @property
    @pulumi.getter
    def uri(self) -> str:
        """
        The HTTPS endpoint URL to call for health check requests.
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class GetLbBackendsBackendHealthCheckTcpResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetLbFrontendAclResult(dict):
    def __init__(__self__, *,
                 actions: Sequence['outputs.GetLbFrontendAclActionResult'],
                 created_at: str,
                 description: str,
                 matches: Sequence['outputs.GetLbFrontendAclMatchResult'],
                 name: str,
                 updated_at: str):
        """
        :param Sequence['GetLbFrontendAclActionArgs'] actions: Action to undertake when an ACL filter matches
        :param str created_at: IsDate and time of ACL's creation (RFC 3339 format)
        :param str description: Description of the ACL
        :param Sequence['GetLbFrontendAclMatchArgs'] matches: The ACL match rule
        :param str name: The name of the frontend.
               - When using the `name` you should specify the `lb-id`
        :param str updated_at: IsDate and time of ACL's update (RFC 3339 format)
        """
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "matches", matches)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "updated_at", updated_at)

    @property
    @pulumi.getter
    def actions(self) -> Sequence['outputs.GetLbFrontendAclActionResult']:
        """
        Action to undertake when an ACL filter matches
        """
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        IsDate and time of ACL's creation (RFC 3339 format)
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Description of the ACL
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def matches(self) -> Sequence['outputs.GetLbFrontendAclMatchResult']:
        """
        The ACL match rule
        """
        return pulumi.get(self, "matches")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the frontend.
        - When using the `name` you should specify the `lb-id`
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> str:
        """
        IsDate and time of ACL's update (RFC 3339 format)
        """
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class GetLbFrontendAclActionResult(dict):
    def __init__(__self__, *,
                 redirects: Sequence['outputs.GetLbFrontendAclActionRedirectResult'],
                 type: str):
        """
        :param Sequence['GetLbFrontendAclActionRedirectArgs'] redirects: Redirect parameters when using an ACL with `redirect` action
        :param str type: The action type
        """
        pulumi.set(__self__, "redirects", redirects)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def redirects(self) -> Sequence['outputs.GetLbFrontendAclActionRedirectResult']:
        """
        Redirect parameters when using an ACL with `redirect` action
        """
        return pulumi.get(self, "redirects")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The action type
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetLbFrontendAclActionRedirectResult(dict):
    def __init__(__self__, *,
                 code: int,
                 target: str,
                 type: str):
        """
        :param int code: The HTTP redirect code to use
        :param str target: An URL can be used in case of a location redirect
        :param str type: The redirect type
        """
        pulumi.set(__self__, "code", code)
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def code(self) -> int:
        """
        The HTTP redirect code to use
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        An URL can be used in case of a location redirect
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The redirect type
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetLbFrontendAclMatchResult(dict):
    def __init__(__self__, *,
                 http_filter: str,
                 http_filter_option: str,
                 http_filter_values: Sequence[str],
                 invert: bool,
                 ip_subnets: Sequence[str]):
        """
        :param str http_filter: The HTTP filter to match
        :param str http_filter_option: You can use this field with http_header_match acl type to set the header name to filter
        :param Sequence[str] http_filter_values: A list of possible values to match for the given HTTP filter
        :param bool invert: If set to true, the condition will be of type "unless"
        :param Sequence[str] ip_subnets: A list of IPs or CIDR v4/v6 addresses of the client of the session to match
        """
        pulumi.set(__self__, "http_filter", http_filter)
        pulumi.set(__self__, "http_filter_option", http_filter_option)
        pulumi.set(__self__, "http_filter_values", http_filter_values)
        pulumi.set(__self__, "invert", invert)
        pulumi.set(__self__, "ip_subnets", ip_subnets)

    @property
    @pulumi.getter(name="httpFilter")
    def http_filter(self) -> str:
        """
        The HTTP filter to match
        """
        return pulumi.get(self, "http_filter")

    @property
    @pulumi.getter(name="httpFilterOption")
    def http_filter_option(self) -> str:
        """
        You can use this field with http_header_match acl type to set the header name to filter
        """
        return pulumi.get(self, "http_filter_option")

    @property
    @pulumi.getter(name="httpFilterValues")
    def http_filter_values(self) -> Sequence[str]:
        """
        A list of possible values to match for the given HTTP filter
        """
        return pulumi.get(self, "http_filter_values")

    @property
    @pulumi.getter
    def invert(self) -> bool:
        """
        If set to true, the condition will be of type "unless"
        """
        return pulumi.get(self, "invert")

    @property
    @pulumi.getter(name="ipSubnets")
    def ip_subnets(self) -> Sequence[str]:
        """
        A list of IPs or CIDR v4/v6 addresses of the client of the session to match
        """
        return pulumi.get(self, "ip_subnets")


@pulumi.output_type
class GetLbFrontendsFrontendResult(dict):
    def __init__(__self__, *,
                 backend_id: str,
                 certificate_ids: Sequence[str],
                 created_at: str,
                 enable_http3: bool,
                 id: str,
                 inbound_port: int,
                 lb_id: str,
                 name: str,
                 timeout_client: str,
                 update_at: str):
        """
        :param str backend_id: The Load Balancer backend ID this frontend is attached to.
               > **Important:** Load Balancer backend IDs are zoned, which means they are of the form `{zone}/{id}`, e.g. `fr-par-1/11111111-1111-1111-1111-111111111111`
        :param Sequence[str] certificate_ids: List of certificate IDs that are used by the frontend.
        :param str created_at: The date on which the frontend was created (RFC 3339 format).
        :param bool enable_http3: Whether HTTP/3 protocol is activated.
        :param str id: The ID of the associated frontend.
               > **Important:** LB frontend IDs are zoned, which means they are of the form `{zone}/{id}`, e.g. `fr-par-1/11111111-1111-1111-1111-111111111111`
        :param int inbound_port: TCP port the frontend listens to.
        :param str lb_id: The Load Balancer ID this frontend is attached to. Frontends with a matching ID are listed.
        :param str name: The frontend name to filter for. Frontends with a matching name are listed.
        :param str timeout_client: Maximum inactivity time on the client side.
        :param str update_at: The date aont which the frontend was last updated (RFC 3339 format).
        """
        pulumi.set(__self__, "backend_id", backend_id)
        pulumi.set(__self__, "certificate_ids", certificate_ids)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "enable_http3", enable_http3)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "inbound_port", inbound_port)
        pulumi.set(__self__, "lb_id", lb_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "timeout_client", timeout_client)
        pulumi.set(__self__, "update_at", update_at)

    @property
    @pulumi.getter(name="backendId")
    def backend_id(self) -> str:
        """
        The Load Balancer backend ID this frontend is attached to.
        > **Important:** Load Balancer backend IDs are zoned, which means they are of the form `{zone}/{id}`, e.g. `fr-par-1/11111111-1111-1111-1111-111111111111`
        """
        return pulumi.get(self, "backend_id")

    @property
    @pulumi.getter(name="certificateIds")
    def certificate_ids(self) -> Sequence[str]:
        """
        List of certificate IDs that are used by the frontend.
        """
        return pulumi.get(self, "certificate_ids")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        The date on which the frontend was created (RFC 3339 format).
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="enableHttp3")
    def enable_http3(self) -> bool:
        """
        Whether HTTP/3 protocol is activated.
        """
        return pulumi.get(self, "enable_http3")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the associated frontend.
        > **Important:** LB frontend IDs are zoned, which means they are of the form `{zone}/{id}`, e.g. `fr-par-1/11111111-1111-1111-1111-111111111111`
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="inboundPort")
    def inbound_port(self) -> int:
        """
        TCP port the frontend listens to.
        """
        return pulumi.get(self, "inbound_port")

    @property
    @pulumi.getter(name="lbId")
    def lb_id(self) -> str:
        """
        The Load Balancer ID this frontend is attached to. Frontends with a matching ID are listed.
        """
        return pulumi.get(self, "lb_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The frontend name to filter for. Frontends with a matching name are listed.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="timeoutClient")
    def timeout_client(self) -> str:
        """
        Maximum inactivity time on the client side.
        """
        return pulumi.get(self, "timeout_client")

    @property
    @pulumi.getter(name="updateAt")
    def update_at(self) -> str:
        """
        The date aont which the frontend was last updated (RFC 3339 format).
        """
        return pulumi.get(self, "update_at")


@pulumi.output_type
class GetLbIpsIpResult(dict):
    def __init__(__self__, *,
                 id: str,
                 ip_address: str,
                 lb_id: str,
                 organization_id: str,
                 project_id: str,
                 reverse: str,
                 tags: Sequence[str],
                 zone: str):
        """
        :param str id: The ID of the associated IP.
        :param str ip_address: The IP address
        :param str lb_id: The ID of the associated Load BalancerD, if any
        :param str organization_id: The ID of the Organization the Load Balancer is associated with.
        :param str project_id: The ID of the Project the Load Balancer is associated with.
        :param str reverse: The reverse domain associated with this IP.
        :param Sequence[str] tags: List of tags used as filter. IPs with these exact tags are listed.
        :param str zone: `zone`) The zone in which the IPs exist.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "lb_id", lb_id)
        pulumi.set(__self__, "organization_id", organization_id)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "reverse", reverse)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the associated IP.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        """
        The IP address
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter(name="lbId")
    def lb_id(self) -> str:
        """
        The ID of the associated Load BalancerD, if any
        """
        return pulumi.get(self, "lb_id")

    @property
    @pulumi.getter(name="organizationId")
    def organization_id(self) -> str:
        """
        The ID of the Organization the Load Balancer is associated with.
        """
        return pulumi.get(self, "organization_id")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        The ID of the Project the Load Balancer is associated with.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def reverse(self) -> str:
        """
        The reverse domain associated with this IP.
        """
        return pulumi.get(self, "reverse")

    @property
    @pulumi.getter
    def tags(self) -> Sequence[str]:
        """
        List of tags used as filter. IPs with these exact tags are listed.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def zone(self) -> str:
        """
        `zone`) The zone in which the IPs exist.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class GetLbRoutesRouteResult(dict):
    def __init__(__self__, *,
                 backend_id: str,
                 created_at: str,
                 frontend_id: str,
                 id: str,
                 match_host_header: str,
                 match_sni: str,
                 update_at: str):
        """
        :param str backend_id: The backend ID to redirect to
        :param str created_at: The date on which the route was created (RFC 3339 format).
        :param str frontend_id: The frontend ID (the origin of the redirection), to filter for. Routes with a matching frontend ID are listed.
        :param str id: The associated route ID.
        :param str match_host_header: Specifies the host of the server to which the request is being sent.
        :param str match_sni: Server Name Indication TLS extension field from an incoming connection made via an SSL/TLS transport layer.
        :param str update_at: The date on which the route was last updated (RFC 3339 format).
        """
        pulumi.set(__self__, "backend_id", backend_id)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "frontend_id", frontend_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "match_host_header", match_host_header)
        pulumi.set(__self__, "match_sni", match_sni)
        pulumi.set(__self__, "update_at", update_at)

    @property
    @pulumi.getter(name="backendId")
    def backend_id(self) -> str:
        """
        The backend ID to redirect to
        """
        return pulumi.get(self, "backend_id")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        The date on which the route was created (RFC 3339 format).
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="frontendId")
    def frontend_id(self) -> str:
        """
        The frontend ID (the origin of the redirection), to filter for. Routes with a matching frontend ID are listed.
        """
        return pulumi.get(self, "frontend_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The associated route ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="matchHostHeader")
    def match_host_header(self) -> str:
        """
        Specifies the host of the server to which the request is being sent.
        """
        return pulumi.get(self, "match_host_header")

    @property
    @pulumi.getter(name="matchSni")
    def match_sni(self) -> str:
        """
        Server Name Indication TLS extension field from an incoming connection made via an SSL/TLS transport layer.
        """
        return pulumi.get(self, "match_sni")

    @property
    @pulumi.getter(name="updateAt")
    def update_at(self) -> str:
        """
        The date on which the route was last updated (RFC 3339 format).
        """
        return pulumi.get(self, "update_at")


@pulumi.output_type
class GetLbsLbResult(dict):
    def __init__(__self__, *,
                 backend_count: int,
                 created_at: str,
                 description: str,
                 frontend_count: int,
                 id: str,
                 instances: Sequence['outputs.GetLbsLbInstanceResult'],
                 ips: Sequence['outputs.GetLbsLbIpResult'],
                 name: str,
                 organization_id: str,
                 private_network_count: int,
                 project_id: str,
                 route_count: int,
                 ssl_compatibility_level: str,
                 status: str,
                 subscriber: str,
                 tags: Sequence[str],
                 type: str,
                 updated_at: str,
                 zone: str):
        """
        :param int backend_count: Number of backends the Load Balancer has.
        :param str created_at: Date on which the Load Balancer was created.
        :param str description: The description of the Load Balancer.
        :param int frontend_count: Number of frontends the Load Balancer has.
        :param str id: The ID of the Load Balancer.
        :param Sequence['GetLbsLbInstanceArgs'] instances: List of underlying Instances.
        :param Sequence['GetLbsLbIpArgs'] ips: List of IPs attached to the Load Balancer.
        :param str name: The Load Balancer name to filter for. Load Balancers with a matching name are listed.
        :param str organization_id: The ID of the Organization the Load Balancer is associated with.
        :param int private_network_count: Number of Private Networks attached to the Load balancer.
        :param str project_id: The ID of the Project the Load Balancer is associated with.
        :param int route_count: Number of routes the Load balancer has.
        :param str ssl_compatibility_level: Determines the minimal SSL version which needs to be supported on the client side.
        :param str status: The state of the Load Balancer Instance. Possible values are: `unknown`, `ready`, `pending`, `stopped`, `error`, `locked` and `migrating`.
        :param str subscriber: The subscriber information.
        :param Sequence[str] tags: List of tags to filter for. Load Balancers with these exact tags are listed.
        :param str type: The offer type of the Load Balancer.
        :param str updated_at: Date on which the Load Balancer was updated.
        :param str zone: `zone`) The zone in which the Load Balancers exist.
        """
        pulumi.set(__self__, "backend_count", backend_count)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "frontend_count", frontend_count)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "instances", instances)
        pulumi.set(__self__, "ips", ips)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "organization_id", organization_id)
        pulumi.set(__self__, "private_network_count", private_network_count)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "route_count", route_count)
        pulumi.set(__self__, "ssl_compatibility_level", ssl_compatibility_level)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "subscriber", subscriber)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "updated_at", updated_at)
        pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter(name="backendCount")
    def backend_count(self) -> int:
        """
        Number of backends the Load Balancer has.
        """
        return pulumi.get(self, "backend_count")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        Date on which the Load Balancer was created.
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the Load Balancer.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="frontendCount")
    def frontend_count(self) -> int:
        """
        Number of frontends the Load Balancer has.
        """
        return pulumi.get(self, "frontend_count")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Load Balancer.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def instances(self) -> Sequence['outputs.GetLbsLbInstanceResult']:
        """
        List of underlying Instances.
        """
        return pulumi.get(self, "instances")

    @property
    @pulumi.getter
    def ips(self) -> Sequence['outputs.GetLbsLbIpResult']:
        """
        List of IPs attached to the Load Balancer.
        """
        return pulumi.get(self, "ips")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The Load Balancer name to filter for. Load Balancers with a matching name are listed.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="organizationId")
    def organization_id(self) -> str:
        """
        The ID of the Organization the Load Balancer is associated with.
        """
        return pulumi.get(self, "organization_id")

    @property
    @pulumi.getter(name="privateNetworkCount")
    def private_network_count(self) -> int:
        """
        Number of Private Networks attached to the Load balancer.
        """
        return pulumi.get(self, "private_network_count")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        The ID of the Project the Load Balancer is associated with.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter(name="routeCount")
    def route_count(self) -> int:
        """
        Number of routes the Load balancer has.
        """
        return pulumi.get(self, "route_count")

    @property
    @pulumi.getter(name="sslCompatibilityLevel")
    def ssl_compatibility_level(self) -> str:
        """
        Determines the minimal SSL version which needs to be supported on the client side.
        """
        return pulumi.get(self, "ssl_compatibility_level")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The state of the Load Balancer Instance. Possible values are: `unknown`, `ready`, `pending`, `stopped`, `error`, `locked` and `migrating`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def subscriber(self) -> str:
        """
        The subscriber information.
        """
        return pulumi.get(self, "subscriber")

    @property
    @pulumi.getter
    def tags(self) -> Sequence[str]:
        """
        List of tags to filter for. Load Balancers with these exact tags are listed.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The offer type of the Load Balancer.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> str:
        """
        Date on which the Load Balancer was updated.
        """
        return pulumi.get(self, "updated_at")

    @property
    @pulumi.getter
    def zone(self) -> str:
        """
        `zone`) The zone in which the Load Balancers exist.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class GetLbsLbInstanceResult(dict):
    def __init__(__self__, *,
                 created_at: str,
                 id: str,
                 ip_address: str,
                 status: str,
                 updated_at: str,
                 zone: str):
        """
        :param str created_at: Date on which the Load Balancer was created.
        :param str id: The ID of the Load Balancer.
        :param str status: The state of the Load Balancer Instance. Possible values are: `unknown`, `ready`, `pending`, `stopped`, `error`, `locked` and `migrating`.
        :param str updated_at: Date on which the Load Balancer was updated.
        :param str zone: `zone`) The zone in which the Load Balancers exist.
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "updated_at", updated_at)
        pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        Date on which the Load Balancer was created.
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Load Balancer.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The state of the Load Balancer Instance. Possible values are: `unknown`, `ready`, `pending`, `stopped`, `error`, `locked` and `migrating`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> str:
        """
        Date on which the Load Balancer was updated.
        """
        return pulumi.get(self, "updated_at")

    @property
    @pulumi.getter
    def zone(self) -> str:
        """
        `zone`) The zone in which the Load Balancers exist.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class GetLbsLbIpResult(dict):
    def __init__(__self__, *,
                 id: str,
                 ip_address: str,
                 lb_id: str,
                 organization_id: str,
                 project_id: str,
                 reverse: str,
                 zone: str):
        """
        :param str id: The ID of the Load Balancer.
        :param str organization_id: The ID of the Organization the Load Balancer is associated with.
        :param str project_id: The ID of the Project the Load Balancer is associated with.
        :param str zone: `zone`) The zone in which the Load Balancers exist.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "lb_id", lb_id)
        pulumi.set(__self__, "organization_id", organization_id)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "reverse", reverse)
        pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Load Balancer.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter(name="lbId")
    def lb_id(self) -> str:
        return pulumi.get(self, "lb_id")

    @property
    @pulumi.getter(name="organizationId")
    def organization_id(self) -> str:
        """
        The ID of the Organization the Load Balancer is associated with.
        """
        return pulumi.get(self, "organization_id")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        The ID of the Project the Load Balancer is associated with.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def reverse(self) -> str:
        return pulumi.get(self, "reverse")

    @property
    @pulumi.getter
    def zone(self) -> str:
        """
        `zone`) The zone in which the Load Balancers exist.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class GetLoadbalancerCertificateCustomCertificateResult(dict):
    def __init__(__self__, *,
                 certificate_chain: str):
        """
        :param str certificate_chain: The full PEM-formatted certificate chain
        """
        pulumi.set(__self__, "certificate_chain", certificate_chain)

    @property
    @pulumi.getter(name="certificateChain")
    def certificate_chain(self) -> str:
        """
        The full PEM-formatted certificate chain
        """
        return pulumi.get(self, "certificate_chain")


@pulumi.output_type
class GetLoadbalancerCertificateLetsencryptResult(dict):
    def __init__(__self__, *,
                 common_name: str,
                 subject_alternative_names: Sequence[str]):
        """
        :param str common_name: The main domain name of the certificate
        :param Sequence[str] subject_alternative_names: The alternative domain names of the certificate
        """
        pulumi.set(__self__, "common_name", common_name)
        pulumi.set(__self__, "subject_alternative_names", subject_alternative_names)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> str:
        """
        The main domain name of the certificate
        """
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter(name="subjectAlternativeNames")
    def subject_alternative_names(self) -> Sequence[str]:
        """
        The alternative domain names of the certificate
        """
        return pulumi.get(self, "subject_alternative_names")


@pulumi.output_type
class GetLoadbalancerPrivateNetworkResult(dict):
    def __init__(__self__, *,
                 dhcp_config: bool,
                 ipam_ids: Sequence[str],
                 private_network_id: str,
                 static_configs: Sequence[str],
                 status: str,
                 zone: str):
        """
        :param bool dhcp_config: Set to true if you want to let DHCP assign IP addresses
        :param Sequence[str] ipam_ids: IPAM ID of a pre-reserved IP address to assign to the Load Balancer on this Private Network
        :param str private_network_id: The Private Network ID
        :param Sequence[str] static_configs: Define an IP address in the subnet of your private network that will be assigned to your load balancer instance
        :param str status: The status of private network connection
        :param str zone: (Defaults to provider `zone`) The zone in which the Load Balancer exists.
        """
        pulumi.set(__self__, "dhcp_config", dhcp_config)
        pulumi.set(__self__, "ipam_ids", ipam_ids)
        pulumi.set(__self__, "private_network_id", private_network_id)
        pulumi.set(__self__, "static_configs", static_configs)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter(name="dhcpConfig")
    def dhcp_config(self) -> bool:
        """
        Set to true if you want to let DHCP assign IP addresses
        """
        return pulumi.get(self, "dhcp_config")

    @property
    @pulumi.getter(name="ipamIds")
    def ipam_ids(self) -> Sequence[str]:
        """
        IPAM ID of a pre-reserved IP address to assign to the Load Balancer on this Private Network
        """
        return pulumi.get(self, "ipam_ids")

    @property
    @pulumi.getter(name="privateNetworkId")
    def private_network_id(self) -> str:
        """
        The Private Network ID
        """
        return pulumi.get(self, "private_network_id")

    @property
    @pulumi.getter(name="staticConfigs")
    def static_configs(self) -> Sequence[str]:
        """
        Define an IP address in the subnet of your private network that will be assigned to your load balancer instance
        """
        return pulumi.get(self, "static_configs")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The status of private network connection
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def zone(self) -> str:
        """
        (Defaults to provider `zone`) The zone in which the Load Balancer exists.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class GetMongoDbInstancePublicNetworkResult(dict):
    def __init__(__self__, *,
                 dns_record: str,
                 id: str,
                 port: int):
        """
        :param str dns_record: The DNS record of your endpoint
        :param str id: The ID of the MongoDB® Instance.
        :param int port: TCP port of the endpoint
        """
        pulumi.set(__self__, "dns_record", dns_record)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter(name="dnsRecord")
    def dns_record(self) -> str:
        """
        The DNS record of your endpoint
        """
        return pulumi.get(self, "dns_record")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the MongoDB® Instance.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        TCP port of the endpoint
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class GetObjectBucketCorsRuleResult(dict):
    def __init__(__self__, *,
                 allowed_headers: Sequence[str],
                 allowed_methods: Sequence[str],
                 allowed_origins: Sequence[str],
                 expose_headers: Sequence[str],
                 max_age_seconds: int):
        pulumi.set(__self__, "allowed_headers", allowed_headers)
        pulumi.set(__self__, "allowed_methods", allowed_methods)
        pulumi.set(__self__, "allowed_origins", allowed_origins)
        pulumi.set(__self__, "expose_headers", expose_headers)
        pulumi.set(__self__, "max_age_seconds", max_age_seconds)

    @property
    @pulumi.getter(name="allowedHeaders")
    def allowed_headers(self) -> Sequence[str]:
        return pulumi.get(self, "allowed_headers")

    @property
    @pulumi.getter(name="allowedMethods")
    def allowed_methods(self) -> Sequence[str]:
        return pulumi.get(self, "allowed_methods")

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Sequence[str]:
        return pulumi.get(self, "allowed_origins")

    @property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Sequence[str]:
        return pulumi.get(self, "expose_headers")

    @property
    @pulumi.getter(name="maxAgeSeconds")
    def max_age_seconds(self) -> int:
        return pulumi.get(self, "max_age_seconds")


@pulumi.output_type
class GetObjectBucketLifecycleRuleResult(dict):
    def __init__(__self__, *,
                 abort_incomplete_multipart_upload_days: int,
                 enabled: bool,
                 expirations: Sequence['outputs.GetObjectBucketLifecycleRuleExpirationResult'],
                 id: str,
                 prefix: str,
                 tags: Mapping[str, str],
                 transitions: Sequence['outputs.GetObjectBucketLifecycleRuleTransitionResult']):
        """
        :param int abort_incomplete_multipart_upload_days: Specifies the number of days after initiating a multipart upload when the multipart upload must be completed
        :param bool enabled: Specifies if the configuration rule is Enabled or Disabled
        :param Sequence['GetObjectBucketLifecycleRuleExpirationArgs'] expirations: Specifies a period in the object's expire
        :param str id: The unique identifier of the bucket.
        :param str prefix: The prefix identifying one or more objects to which the rule applies
        :param Mapping[str, str] tags: The tags associated with the bucket lifecycle
        :param Sequence['GetObjectBucketLifecycleRuleTransitionArgs'] transitions: Define when objects transition to another storage class
        """
        pulumi.set(__self__, "abort_incomplete_multipart_upload_days", abort_incomplete_multipart_upload_days)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "expirations", expirations)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "prefix", prefix)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "transitions", transitions)

    @property
    @pulumi.getter(name="abortIncompleteMultipartUploadDays")
    def abort_incomplete_multipart_upload_days(self) -> int:
        """
        Specifies the number of days after initiating a multipart upload when the multipart upload must be completed
        """
        return pulumi.get(self, "abort_incomplete_multipart_upload_days")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Specifies if the configuration rule is Enabled or Disabled
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def expirations(self) -> Sequence['outputs.GetObjectBucketLifecycleRuleExpirationResult']:
        """
        Specifies a period in the object's expire
        """
        return pulumi.get(self, "expirations")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The unique identifier of the bucket.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def prefix(self) -> str:
        """
        The prefix identifying one or more objects to which the rule applies
        """
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter
    def tags(self) -> Mapping[str, str]:
        """
        The tags associated with the bucket lifecycle
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def transitions(self) -> Sequence['outputs.GetObjectBucketLifecycleRuleTransitionResult']:
        """
        Define when objects transition to another storage class
        """
        return pulumi.get(self, "transitions")


@pulumi.output_type
class GetObjectBucketLifecycleRuleExpirationResult(dict):
    def __init__(__self__, *,
                 days: int):
        """
        :param int days: Specifies the number of days after object creation when the specific rule action takes effect
        """
        pulumi.set(__self__, "days", days)

    @property
    @pulumi.getter
    def days(self) -> int:
        """
        Specifies the number of days after object creation when the specific rule action takes effect
        """
        return pulumi.get(self, "days")


@pulumi.output_type
class GetObjectBucketLifecycleRuleTransitionResult(dict):
    def __init__(__self__, *,
                 days: int,
                 storage_class: str):
        """
        :param int days: Specifies the number of days after object creation when the specific rule action takes effect
        :param str storage_class: Specifies the Scaleway Object Storage class to which you want the object to transition
        """
        pulumi.set(__self__, "days", days)
        pulumi.set(__self__, "storage_class", storage_class)

    @property
    @pulumi.getter
    def days(self) -> int:
        """
        Specifies the number of days after object creation when the specific rule action takes effect
        """
        return pulumi.get(self, "days")

    @property
    @pulumi.getter(name="storageClass")
    def storage_class(self) -> str:
        """
        Specifies the Scaleway Object Storage class to which you want the object to transition
        """
        return pulumi.get(self, "storage_class")


@pulumi.output_type
class GetObjectBucketVersioningResult(dict):
    def __init__(__self__, *,
                 enabled: bool):
        """
        :param bool enabled: Enable versioning. Once you version-enable a bucket, it can never return to an unversioned state
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Enable versioning. Once you version-enable a bucket, it can never return to an unversioned state
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetRedisClusterAclResult(dict):
    def __init__(__self__, *,
                 description: str,
                 id: str,
                 ip: str):
        """
        :param str description: Description of the rule.
        :param str id: The ID of the Redis cluster.
        :param str ip: IPv4 network address of the rule (IP network in a CIDR format).
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Description of the rule.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Redis cluster.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        IPv4 network address of the rule (IP network in a CIDR format).
        """
        return pulumi.get(self, "ip")


@pulumi.output_type
class GetRedisClusterPrivateNetworkResult(dict):
    def __init__(__self__, *,
                 endpoint_id: str,
                 id: str,
                 service_ips: Sequence[str],
                 zone: str):
        """
        :param str endpoint_id: The ID of the endpoint.
        :param str id: The ID of the Redis cluster.
        :param Sequence[str] service_ips: List of IPv4 addresses of the private network with a CIDR notation
        :param str zone: `region`) The zone in which the server exists.
        """
        pulumi.set(__self__, "endpoint_id", endpoint_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "service_ips", service_ips)
        pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> str:
        """
        The ID of the endpoint.
        """
        return pulumi.get(self, "endpoint_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Redis cluster.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="serviceIps")
    def service_ips(self) -> Sequence[str]:
        """
        List of IPv4 addresses of the private network with a CIDR notation
        """
        return pulumi.get(self, "service_ips")

    @property
    @pulumi.getter
    def zone(self) -> str:
        """
        `region`) The zone in which the server exists.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class GetRedisClusterPublicNetworkResult(dict):
    def __init__(__self__, *,
                 id: str,
                 ips: Sequence[str],
                 port: int):
        """
        :param str id: The ID of the Redis cluster.
        :param int port: TCP port of the endpoint
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ips", ips)
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Redis cluster.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def ips(self) -> Sequence[str]:
        return pulumi.get(self, "ips")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        TCP port of the endpoint
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class GetSecretEphemeralPolicyResult(dict):
    def __init__(__self__, *,
                 action: str,
                 expires_once_accessed: bool,
                 ttl: str):
        """
        :param str action: Action to perform when the version of a secret expires.
        :param bool expires_once_accessed: True if the secret version expires after a single user access.
        :param str ttl: Time frame, from one second and up to one year, during which the secret's versions are valid. Has to be specified in Go Duration format
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "expires_once_accessed", expires_once_accessed)
        pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        Action to perform when the version of a secret expires.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="expiresOnceAccessed")
    def expires_once_accessed(self) -> bool:
        """
        True if the secret version expires after a single user access.
        """
        return pulumi.get(self, "expires_once_accessed")

    @property
    @pulumi.getter
    def ttl(self) -> str:
        """
        Time frame, from one second and up to one year, during which the secret's versions are valid. Has to be specified in Go Duration format
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class GetTemDomainReputationResult(dict):
    def __init__(__self__, *,
                 previous_score: int,
                 previous_scored_at: str,
                 score: int,
                 scored_at: str,
                 status: str):
        """
        :param int previous_score: The previously-calculated domain's reputation score
        :param str previous_scored_at: Time and date the previous reputation score was calculated
        :param int score: A range from 0 to 100 that determines your domain's reputation score
        :param str scored_at: Time and date the score was calculated
        :param str status: Status of the domain's reputation
        """
        pulumi.set(__self__, "previous_score", previous_score)
        pulumi.set(__self__, "previous_scored_at", previous_scored_at)
        pulumi.set(__self__, "score", score)
        pulumi.set(__self__, "scored_at", scored_at)
        pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="previousScore")
    def previous_score(self) -> int:
        """
        The previously-calculated domain's reputation score
        """
        return pulumi.get(self, "previous_score")

    @property
    @pulumi.getter(name="previousScoredAt")
    def previous_scored_at(self) -> str:
        """
        Time and date the previous reputation score was calculated
        """
        return pulumi.get(self, "previous_scored_at")

    @property
    @pulumi.getter
    def score(self) -> int:
        """
        A range from 0 to 100 that determines your domain's reputation score
        """
        return pulumi.get(self, "score")

    @property
    @pulumi.getter(name="scoredAt")
    def scored_at(self) -> str:
        """
        Time and date the score was calculated
        """
        return pulumi.get(self, "scored_at")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of the domain's reputation
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetVpcGatewayNetworkIpamConfigResult(dict):
    def __init__(__self__, *,
                 ipam_ip_id: str,
                 push_default_route: bool):
        """
        :param str ipam_ip_id: Use this IPAM-booked IP ID as the Gateway's IP in this Private Network
        :param bool push_default_route: Defines whether the default route is enabled on that Gateway Network
        """
        pulumi.set(__self__, "ipam_ip_id", ipam_ip_id)
        pulumi.set(__self__, "push_default_route", push_default_route)

    @property
    @pulumi.getter(name="ipamIpId")
    def ipam_ip_id(self) -> str:
        """
        Use this IPAM-booked IP ID as the Gateway's IP in this Private Network
        """
        return pulumi.get(self, "ipam_ip_id")

    @property
    @pulumi.getter(name="pushDefaultRoute")
    def push_default_route(self) -> bool:
        """
        Defines whether the default route is enabled on that Gateway Network
        """
        return pulumi.get(self, "push_default_route")


@pulumi.output_type
class GetVpcPrivateNetworkIpv4SubnetResult(dict):
    def __init__(__self__, *,
                 address: str,
                 created_at: str,
                 id: str,
                 prefix_length: int,
                 subnet: str,
                 subnet_mask: str,
                 updated_at: str):
        """
        :param str address: The network address of the subnet in dotted decimal notation, e.g., '192.168.0.0' for a '192.168.0.0/24' subnet
        :param str created_at: The date and time of the creation of the subnet
        :param str id: The ID of the Private Network.
        :param int prefix_length: The length of the network prefix, e.g., 24 for a 255.255.255.0 mask
        :param str subnet: The subnet CIDR
        :param str subnet_mask: The subnet mask expressed in dotted decimal notation, e.g., '255.255.255.0' for a /24 subnet
        :param str updated_at: The date and time of the last update of the subnet
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "prefix_length", prefix_length)
        pulumi.set(__self__, "subnet", subnet)
        pulumi.set(__self__, "subnet_mask", subnet_mask)
        pulumi.set(__self__, "updated_at", updated_at)

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        The network address of the subnet in dotted decimal notation, e.g., '192.168.0.0' for a '192.168.0.0/24' subnet
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        The date and time of the creation of the subnet
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Private Network.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> int:
        """
        The length of the network prefix, e.g., 24 for a 255.255.255.0 mask
        """
        return pulumi.get(self, "prefix_length")

    @property
    @pulumi.getter
    def subnet(self) -> str:
        """
        The subnet CIDR
        """
        return pulumi.get(self, "subnet")

    @property
    @pulumi.getter(name="subnetMask")
    def subnet_mask(self) -> str:
        """
        The subnet mask expressed in dotted decimal notation, e.g., '255.255.255.0' for a /24 subnet
        """
        return pulumi.get(self, "subnet_mask")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> str:
        """
        The date and time of the last update of the subnet
        """
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class GetVpcPrivateNetworkIpv6SubnetResult(dict):
    def __init__(__self__, *,
                 address: str,
                 created_at: str,
                 id: str,
                 prefix_length: int,
                 subnet: str,
                 subnet_mask: str,
                 updated_at: str):
        """
        :param str address: The network address of the subnet in dotted decimal notation, e.g., '192.168.0.0' for a '192.168.0.0/24' subnet
        :param str created_at: The date and time of the creation of the subnet
        :param str id: The ID of the Private Network.
        :param int prefix_length: The length of the network prefix, e.g., 24 for a 255.255.255.0 mask
        :param str subnet: The subnet CIDR
        :param str subnet_mask: The subnet mask expressed in dotted decimal notation, e.g., '255.255.255.0' for a /24 subnet
        :param str updated_at: The date and time of the last update of the subnet
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "prefix_length", prefix_length)
        pulumi.set(__self__, "subnet", subnet)
        pulumi.set(__self__, "subnet_mask", subnet_mask)
        pulumi.set(__self__, "updated_at", updated_at)

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        The network address of the subnet in dotted decimal notation, e.g., '192.168.0.0' for a '192.168.0.0/24' subnet
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        The date and time of the creation of the subnet
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Private Network.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> int:
        """
        The length of the network prefix, e.g., 24 for a 255.255.255.0 mask
        """
        return pulumi.get(self, "prefix_length")

    @property
    @pulumi.getter
    def subnet(self) -> str:
        """
        The subnet CIDR
        """
        return pulumi.get(self, "subnet")

    @property
    @pulumi.getter(name="subnetMask")
    def subnet_mask(self) -> str:
        """
        The subnet mask expressed in dotted decimal notation, e.g., '255.255.255.0' for a /24 subnet
        """
        return pulumi.get(self, "subnet_mask")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> str:
        """
        The date and time of the last update of the subnet
        """
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class GetVpcRoutesRouteResult(dict):
    def __init__(__self__, *,
                 created_at: str,
                 description: str,
                 destination: str,
                 id: str,
                 nexthop_ip: str,
                 nexthop_name: str,
                 nexthop_private_network_id: str,
                 nexthop_resource_id: str,
                 nexthop_resource_type: str,
                 region: str,
                 tags: Sequence[str],
                 vpc_id: str):
        """
        :param str created_at: The date on which the route was created (RFC 3339 format).
        :param str description: The description of the route.
        :param str destination: The destination IP or IP range of the route.
        :param str id: The ID of the route.
               > **Important:** route IDs are regional, which means they are of the form `{region}/{id}`, e.g. `fr-par/11111111-1111-1111-1111-111111111111
        :param str nexthop_ip: The IP of the route's next hop.
        :param str nexthop_name: The name of the route's next hop.
        :param str nexthop_private_network_id: The next hop private network ID to filter for. routes with a similar next hop private network ID are listed.
        :param str nexthop_resource_id: The next hop resource ID to filter for. routes with a similar next hop resource ID are listed.
        :param str nexthop_resource_type: The next hop resource type to filter for. routes with a similar next hop resource type are listed.
        :param str region: `region`). The region in which the routes exist.
        :param Sequence[str] tags: List of tags to filter for. routes with these exact tags are listed.
        :param str vpc_id: The VPC ID to filter for. routes with a similar VPC ID are listed.
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "destination", destination)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "nexthop_ip", nexthop_ip)
        pulumi.set(__self__, "nexthop_name", nexthop_name)
        pulumi.set(__self__, "nexthop_private_network_id", nexthop_private_network_id)
        pulumi.set(__self__, "nexthop_resource_id", nexthop_resource_id)
        pulumi.set(__self__, "nexthop_resource_type", nexthop_resource_type)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "vpc_id", vpc_id)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        The date on which the route was created (RFC 3339 format).
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the route.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def destination(self) -> str:
        """
        The destination IP or IP range of the route.
        """
        return pulumi.get(self, "destination")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the route.
        > **Important:** route IDs are regional, which means they are of the form `{region}/{id}`, e.g. `fr-par/11111111-1111-1111-1111-111111111111
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="nexthopIp")
    def nexthop_ip(self) -> str:
        """
        The IP of the route's next hop.
        """
        return pulumi.get(self, "nexthop_ip")

    @property
    @pulumi.getter(name="nexthopName")
    def nexthop_name(self) -> str:
        """
        The name of the route's next hop.
        """
        return pulumi.get(self, "nexthop_name")

    @property
    @pulumi.getter(name="nexthopPrivateNetworkId")
    def nexthop_private_network_id(self) -> str:
        """
        The next hop private network ID to filter for. routes with a similar next hop private network ID are listed.
        """
        return pulumi.get(self, "nexthop_private_network_id")

    @property
    @pulumi.getter(name="nexthopResourceId")
    def nexthop_resource_id(self) -> str:
        """
        The next hop resource ID to filter for. routes with a similar next hop resource ID are listed.
        """
        return pulumi.get(self, "nexthop_resource_id")

    @property
    @pulumi.getter(name="nexthopResourceType")
    def nexthop_resource_type(self) -> str:
        """
        The next hop resource type to filter for. routes with a similar next hop resource type are listed.
        """
        return pulumi.get(self, "nexthop_resource_type")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        `region`). The region in which the routes exist.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter
    def tags(self) -> Sequence[str]:
        """
        List of tags to filter for. routes with these exact tags are listed.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> str:
        """
        The VPC ID to filter for. routes with a similar VPC ID are listed.
        """
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class GetVpcsVpcResult(dict):
    def __init__(__self__, *,
                 created_at: str,
                 id: str,
                 is_default: bool,
                 name: str,
                 organization_id: str,
                 project_id: str,
                 region: str,
                 tags: Sequence[str],
                 update_at: str):
        """
        :param str created_at: Date and time of VPC's creation (RFC 3339 format).
        :param str id: The associated VPC ID.
               > **Important:** VPC IDs are regional, which means they are of the form `{region}/{id}`, e.g. `fr-par/11111111-1111-1111-1111-111111111111
        :param bool is_default: Defines whether the VPC is the default one for its Project.
        :param str name: The VPC name to filter for. VPCs with a similar name are listed.
        :param str organization_id: The Organization ID the VPC is associated with.
        :param str project_id: The ID of the Project the VPC is associated with.
        :param str region: `region`). The region in which the VPCs exist.
        :param Sequence[str] tags: List of tags to filter for. VPCs with these exact tags are listed.
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_default", is_default)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "organization_id", organization_id)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "update_at", update_at)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        Date and time of VPC's creation (RFC 3339 format).
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The associated VPC ID.
        > **Important:** VPC IDs are regional, which means they are of the form `{region}/{id}`, e.g. `fr-par/11111111-1111-1111-1111-111111111111
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> bool:
        """
        Defines whether the VPC is the default one for its Project.
        """
        return pulumi.get(self, "is_default")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The VPC name to filter for. VPCs with a similar name are listed.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="organizationId")
    def organization_id(self) -> str:
        """
        The Organization ID the VPC is associated with.
        """
        return pulumi.get(self, "organization_id")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        The ID of the Project the VPC is associated with.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        `region`). The region in which the VPCs exist.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter
    def tags(self) -> Sequence[str]:
        """
        List of tags to filter for. VPCs with these exact tags are listed.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="updateAt")
    def update_at(self) -> str:
        return pulumi.get(self, "update_at")


@pulumi.output_type
class GetWebHostOfferProductResult(dict):
    def __init__(__self__, *,
                 databases_quota: int,
                 email_accounts_quota: int,
                 email_storage_quota: int,
                 hosting_storage_quota: int,
                 name: str,
                 option: bool,
                 ram: int,
                 support_included: bool,
                 v_cpu: int):
        """
        :param int databases_quota: The quota of databases.
        :param int email_accounts_quota: The quota of email accounts.
        :param int email_storage_quota: The quota of email storage.
        :param int hosting_storage_quota: The quota of hosting storage.
        :param str name: The offer name. Only one of `name` and `offer_id` should be specified.
        :param bool option: The product option.
        :param int ram: The capacity of the memory in GB.
        :param bool support_included: If support is included.
        :param int v_cpu: The number of cores.
        """
        pulumi.set(__self__, "databases_quota", databases_quota)
        pulumi.set(__self__, "email_accounts_quota", email_accounts_quota)
        pulumi.set(__self__, "email_storage_quota", email_storage_quota)
        pulumi.set(__self__, "hosting_storage_quota", hosting_storage_quota)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "option", option)
        pulumi.set(__self__, "ram", ram)
        pulumi.set(__self__, "support_included", support_included)
        pulumi.set(__self__, "v_cpu", v_cpu)

    @property
    @pulumi.getter(name="databasesQuota")
    def databases_quota(self) -> int:
        """
        The quota of databases.
        """
        return pulumi.get(self, "databases_quota")

    @property
    @pulumi.getter(name="emailAccountsQuota")
    def email_accounts_quota(self) -> int:
        """
        The quota of email accounts.
        """
        return pulumi.get(self, "email_accounts_quota")

    @property
    @pulumi.getter(name="emailStorageQuota")
    def email_storage_quota(self) -> int:
        """
        The quota of email storage.
        """
        return pulumi.get(self, "email_storage_quota")

    @property
    @pulumi.getter(name="hostingStorageQuota")
    def hosting_storage_quota(self) -> int:
        """
        The quota of hosting storage.
        """
        return pulumi.get(self, "hosting_storage_quota")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The offer name. Only one of `name` and `offer_id` should be specified.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def option(self) -> bool:
        """
        The product option.
        """
        return pulumi.get(self, "option")

    @property
    @pulumi.getter
    def ram(self) -> int:
        """
        The capacity of the memory in GB.
        """
        return pulumi.get(self, "ram")

    @property
    @pulumi.getter(name="supportIncluded")
    def support_included(self) -> bool:
        """
        If support is included.
        """
        return pulumi.get(self, "support_included")

    @property
    @pulumi.getter(name="vCpu")
    def v_cpu(self) -> int:
        """
        The number of cores.
        """
        return pulumi.get(self, "v_cpu")


@pulumi.output_type
class GetWebhostingCpanelUrlResult(dict):
    def __init__(__self__, *,
                 dashboard: str,
                 webmail: str):
        pulumi.set(__self__, "dashboard", dashboard)
        pulumi.set(__self__, "webmail", webmail)

    @property
    @pulumi.getter
    def dashboard(self) -> str:
        return pulumi.get(self, "dashboard")

    @property
    @pulumi.getter
    def webmail(self) -> str:
        return pulumi.get(self, "webmail")


@pulumi.output_type
class GetWebhostingOptionResult(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


